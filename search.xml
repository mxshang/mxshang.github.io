<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>学习笔记—前端基础之ES6(2)</title>
    <url>/2021/05/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BES6-2/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><h2 id="Set-Map"><a href="#Set-Map" class="headerlink" title="Set / Map"></a>Set / Map</h2><p><code>Set</code> 和 <code>Map</code> 是两种存储结构。</p><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMTAyMjkxMDgyMTE0OTMxMi8xMDIzMDI0MTgxMTA5NDQw">Map和Set | 廖雪峰的官网<i class="fa fa-external-link-alt"></i></span></p></blockquote><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>首先，<code>Set</code>属于 <em>object</em> 类型（如 <strong>下图</strong> 所示）</p><p><img data-src="pic5.png" alt></p><p><code>new Set([value]) [value]:Array</code></p><p><img data-src="pic6.png" alt></p><p><code>Set</code> 是一组 <strong>key 集合</strong>，但<strong>不存储 value</strong>。由于<strong>key不能重复</strong>，所以，在<code>Set</code>中，<strong>没有重复的key</strong>。</p><p>因此，我们常常利用 <code>Set</code> 来实现 <em>数组去重</em> 。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure><p>通过<code>add(key)</code>方法可以添加元素到<code>Set</code>中，可以重复添加，但不会有效果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// 仍然是 Set &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure><p>通过<code>delete(key)</code>方法可以删除元素</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.delete(<span class="number">3</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 4&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以用以下方法对 <code>Set {1, 2, 3, 4}</code> 进行数组转换处理。</p><ul><li><p>展开运算符</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...s];</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li><li><p>Array.form()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(s);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// // [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li></ul><p>同时，我们可以利用<code>Set</code>实现各种处理，例如实现集合的 <em>并集<em>、</em>交集</em> 和 <em>差集</em> 等。</p><p>假如我们现在有以下两个数组。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr1);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr2);</span><br></pre></td></tr></table></figure><ul><li><p>并集</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...new <span class="built_in">Set</span>([...s1, ...s2])]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(union()); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p>交集</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intersection</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...s1].filter(<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.has(val)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(intersection()); <span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>这里我们用到了 <code>filter</code> 这个高阶函数来进行处理。</p></li><li><p>差集</p><p>差集很好理解，其实就是交集取反，就是 <em>差集</em>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...s1].filter(<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !s2.has(val)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(diff()); <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><code>Map</code> 也属于 <em>Object</em> 类型</p><p><img data-src="pic7.png" alt></p><p><code>Map</code>是一组<strong>键值对</strong>的结构，具有<strong>极快的查找速度</strong>。</p><p>先对 <code>Map</code> 进行初始化</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'a'</span>, <span class="number">1</span>], [<span class="string">'b'</span>, <span class="number">2</span>], [<span class="string">'3'</span>, <span class="number">3</span>]]);</span><br><span class="line">m.get(<span class="string">'b'</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>我们新建一个<code>Map</code> ，需要一个二维数组，或者直接初始化一个空的 <code>Map</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 空Map</span></span><br><span class="line">m.set(<span class="string">'a'</span>, <span class="number">1</span>); <span class="comment">// 添加新的key-value</span></span><br><span class="line">m.set(<span class="string">'b'</span>, <span class="number">2</span>);</span><br><span class="line">m.has(<span class="string">'a'</span>); <span class="comment">// 是否存在key 'a': true</span></span><br><span class="line">m.get(<span class="string">'a'</span>); <span class="comment">// 1</span></span><br><span class="line">m.delete(<span class="string">'a'</span>); <span class="comment">// 删除key 'a'</span></span><br><span class="line">m.get(<span class="string">'a'</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>由于一个 <code>key</code> 只能对应一个 <code>value</code> ，所以，多次对一个key放入value，<strong>后面的值会把前面的值替换掉</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="string">'a'</span>, <span class="number">1</span>);</span><br><span class="line">m.set(<span class="string">'a'</span>, <span class="number">11</span>);</span><br><span class="line">m.get(<span class="string">'a'</span>); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>在这里我们可以思考一个问题，<code>Map</code> 的 <code>key</code> 是否可以是一个对象呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line">m.set(obj, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m);<span class="comment">// &#123;&#123;a: 1&#125; =&gt; 2&#125;</span></span><br></pre></td></tr></table></figure><p>答案显然是可以的。</p><p>这里还有一个小问题，假如我们清空上述的对象类型，那么 <code>key</code> 值是否还存在呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line">m.set(obj, <span class="number">2</span>);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(m); <span class="comment">// &#123;&#123;a: 1&#125; =&gt; 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>这里我们可以理解为，我们定义的 <em>变量obj</em> 指向 <em>内存空间obj</em> ，然后我们定义了一个<code>Set</code>类型，其<code>key</code>值指向 <em>内存空间obj</em> 。</p><p><img data-src="pic8.png" alt></p><p>而后我们又将 <em>变量obj</em> 清空，其原来的 <em>内存空间obj</em> 并没有被销毁，只是改变了其指向。所以 <em>变量obj</em> 的指向并不影响 <code>Set</code> 中 <code>key</code> 的指向，所以才有了上述问题的产生和结果。</p><p><img data-src="pic9.png" alt></p><p>针对于上述问题，我们可以提出来另外一个存储结构类型 <code>weakMap</code>，其key值是会被清空的。</p><h4 id="weakMap"><a href="#weakMap" class="headerlink" title="weakMap"></a>weakMap</h4><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvV2Vha01hcA==">WeakMap-JavaScript | MDN<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><code>WeakMap</code> 对象是一组 <code>key/value</code> (键值对)的集合，其中的键是 <strong>弱引用</strong> 的。其 <code>key</code> 必须是对象，而 <code>value</code> 可以是任意的。</p><p><code>WeakMap</code> 的 key 只能是 <code>Object</code> 类型。 <strong>原始数据类型</strong> 是不能作为 key 的（比如 <code>Symbol</code>）。</p><p>所以我们就可以得出来一个结论了。</p><p><code>Map</code> 的 <code>key</code> 值是强引用类型，在堆内存中存在指向关系，所以不会被垃圾回收机制给清除掉。</p><p>而 <code>weakMap</code> 的 <code>key</code> 值是弱引用类型，会被垃圾回收机制清除掉。</p><h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>ES6</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—前端基础之ES6(1)</title>
    <url>/2021/05/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BES6-1/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><h2 id="let、const和var的区别"><a href="#let、const和var的区别" class="headerlink" title="let、const和var的区别"></a>let、const和var的区别</h2><p><code>let</code>、<code>const</code> 和 <code>var</code>都是用来定义变量的，那它们有什么区别呢？</p><h3 id="var的特点"><a href="#var的特点" class="headerlink" title="var的特点"></a>var的特点</h3><ol><li><p>对<strong>全局变量</strong>造成污染</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">//1</span></span><br></pre></td></tr></table></figure></li><li><p>存在<strong>变量提升</strong>机制</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"a"</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>var</code>可以被<strong>重复声明</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>var</code>的作用域只有<strong>全局作用域</strong>和<strong>函数作用域</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="let的特点"><a href="#let的特点" class="headerlink" title="let的特点"></a>let的特点</h3><ol><li><p>不可以被重复声明</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure></li><li><p>存在块级作用域</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// 0 1 2 ... 8 9</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>如果使用<code>var</code>进行定义，则会全部输出10</em></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// 10</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>暂时性死区</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// Cannot access 'a' before initialization</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>因为ES6在定义变量的时候，会把同名的变量定义为两个变量</em>（如 <strong>下图</strong> 所示）<br><img data-src="pic1.png" alt></p></li></ol><h3 id="const的特点"><a href="#const的特点" class="headerlink" title="const的特点"></a>const的特点</h3><p><code>const</code>是<strong>不可变的量</strong>，也就是<strong>常量</strong>。</p><ol><li><p><code>const</code>定义的变量不可以对其值进行修改。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line">PI = <span class="number">3.15</span>; <span class="comment">// Assignment to constant variable.</span></span><br></pre></td></tr></table></figure></li><li><p><code>const</code>可以修改同一地址（堆内存）中的值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line">a.b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// &#123;b: 2&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>在解构中，有下面两部分参与：</p><p><strong>解构的源</strong>：解构赋值表达式的右边部分。</p><p><strong>解构的目标</strong>：解构赋值表达式的左边部分。</p><h3 id="数组解构-Array"><a href="#数组解构-Array" class="headerlink" title="数组解构(Array)"></a>数组解构(Array)</h3><ol><li><p>基本使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// c = 3</span></span><br></pre></td></tr></table></figure></li><li><p>嵌套使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, [[b], c]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// c = 3</span></span><br></pre></td></tr></table></figure></li><li><p>可以忽略未定义变量</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, , b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 3</span></span><br></pre></td></tr></table></figure></li><li><p>非完全解构</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b] = []; <span class="comment">// a = 1, b = undefined</span></span><br></pre></td></tr></table></figure></li><li><p>字符串解构等</p><p><em>在数组的解构中，解构的目标若为<strong>可遍历对象</strong>，皆可进行解构赋值。</em></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line"><span class="comment">// a = 'h'</span></span><br><span class="line"><span class="comment">// b = 'e'</span></span><br><span class="line"><span class="comment">// c = 'l'</span></span><br><span class="line"><span class="comment">// d = 'l'</span></span><br><span class="line"><span class="comment">// e = 'o'</span></span><br></pre></td></tr></table></figure></li><li><p>解构默认值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">2</span>] = [<span class="literal">undefined</span>]; <span class="comment">// a = 2</span></span><br></pre></td></tr></table></figure><p><em>当解构模式有匹配结果，且匹配结果是 <code>undefined</code> 时，会触发默认值作为返回结果。</em></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [];     <span class="comment">// a = 3, b = 3</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>];    <span class="comment">// a = 1, b = 1</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// a = 1, b = 2</span></span><br></pre></td></tr></table></figure><ul><li>a 与 b 匹配结果为 <em>undefined</em> ，触发默认值：<strong>a = 3; b = a =3</strong></li><li>a 正常解构赋值，匹配结果为 <em>a = 1*，b 匹配结果 *undefined</em> ，触发默认值：<strong>b = a =1</strong></li><li>a 与 b 正常解构赋值，匹配结果为 <strong>a = 1，b = 2</strong></li></ul></li><li><p>扩展运算符</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = [2, 3]</span></span><br></pre></td></tr></table></figure><p>扩展运算符，又叫 <strong>展开运算符</strong> 或 <strong>剩余运算符</strong>。可以利用扩展运算符，对数组进行合并。（如 <strong>下图</strong> 所示）![(pic2.png)</p></li></ol><h3 id="对象解构-Object"><a href="#对象解构-Object" class="headerlink" title="对象解构(Object)"></a>对象解构(Object)</h3><ol><li><p>基本使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line"><span class="comment">// foo = 'aaa'</span></span><br><span class="line"><span class="comment">// bar = 'bbb'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">baz</span> : foo &#125; = &#123; <span class="attr">baz</span> : <span class="string">'ddd'</span> &#125;;</span><br><span class="line"><span class="comment">// foo = 'ddd'</span></span><br></pre></td></tr></table></figure></li><li><p>可嵌套/可忽略</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [<span class="string">'hello'</span>, &#123;<span class="attr">y</span>: <span class="string">'world'</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line"><span class="comment">// x = 'hello'</span></span><br><span class="line"><span class="comment">// y = 'world'</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [<span class="string">'hello'</span>, &#123;<span class="attr">y</span>: <span class="string">'world'</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123;  &#125;] &#125; = obj;</span><br><span class="line"><span class="comment">// x = 'hello'</span></span><br></pre></td></tr></table></figure></li><li><p>非完全解构</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [&#123;<span class="attr">y</span>: <span class="string">'world'</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [&#123; y &#125;, x ] &#125; = obj;</span><br><span class="line"><span class="comment">// x = undefined</span></span><br><span class="line"><span class="comment">// y = 'world'</span></span><br></pre></td></tr></table></figure></li><li><p>解构默认值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a = <span class="number">10</span>, b = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// a = 3; b = 5;</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span>: aa = <span class="number">10</span>, <span class="attr">b</span>: bb = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// aa = 3; bb = 5;</span></span><br></pre></td></tr></table></figure></li><li><p>扩展运算符</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, b, ...rest&#125; = &#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span>&#125;;</span><br><span class="line"><span class="comment">// a = 10</span></span><br><span class="line"><span class="comment">// b = 20</span></span><br><span class="line"><span class="comment">// rest = &#123;c: 30, d: 40&#125;</span></span><br></pre></td></tr></table></figure><p>在ES6中，我们可以通过 <em>扩展运算符</em> 实现很多应用，例如 <strong>深拷贝和浅拷贝</strong>。</p><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS93M2Nub3RlL2RlY29uc3RydWN0aW9uLWFzc2lnbm1lbnQuaHRtbA==">ES6 解构赋值 | 菜鸟教程<i class="fa fa-external-link-alt"></i></span></p></blockquote></li></ol><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p><strong>深拷贝</strong>：拷贝后与原数组无关，会使 <em>拷贝后的数组</em> 在堆中指向一个新的内存空间。<br><strong>浅拷贝</strong>：拷贝后与原数组有关，<em>新数组</em> 与 <em>原数组</em> 指向同一个堆内存。</p><p><img data-src="pic3.png" alt></p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><p><code>Object.assign()</code> 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 <code>Object.assign()</code> 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: &#123;<span class="attr">name</span>: <span class="string">"mxs"</span>, <span class="attr">age</span>: <span class="number">26</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line">obj2.a.name = <span class="string">"zd"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a.name); <span class="comment">// zd</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat()"></a>Array.prototype.concat()</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, &#123;</span><br><span class="line">  name: <span class="string">'mxs'</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.concat();    </span><br><span class="line">arr2[<span class="number">2</span>].name = <span class="string">'zd'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, &#123;name:'zd'&#125;]</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-slice"><a href="#Array-prototype-slice" class="headerlink" title="Array.prototype.slice()"></a>Array.prototype.slice()</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, &#123;</span><br><span class="line">  name: <span class="string">'mxs'</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.slice();</span><br><span class="line">arr2[<span class="number">2</span>].name = <span class="string">'zd'</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, &#123;name:'zd'&#125;]</span></span><br></pre></td></tr></table></figure><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><p>扩展运算符只能拷贝一层 <strong>对象</strong> / <strong>数组</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">'zd'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">age</span>:&#123;<span class="attr">count</span>:<span class="number">26</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> allObj = &#123;...school,...my&#125;;</span><br><span class="line">obj2.age.count = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(allObj); <span class="comment">// &#123;&#123;name: "zd", age: &#123;count: 100&#125;&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;age: &#123;count: 100&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>可以发现两个对象都改变了，这就是只实现了 <strong>浅拷贝</strong>。</p><p>如果想要实现 <strong>深拷贝</strong>，会十分的麻烦。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">'zd'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">age</span>:&#123;<span class="attr">count</span>:<span class="number">26</span>&#125;,<span class="attr">name</span>:<span class="string">'mxs'</span>&#125;;</span><br><span class="line"><span class="comment">// 把原来的my放到新的对象中，用一个新的对象age将原始的age也拷贝一份</span></span><br><span class="line"><span class="keyword">let</span> newObj2 = &#123;...obj2,<span class="attr">age</span>:&#123;...obj2.age&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> allObj = &#123;...obj1,...newObj2&#125;;</span><br><span class="line">obj2.age.count = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(allObj); <span class="comment">// &#123;&#123;name: "mxs", age: &#123;count: 26&#125;&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;&#123;name: "mxs", age: &#123;count: 100&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="深拷贝和浅拷贝-1"><a href="#深拷贝和浅拷贝-1" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p><strong>深拷贝</strong>：拷贝后与原数组无关，会使 <em>拷贝后的数组</em> 在堆中指向一个新的内存空间。<br><strong>浅拷贝</strong>：拷贝后与原数组有关，<em>新数组</em> 与 <em>原数组</em> 指向同一个堆内存。</p><p><img data-src="pic3.png" alt></p><h3 id="浅拷贝-1"><a href="#浅拷贝-1" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><h4 id="Object-assign-1"><a href="#Object-assign-1" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><p><code>Object.assign()</code> 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 <code>Object.assign()</code> 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: &#123;<span class="attr">name</span>: <span class="string">"mxs"</span>, <span class="attr">age</span>: <span class="number">26</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line">obj2.a.name = <span class="string">"zd"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a.name); <span class="comment">// zd</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-concat-1"><a href="#Array-prototype-concat-1" class="headerlink" title="Array.prototype.concat()"></a>Array.prototype.concat()</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, &#123;</span><br><span class="line">  name: <span class="string">'mxs'</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.concat();    </span><br><span class="line">arr2[<span class="number">2</span>].name = <span class="string">'zd'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, &#123;name:'zd'&#125;]</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-slice-1"><a href="#Array-prototype-slice-1" class="headerlink" title="Array.prototype.slice()"></a>Array.prototype.slice()</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, &#123;</span><br><span class="line">  name: <span class="string">'mxs'</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.slice();</span><br><span class="line">arr2[<span class="number">2</span>].name = <span class="string">'zd'</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, &#123;name:'zd'&#125;]</span></span><br></pre></td></tr></table></figure><h4 id="扩展运算符-1"><a href="#扩展运算符-1" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><p>扩展运算符只能拷贝一层 <strong>对象</strong> / <strong>数组</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">'zd'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">age</span>:&#123;<span class="attr">count</span>:<span class="number">26</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> allObj = &#123;...school,...my&#125;;</span><br><span class="line">obj2.age.count = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(allObj); <span class="comment">// &#123;&#123;name: "zd", age: &#123;count: 100&#125;&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;age: &#123;count: 100&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>可以发现两个对象都改变了，这就是只实现了 <strong>浅拷贝</strong>。</p><p>如果想要实现 <strong>深拷贝</strong>，会十分的麻烦。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">'zd'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">age</span>:&#123;<span class="attr">count</span>:<span class="number">26</span>&#125;,<span class="attr">name</span>:<span class="string">'mxs'</span>&#125;;</span><br><span class="line"><span class="comment">// 把原来的my放到新的对象中，用一个新的对象age将原始的age也拷贝一份</span></span><br><span class="line"><span class="keyword">let</span> newObj2 = &#123;...obj2,<span class="attr">age</span>:&#123;...obj2.age&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> allObj = &#123;...obj1,...newObj2&#125;;</span><br><span class="line">obj2.age.count = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(allObj); <span class="comment">// &#123;&#123;name: "mxs", age: &#123;count: 26&#125;&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;&#123;name: "mxs", age: &#123;count: 100&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><h4 id="JSON-parse-JSON-stringify"><a href="#JSON-parse-JSON-stringify" class="headerlink" title="JSON.parse(JSON.stringify())"></a>JSON.parse(JSON.stringify())</h4><p>用<code>JSON.stringify</code>将对象转成JSON字符串，再用<code>JSON.parse()</code>把字符串解析成对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">'zd'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">age</span>:&#123;<span class="attr">count</span>:<span class="number">26</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> allObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(&#123;...obj1,...obj2&#125;));</span><br><span class="line">obj2.age.count = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(allObj); <span class="comment">// &#123;name: 'zd', age: &#123; count: 26 &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>但是需要注意的是，<code>(JSON.stringify([value]))</code> 这种方法虽然可以实现深拷贝，但是却不能拷贝 <code>Function</code>、<code>undefined</code> 和 <code>Symbol</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">'zd'</span>, <span class="attr">age</span>:&#123;&#125;, <span class="attr">count</span>:<span class="number">26</span>, <span class="attr">a</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="attr">b</span>:<span class="literal">null</span>, <span class="attr">c</span>:<span class="literal">undefined</span>, <span class="attr">d</span>:<span class="built_in">Symbol</span>(<span class="string">'zd'</span>)&#125;</span><br><span class="line"><span class="keyword">let</span> allObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(allObj); <span class="comment">// &#123;name: 'zd', age: &#123;&#125;, count: 26, b: null&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以看到，最终被拷贝下来的，只有 <code>String</code> 、<code>Object</code>、 <code>Number</code> 和 <code>Null</code> 这几种数据类型。</p><h4 id="lodash库"><a href="#lodash库" class="headerlink" title="lodash库"></a>lodash库</h4><p>我们可以通过 <strong>loadash库</strong>中的 <code>cloneDeep</code> 方法来实现深克隆。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">   a: <span class="number">1</span>,</span><br><span class="line">   b: &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">   c: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> cloneObj = _.cloneDeep(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj.a.b === cloneObj.a.b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="手写实现深拷贝"><a href="#手写实现深拷贝" class="headerlink" title="手写实现深拷贝"></a>手写实现深拷贝</h4><p>我们先来看一下完整的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj,hash = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (hash.has(obj)) <span class="keyword">return</span> hash.get(obj);</span><br><span class="line">  <span class="keyword">let</span> cloneObj = <span class="keyword">new</span> obj.constructor;</span><br><span class="line">  hash.set(obj, cloneObj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.hasOwnProperty.call(obj, key)) &#123;</span><br><span class="line">      cloneObj[key] = deepClone(obj[key], hash);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">'zd'</span>, <span class="attr">age</span>:&#123;&#125;, <span class="attr">count</span>:<span class="number">26</span>, <span class="attr">a</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="attr">b</span>:<span class="literal">null</span>, <span class="attr">c</span>:<span class="literal">undefined</span>, <span class="attr">d</span>:<span class="built_in">Symbol</span>(<span class="string">'zd'</span>)&#125;</span><br><span class="line"><span class="keyword">let</span> allObj = deepClone(obj);</span><br><span class="line"><span class="built_in">console</span>.log(allObj); <span class="comment">// &#123;name: 'zd', age: &#123;&#125;, count: 26, a: [Function: a], b: null, c: undefined, d: Symbol(zd)&#125;</span></span><br></pre></td></tr></table></figure><p>如果我们想要手写一套深克隆的函数方法，我们需要先搞懂其实现思路。</p><p>简单来说，其实现思路就是 <em>类型判断</em>，<em>克隆数据类型</em>， <em>遍历循环</em>，最后进行 <em>结果输出</em>。</p><ol><li><p>我们先思考，为什么要进行 <em>类型判断</em> ？</p><p>在此之前，我们需要先要清楚 <strong>数据类型判断方式</strong>。</p><ul><li>typeof</li><li>instanceof / constructor</li><li>Object.prototype.toString.call([value])</li></ul><p>然后我们再来看代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果obj是null或者undefined，则直接将结果返回</span></span><br><span class="line"><span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line"><span class="comment">// 如果obj是基础数据类型或者函数，则直接将结果返回(也就是说，函数不需要进行任何处理)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> obj;</span><br><span class="line"><span class="comment">// 如果obj不是对象或数组，则直接将结果返回</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br></pre></td></tr></table></figure><p>通过上面的代码，我们可以发现，剩下的只有两种数据类型 <strong>数组</strong> 和 <strong>对象</strong>。</p><p>那么我们就清楚了，进行 <em>类型判断</em> ，其目的就是为了将需要进行深克隆数据类型筛选出来。</p></li><li><p>然后再思考，如何 <em>克隆</em> 传入对象的 <em>数据类型</em> 呢？</p><p>最常用的方案如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cloneObj = <span class="built_in">Object</span>.prototype.toString.call(obj) === [<span class="string">'Object Array'</span>] ? [] : &#123;&#125;;</span><br></pre></td></tr></table></figure><p>但是这种写法太麻烦了，我们有更简单的实现方案。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// obj不是数组就是对象，将其进行克隆</span></span><br><span class="line"><span class="keyword">let</span> cloneObj = <span class="keyword">new</span> obj.constructor;</span><br></pre></td></tr></table></figure><p>根据 <strong>原型链</strong> 的指向原则，我们可以利用上述方案来创建一个新的数据类型对象。(如 <strong>下图</strong> 所示)</p><p><img data-src="pic4.png" alt></p><p><em>克隆数据类型</em> 的目的，其实就是为了进行下一步的 <em>遍历循环</em>。</p></li><li><p>接着，我们要进行 <em>遍历循环</em> 。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.hasOwnProperty.call(obj, key)) &#123;</span><br><span class="line">    <span class="comment">// 进行递归，实现深克隆</span></span><br><span class="line">    cloneObj[key] = deepClone(obj[key]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 <code>forin</code> 进行循环，在对象复制前，我们都会将值进行递归，再次执行当前方法，判断是否有深层属性。直到递归至没有深层属性为止。</p><p>然后将结果赋值给<code>cloneObj</code>，最后把结果进行输出。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> cloneObj</span><br></pre></td></tr></table></figure><p>但是这种写法还存在一个问题，就是无法进行 <strong>循环引用</strong> 。</p><p>如果要进行循环引用，就会发生 <strong>栈内存溢出</strong> 的情况。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:&#123;<span class="attr">name</span>:<span class="string">'mxs'</span>&#125;&#125;</span><br><span class="line">obj.b = obj;</span><br><span class="line"><span class="keyword">let</span> allObj = deepClone(obj);</span><br><span class="line">obj.a.name = <span class="string">'zd'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure><p>为了处理这种问题的发生，我们还需要在进行一步操作。</p></li><li><p>最后，我们需要对 <strong>异常情况</strong> 进行处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br></pre></td></tr></table></figure><p>设定一个 <code>WeakMap</code> 数据类型（关于 <code>WeakMap</code> ，可以 参考文献 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvV2Vha01hcA==">WeakMap-JavaScript | MDN<i class="fa fa-external-link-alt"></i></span> ，或查看我的另一篇博客 <a href="https://mxshang.github.io/2021/05/28/学习笔记—前端基础之ES6-2/#weakMap">ES6 | weakMap</a>）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(hash.has(obj)) <span class="keyword">return</span> hash.get(obj);</span><br><span class="line">hash.set(obj, cloneObj);</span><br></pre></td></tr></table></figure><p>如果是 <code>Object</code>，我们就将其放到 <code>weakMap</code> 中。如果在拷贝之前，这个 <code>Object</code> 就已经存在了，我们就直接将其返回。</p><p>至此，我们的 <strong>深拷贝</strong> 就完成了。</p></li></ol><p>我们可以通过这种思路，写出很多种 <strong>深克隆</strong> 的方案。</p><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>ES6</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
</search>
