<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>学习笔记—前端基础之ES6(1)</title>
    <url>/2021/05/10/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BES6-1/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><h2 id="let、const和var的区别"><a href="#let、const和var的区别" class="headerlink" title="let、const和var的区别"></a>let、const和var的区别</h2><p><code>let</code>、<code>const</code> 和 <code>var</code>都是用来定义变量的，那它们有什么区别呢？</p><h3 id="var的特点"><a href="#var的特点" class="headerlink" title="var的特点"></a>var的特点</h3><ol><li><p>对<strong>全局变量</strong>造成污染</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">//1</span></span><br></pre></td></tr></table></figure></li><li><p>存在<strong>变量提升</strong>机制</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"a"</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>var</code>可以被<strong>重复声明</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>var</code>的作用域只有<strong>全局作用域</strong>和<strong>函数作用域</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="let的特点"><a href="#let的特点" class="headerlink" title="let的特点"></a>let的特点</h3><ol><li><p>不可以被重复声明</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure></li><li><p>存在块级作用域</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// 0 1 2 ... 8 9</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>如果使用<code>var</code>进行定义，则会全部输出10</em></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// 10</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>暂时性死区</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// Cannot access 'a' before initialization</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>因为ES6在定义变量的时候，会把同名的变量定义为两个变量</em>（如 <strong>下图</strong> 所示）<br><img data-src="pic1.png" alt></p></li><li><p>不会绑定在 <code>window</code> 上</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.info(<span class="built_in">window</span>.a);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="const的特点"><a href="#const的特点" class="headerlink" title="const的特点"></a>const的特点</h3><p><code>const</code>是<strong>不可变的量</strong>，也就是<strong>常量</strong>。</p><ol><li><p><code>const</code>定义的变量不可以对其值进行修改。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line">PI = <span class="number">3.15</span>; <span class="comment">// Assignment to constant variable.</span></span><br></pre></td></tr></table></figure></li><li><p><code>const</code>可以修改同一地址（堆内存）中的值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line">a.b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// &#123;b: 2&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>在解构中，有下面两部分参与：</p><p><strong>解构的源</strong>：解构赋值表达式的右边部分。</p><p><strong>解构的目标</strong>：解构赋值表达式的左边部分。</p><h3 id="数组解构-Array"><a href="#数组解构-Array" class="headerlink" title="数组解构(Array)"></a>数组解构(Array)</h3><ol><li><p>基本使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// c = 3</span></span><br></pre></td></tr></table></figure></li><li><p>嵌套使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, [[b], c]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// c = 3</span></span><br></pre></td></tr></table></figure></li><li><p>可以忽略未定义变量</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, , b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 3</span></span><br></pre></td></tr></table></figure></li><li><p>非完全解构</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b] = []; <span class="comment">// a = 1, b = undefined</span></span><br></pre></td></tr></table></figure></li><li><p>字符串解构等</p><p><em>在数组的解构中，解构的目标若为<strong>可遍历对象</strong>，皆可进行解构赋值。</em></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line"><span class="comment">// a = 'h'</span></span><br><span class="line"><span class="comment">// b = 'e'</span></span><br><span class="line"><span class="comment">// c = 'l'</span></span><br><span class="line"><span class="comment">// d = 'l'</span></span><br><span class="line"><span class="comment">// e = 'o'</span></span><br></pre></td></tr></table></figure></li><li><p>解构默认值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">2</span>] = [<span class="literal">undefined</span>]; <span class="comment">// a = 2</span></span><br></pre></td></tr></table></figure><p><em>当解构模式有匹配结果，且匹配结果是 <code>undefined</code> 时，会触发默认值作为返回结果。</em></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [];     <span class="comment">// a = 3, b = 3</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>];    <span class="comment">// a = 1, b = 1</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// a = 1, b = 2</span></span><br></pre></td></tr></table></figure><ul><li>a 与 b 匹配结果为 <em>undefined</em> ，触发默认值：<strong>a = 3; b = a =3</strong></li><li>a 正常解构赋值，匹配结果为 <em>a = 1*，b 匹配结果 *undefined</em> ，触发默认值：<strong>b = a =1</strong></li><li>a 与 b 正常解构赋值，匹配结果为 <strong>a = 1，b = 2</strong></li></ul></li><li><p>扩展运算符</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = [2, 3]</span></span><br></pre></td></tr></table></figure><p>扩展运算符，又叫 <strong>展开运算符</strong> 或 <strong>剩余运算符</strong>。可以利用扩展运算符，对数组进行合并。（如 <strong>下图</strong> 所示）![(pic2.png)</p></li></ol><h3 id="对象解构-Object"><a href="#对象解构-Object" class="headerlink" title="对象解构(Object)"></a>对象解构(Object)</h3><ol><li><p>基本使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line"><span class="comment">// foo = 'aaa'</span></span><br><span class="line"><span class="comment">// bar = 'bbb'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">baz</span> : foo &#125; = &#123; <span class="attr">baz</span> : <span class="string">'ddd'</span> &#125;;</span><br><span class="line"><span class="comment">// foo = 'ddd'</span></span><br></pre></td></tr></table></figure></li><li><p>可嵌套/可忽略</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [<span class="string">'hello'</span>, &#123;<span class="attr">y</span>: <span class="string">'world'</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line"><span class="comment">// x = 'hello'</span></span><br><span class="line"><span class="comment">// y = 'world'</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [<span class="string">'hello'</span>, &#123;<span class="attr">y</span>: <span class="string">'world'</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123;  &#125;] &#125; = obj;</span><br><span class="line"><span class="comment">// x = 'hello'</span></span><br></pre></td></tr></table></figure></li><li><p>非完全解构</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [&#123;<span class="attr">y</span>: <span class="string">'world'</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [&#123; y &#125;, x ] &#125; = obj;</span><br><span class="line"><span class="comment">// x = undefined</span></span><br><span class="line"><span class="comment">// y = 'world'</span></span><br></pre></td></tr></table></figure></li><li><p>解构默认值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a = <span class="number">10</span>, b = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// a = 3; b = 5;</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span>: aa = <span class="number">10</span>, <span class="attr">b</span>: bb = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// aa = 3; bb = 5;</span></span><br></pre></td></tr></table></figure></li><li><p>扩展运算符</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, b, ...rest&#125; = &#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span>&#125;;</span><br><span class="line"><span class="comment">// a = 10</span></span><br><span class="line"><span class="comment">// b = 20</span></span><br><span class="line"><span class="comment">// rest = &#123;c: 30, d: 40&#125;</span></span><br></pre></td></tr></table></figure><p>在ES6中，我们可以通过 <em>扩展运算符</em> 实现很多应用，例如 <strong>深拷贝和浅拷贝</strong>。</p><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS93M2Nub3RlL2RlY29uc3RydWN0aW9uLWFzc2lnbm1lbnQuaHRtbA==">ES6 解构赋值 | 菜鸟教程<i class="fa fa-external-link-alt"></i></span></p></blockquote></li></ol><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p><strong>深拷贝</strong>：拷贝后与原数组无关，会使 <em>拷贝后的数组</em> 在堆中指向一个新的内存空间。<br><strong>浅拷贝</strong>：拷贝后与原数组有关，<em>新数组</em> 与 <em>原数组</em> 指向同一个堆内存。</p><p><img data-src="pic3.png" alt></p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><p><code>Object.assign()</code> 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 <code>Object.assign()</code> 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: &#123;<span class="attr">name</span>: <span class="string">"mxs"</span>, <span class="attr">age</span>: <span class="number">26</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line">obj2.a.name = <span class="string">"zd"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a.name); <span class="comment">// zd</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat()"></a>Array.prototype.concat()</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, &#123;</span><br><span class="line">  name: <span class="string">'mxs'</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.concat();    </span><br><span class="line">arr2[<span class="number">2</span>].name = <span class="string">'zd'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, &#123;name:'zd'&#125;]</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-slice"><a href="#Array-prototype-slice" class="headerlink" title="Array.prototype.slice()"></a>Array.prototype.slice()</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, &#123;</span><br><span class="line">  name: <span class="string">'mxs'</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.slice();</span><br><span class="line">arr2[<span class="number">2</span>].name = <span class="string">'zd'</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, &#123;name:'zd'&#125;]</span></span><br></pre></td></tr></table></figure><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><p>扩展运算符只能拷贝一层 <strong>对象</strong> / <strong>数组</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">'zd'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">age</span>:&#123;<span class="attr">count</span>:<span class="number">26</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> allObj = &#123;...school,...my&#125;;</span><br><span class="line">obj2.age.count = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(allObj); <span class="comment">// &#123;&#123;name: "zd", age: &#123;count: 100&#125;&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;age: &#123;count: 100&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>可以发现两个对象都改变了，这就是只实现了 <strong>浅拷贝</strong>。</p><p>如果想要实现 <strong>深拷贝</strong>，会十分的麻烦。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">'zd'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">age</span>:&#123;<span class="attr">count</span>:<span class="number">26</span>&#125;,<span class="attr">name</span>:<span class="string">'mxs'</span>&#125;;</span><br><span class="line"><span class="comment">// 把原来的my放到新的对象中，用一个新的对象age将原始的age也拷贝一份</span></span><br><span class="line"><span class="keyword">let</span> newObj2 = &#123;...obj2,<span class="attr">age</span>:&#123;...obj2.age&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> allObj = &#123;...obj1,...newObj2&#125;;</span><br><span class="line">obj2.age.count = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(allObj); <span class="comment">// &#123;&#123;name: "mxs", age: &#123;count: 26&#125;&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;&#123;name: "mxs", age: &#123;count: 100&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><h4 id="JSON-parse-JSON-stringify"><a href="#JSON-parse-JSON-stringify" class="headerlink" title="JSON.parse(JSON.stringify())"></a>JSON.parse(JSON.stringify())</h4><p>用<code>JSON.stringify</code>将对象转成JSON字符串，再用<code>JSON.parse()</code>把字符串解析成对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">'zd'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">age</span>:&#123;<span class="attr">count</span>:<span class="number">26</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> allObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(&#123;...obj1,...obj2&#125;));</span><br><span class="line">obj2.age.count = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(allObj); <span class="comment">// &#123;name: 'zd', age: &#123; count: 26 &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>但是需要注意的是，<code>(JSON.stringify([value]))</code> 这种方法虽然可以实现深拷贝，但是却不能拷贝 <code>Function</code>、<code>undefined</code> 和 <code>Symbol</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">'zd'</span>, <span class="attr">age</span>:&#123;&#125;, <span class="attr">count</span>:<span class="number">26</span>, <span class="attr">a</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="attr">b</span>:<span class="literal">null</span>, <span class="attr">c</span>:<span class="literal">undefined</span>, <span class="attr">d</span>:<span class="built_in">Symbol</span>(<span class="string">'zd'</span>)&#125;</span><br><span class="line"><span class="keyword">let</span> allObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(allObj); <span class="comment">// &#123;name: 'zd', age: &#123;&#125;, count: 26, b: null&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以看到，最终被拷贝下来的，只有 <code>String</code> 、<code>Object</code>、 <code>Number</code> 和 <code>Null</code> 这几种数据类型。</p><h4 id="lodash库"><a href="#lodash库" class="headerlink" title="lodash库"></a>lodash库</h4><p>我们可以通过 <strong>loadash库</strong>中的 <code>cloneDeep</code> 方法来实现深克隆。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">   a: <span class="number">1</span>,</span><br><span class="line">   b: &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">   c: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> cloneObj = _.cloneDeep(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj.a.b === cloneObj.a.b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="手写实现深拷贝"><a href="#手写实现深拷贝" class="headerlink" title="手写实现深拷贝"></a>手写实现深拷贝</h4><p>我们先来看一下完整的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj,hash = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (hash.has(obj)) <span class="keyword">return</span> hash.get(obj);</span><br><span class="line">  <span class="keyword">let</span> cloneObj = <span class="keyword">new</span> obj.constructor;</span><br><span class="line">  hash.set(obj, cloneObj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.hasOwnProperty.call(obj, key)) &#123;</span><br><span class="line">      cloneObj[key] = deepClone(obj[key], hash);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">'zd'</span>, <span class="attr">age</span>:&#123;&#125;, <span class="attr">count</span>:<span class="number">26</span>, <span class="attr">a</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="attr">b</span>:<span class="literal">null</span>, <span class="attr">c</span>:<span class="literal">undefined</span>, <span class="attr">d</span>:<span class="built_in">Symbol</span>(<span class="string">'zd'</span>)&#125;</span><br><span class="line"><span class="keyword">let</span> allObj = deepClone(obj);</span><br><span class="line"><span class="built_in">console</span>.log(allObj); <span class="comment">// &#123;name: 'zd', age: &#123;&#125;, count: 26, a: [Function: a], b: null, c: undefined, d: Symbol(zd)&#125;</span></span><br></pre></td></tr></table></figure><p>如果我们想要手写一套深克隆的函数方法，我们需要先搞懂其实现思路。</p><p>简单来说，其实现思路就是 <em>类型判断</em>，<em>克隆数据类型</em>， <em>遍历循环</em>，最后进行 <em>结果输出</em>。</p><ol><li><p>我们先思考，为什么要进行 <em>类型判断</em> ？</p><p>在此之前，我们需要先要清楚 <strong>数据类型判断方式</strong>。</p><ul><li>typeof</li><li>instanceof / constructor</li><li>Object.prototype.toString.call([value])</li></ul><p>然后我们再来看代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果obj是null或者undefined，则直接将结果返回</span></span><br><span class="line"><span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line"><span class="comment">// 如果obj是基础数据类型或者函数，则直接将结果返回(也就是说，函数不需要进行任何处理)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> obj;</span><br><span class="line"><span class="comment">// 如果obj不是对象或数组，则直接将结果返回</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br></pre></td></tr></table></figure><p>通过上面的代码，我们可以发现，剩下的只有两种数据类型 <strong>数组</strong> 和 <strong>对象</strong>。</p><p>那么我们就清楚了，进行 <em>类型判断</em> ，其目的就是为了将需要进行深克隆数据类型筛选出来。</p></li><li><p>然后再思考，如何 <em>克隆</em> 传入对象的 <em>数据类型</em> 呢？</p><p>最常用的方案如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cloneObj = <span class="built_in">Object</span>.prototype.toString.call(obj) === [<span class="string">'Object Array'</span>] ? [] : &#123;&#125;;</span><br></pre></td></tr></table></figure><p>但是这种写法太麻烦了，我们有更简单的实现方案。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// obj不是数组就是对象，将其进行克隆</span></span><br><span class="line"><span class="keyword">let</span> cloneObj = <span class="keyword">new</span> obj.constructor;</span><br></pre></td></tr></table></figure><p>根据 <strong>原型链</strong> 的指向原则，我们可以利用上述方案来创建一个新的数据类型对象。(如 <strong>下图</strong> 所示)</p><p><img data-src="pic4.png" alt></p><p><em>克隆数据类型</em> 的目的，其实就是为了进行下一步的 <em>遍历循环</em>。</p></li><li><p>接着，我们要进行 <em>遍历循环</em> 。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.hasOwnProperty.call(obj, key)) &#123;</span><br><span class="line">    <span class="comment">// 进行递归，实现深克隆</span></span><br><span class="line">    cloneObj[key] = deepClone(obj[key]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 <code>forin</code> 进行循环，在对象复制前，我们都会将值进行递归，再次执行当前方法，判断是否有深层属性。直到递归至没有深层属性为止。</p><p>然后将结果赋值给<code>cloneObj</code>，最后把结果进行输出。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> cloneObj</span><br></pre></td></tr></table></figure><p>但是这种写法还存在一个问题，就是无法进行 <strong>循环引用</strong> 。</p><p>如果要进行循环引用，就会发生 <strong>栈内存溢出</strong> 的情况。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:&#123;<span class="attr">name</span>:<span class="string">'mxs'</span>&#125;&#125;</span><br><span class="line">obj.b = obj;</span><br><span class="line"><span class="keyword">let</span> allObj = deepClone(obj);</span><br><span class="line">obj.a.name = <span class="string">'zd'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure><p>为了处理这种问题的发生，我们还需要在进行一步操作。</p></li><li><p>最后，我们需要对 <strong>异常情况</strong> 进行处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br></pre></td></tr></table></figure><p>设定一个 <code>WeakMap</code> 数据类型（关于 <code>WeakMap</code> ，可以 参考文献 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvV2Vha01hcA==">WeakMap-JavaScript | MDN<i class="fa fa-external-link-alt"></i></span> ，或查看我的另一篇博客 <a href="https://mxshang.github.io/2021/05/28/学习笔记—前端基础之ES6-2/#weakMap">ES6 | weakMap</a>）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(hash.has(obj)) <span class="keyword">return</span> hash.get(obj);</span><br><span class="line">hash.set(obj, cloneObj);</span><br></pre></td></tr></table></figure><p>如果是 <code>Object</code>，我们就将其放到 <code>weakMap</code> 中。如果在拷贝之前，这个 <code>Object</code> 就已经存在了，我们就直接将其返回。</p><p>至此，我们的 <strong>深拷贝</strong> 就完成了。</p></li></ol><p>我们可以通过这种思路，写出很多种 <strong>深克隆</strong> 的方案。</p><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>ES6</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—前端基础之ES6的数组</title>
    <url>/2021/06/18/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BES6%E7%9A%84%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> r = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function">(<span class="params">total, num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> total + num</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(r);</span><br></pre></td></tr></table></figure><p><code>reduce()</code> 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</p><p><code>reduce()</code> 可以作为一个高阶函数，用于函数的 <em>compose</em>。</p><p><strong>（注：<code>reduce()</code> 对于空数组是不会执行回调函数的。）</strong></p><p>简单来说，<code>reduce</code> 中会接受一个函数，函数的第一次循环，会将数组的前两项传入，并执行相应的计算，并将结果返回。往后的每一次循环，都会将上一次循环的结果传递到第一个参数中。</p><h3 id="initialValue"><a href="#initialValue" class="headerlink" title="initialValue"></a>initialValue</h3><p><em>initialValue</em> ， <code>reduce()</code>的第二个参数，表示传递给函数的 <strong>初始值</strong> 。</p><p>我们可以用它来计算购物车的总价格</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> r = [&#123;<span class="attr">price</span>: <span class="number">100</span>, <span class="attr">count</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">price</span>: <span class="number">200</span>, <span class="attr">count</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">price</span>: <span class="number">300</span>, <span class="attr">count</span>: <span class="number">3</span>&#125;].reduce(<span class="function">(<span class="params">total, num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> total + num.price * num.count</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// 1400</span></span><br></pre></td></tr></table></figure><p>这样我们整个数组默认的第一项就变成了 <em>0</em>，对于处理这种非数字数组非常好用。</p><h3 id="currentIndex"><a href="#currentIndex" class="headerlink" title="currentIndex"></a>currentIndex</h3><p><em>currentIndex</em> , <code>reduce()</code>函数的第三个参数，表示当前 <strong>元素的索引</strong>。</p><p>我们可以用它来将多个数据合并成一个数据。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> keys = [<span class="string">'name'</span>, <span class="string">'age'</span>];</span><br><span class="line"><span class="keyword">let</span> values = [<span class="string">'mxs'</span>, <span class="number">18</span>];</span><br><span class="line"><span class="keyword">let</span> obj = keys.reduce(<span class="function">(<span class="params">memo, cur, index</span>) =&gt;</span> &#123;</span><br><span class="line">  memo[cur] = values[index]</span><br><span class="line">  <span class="keyword">return</span> memo</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;name: 'mxs', age: 18&#125;</span></span><br></pre></td></tr></table></figure><h3 id="模拟compose函数逻辑"><a href="#模拟compose函数逻辑" class="headerlink" title="模拟compose函数逻辑"></a>模拟compose函数逻辑</h3><p><code>compose</code> 函数，函数<strong>调用扁平化</strong>。一个函数的运行结果当作实参传给下一个函数的这种操作，使复杂函数调用看起来更清晰。</p><p>假设我们目前需要实现这样一个功能</p><p>有两个 <code>String</code> 字符串，将其 <em>拼接</em> 并 <em>转换成大写</em> ，最后再 <em>添加特殊字符并展示</em>。</p><p>我们可能会这样解决这个问题。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">'mxs'</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">'nb'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toUpper</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.toUpperCase()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'***'</span> + str + <span class="string">'***'</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(add(toUpper(sum(str1, str2)))) <span class="comment">// ***MXSNB***</span></span><br></pre></td></tr></table></figure><p>我们只模拟了三种功能，整个代码就已经很繁琐了。</p><p>我们为了简化这种繁琐的代码，可以利用 <strong><em>compose函数</em></strong> 对其进行处理。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...fns</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fn = fns.shift();</span><br><span class="line">    <span class="keyword">return</span> fns.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> b(a)</span><br><span class="line">    &#125;, fn(...args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> r = compose(sum, toUpper, add)(str1, str2)</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// ***MXSNB***</span></span><br></pre></td></tr></table></figure><p>我们用一个名为 <strong><em>compose函数</em></strong> 的方法进行 <strong>闭包封装</strong> ，这样会使输出代码看起来更整洁，逻辑更清晰。</p><p>可以利用箭头函数简化 <strong><em>compose函数</em></strong> 代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> fn = fns.shift();</span><br><span class="line">    <span class="keyword">return</span> fns.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b(a), fn(...args))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，我们还可以在实现思路上进行简化。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...fns</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fns.reduceRight(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a(b(...args))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现方式非常难理解，但是也很好解释通，私下可以花点时间看一下。</p><p>然后我们再对其写法进行简化，最终就会变成如下代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> fns.reduceRight(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> a(b(...args)))</span><br></pre></td></tr></table></figure><p>最终就成了一行代码。</p><p>这行代码也被应用在 <strong>redux源码</strong> 中。</p><h3 id="手写实现reduce"><a href="#手写实现reduce" class="headerlink" title="手写实现reduce"></a>手写实现reduce</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduce = <span class="function"><span class="keyword">function</span> (<span class="params">callBack, prev</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">undefined</span>) &#123;</span><br><span class="line">      prev = callBack(<span class="keyword">this</span>[i], <span class="keyword">this</span>[i + <span class="number">1</span>], i + <span class="number">1</span>, <span class="keyword">this</span>);</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prev = callBack(prev, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> r = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function">(<span class="params">a, b, index, current</span>) =&gt;</span> a + b)</span><br><span class="line"><span class="keyword">let</span> r2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function">(<span class="params">a, b, index, current</span>) =&gt;</span> a + b, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(r2); <span class="comment">// 106</span></span><br></pre></td></tr></table></figure><p>实现思路大体就是，利用将传入数组进行循环，执行函数并输出其结果。 假如有第二个参数，就对第二个参数进行处理。 若没有，则直接进行输出处理即可。</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>循环每一项，并对数组中的每一项进行处理，随后将处理后的结果以新数组的方式返回，不会改变原数组。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.map(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newArr, arr) <span class="comment">// [ 2, 4, 6 ] [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>过滤数组，将结果为 <code>false</code> 的项过滤掉，并将结果返回。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item != <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newArr, arr) <span class="comment">// [ 1, 3 ] [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure><h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><p>查看当前数组中是否存在与输出条件一致的结果，如果有则输出 <code>true</code>，反之为 <code>false</code>。 此方法与 <em>every</em> 方法相反</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.some(<span class="function"><span class="params">item</span> =&gt;</span> item == <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="every"><a href="#every" class="headerlink" title="every"></a>every</h2><p>查看当前数组中是否存在与输出条件不一致的结果，如果有则输出 <code>true</code>，反之为 <code>false</code>。 此方法与 <em>some</em> 方法相反</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.every(<span class="function"><span class="params">item</span> =&gt;</span> item == <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>查找数组中与函数条件一致的那一项结果，并将其返回。如果没找到，则返回 <code>undefined</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.find(<span class="function"><span class="params">item</span> =&gt;</span> item == <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h2><p>查找数组中是否包含函数条件的那一项结果，有则输出 <code>true</code>，没有输出 <code>false</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> r = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>ES6</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—前端基础之ES6(2)</title>
    <url>/2021/05/28/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BES6-2/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><h2 id="Set-Map"><a href="#Set-Map" class="headerlink" title="Set / Map"></a>Set / Map</h2><p><code>Set</code> 和 <code>Map</code> 是两种存储结构。</p><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMTAyMjkxMDgyMTE0OTMxMi8xMDIzMDI0MTgxMTA5NDQw">Map和Set | 廖雪峰的官网<i class="fa fa-external-link-alt"></i></span></p></blockquote><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>首先，<code>Set</code>属于 <em>object</em> 类型（如 <strong>下图</strong> 所示）</p><p><img data-src="pic5.png" alt></p><p><code>new Set([value]) [value]:Array</code></p><p><img data-src="pic6.png" alt></p><p><code>Set</code> 是一组 <strong>key 集合</strong>，但<strong>不存储 value</strong>。由于<strong>key不能重复</strong>，所以，在<code>Set</code>中，<strong>没有重复的key</strong>。</p><p>因此，我们常常利用 <code>Set</code> 来实现 <em>数组去重</em> 。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure><p>通过<code>add(key)</code>方法可以添加元素到<code>Set</code>中，可以重复添加，但不会有效果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// 仍然是 Set &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure><p>通过<code>delete(key)</code>方法可以删除元素</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.delete(<span class="number">3</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 4&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以用以下方法对 <code>Set {1, 2, 3, 4}</code> 进行数组转换处理。</p><ul><li><p>展开运算符</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...s];</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li><li><p>Array.form()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(s);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// // [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li></ul><p>同时，我们可以利用<code>Set</code>实现各种处理，例如实现集合的 <em>并集<em>、</em>交集</em> 和 <em>差集</em> 等。</p><p>假如我们现在有以下两个数组。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr1);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr2);</span><br></pre></td></tr></table></figure><ul><li><p>并集</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...new <span class="built_in">Set</span>([...s1, ...s2])]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(union()); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p>交集</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intersection</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...s1].filter(<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.has(val)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(intersection()); <span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>这里我们用到了 <code>filter</code> 这个高阶函数来进行处理。</p></li><li><p>差集</p><p>差集很好理解，其实就是交集取反，就是 <em>差集</em>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...s1].filter(<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !s2.has(val)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(diff()); <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><code>Map</code> 也属于 <em>Object</em> 类型</p><p><img data-src="pic7.png" alt></p><p><code>Map</code>是一组<strong>键值对</strong>的结构，具有<strong>极快的查找速度</strong>。</p><p>先对 <code>Map</code> 进行初始化</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'a'</span>, <span class="number">1</span>], [<span class="string">'b'</span>, <span class="number">2</span>], [<span class="string">'3'</span>, <span class="number">3</span>]]);</span><br><span class="line">m.get(<span class="string">'b'</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>我们新建一个<code>Map</code> ，需要一个二维数组，或者直接初始化一个空的 <code>Map</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 空Map</span></span><br><span class="line">m.set(<span class="string">'a'</span>, <span class="number">1</span>); <span class="comment">// 添加新的key-value</span></span><br><span class="line">m.set(<span class="string">'b'</span>, <span class="number">2</span>);</span><br><span class="line">m.has(<span class="string">'a'</span>); <span class="comment">// 是否存在key 'a': true</span></span><br><span class="line">m.get(<span class="string">'a'</span>); <span class="comment">// 1</span></span><br><span class="line">m.delete(<span class="string">'a'</span>); <span class="comment">// 删除key 'a'</span></span><br><span class="line">m.get(<span class="string">'a'</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>由于一个 <code>key</code> 只能对应一个 <code>value</code> ，所以，多次对一个key放入value，<strong>后面的值会把前面的值替换掉</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="string">'a'</span>, <span class="number">1</span>);</span><br><span class="line">m.set(<span class="string">'a'</span>, <span class="number">11</span>);</span><br><span class="line">m.get(<span class="string">'a'</span>); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>在这里我们可以思考一个问题，<code>Map</code> 的 <code>key</code> 是否可以是一个对象呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line">m.set(obj, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m);<span class="comment">// &#123;&#123;a: 1&#125; =&gt; 2&#125;</span></span><br></pre></td></tr></table></figure><p>答案显然是可以的。</p><p>这里还有一个小问题，假如我们清空上述的对象类型，那么 <code>key</code> 值是否还存在呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line">m.set(obj, <span class="number">2</span>);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(m); <span class="comment">// &#123;&#123;a: 1&#125; =&gt; 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>这里我们可以理解为，我们定义的 <em>变量obj</em> 指向 <em>内存空间obj</em> ，然后我们定义了一个<code>Set</code>类型，其<code>key</code>值指向 <em>内存空间obj</em> 。</p><p><img data-src="pic8.png" alt></p><p>而后我们又将 <em>变量obj</em> 清空，其原来的 <em>内存空间obj</em> 并没有被销毁，只是改变了其指向。所以 <em>变量obj</em> 的指向并不影响 <code>Set</code> 中 <code>key</code> 的指向，所以才有了上述问题的产生和结果。</p><p><img data-src="pic9.png" alt></p><p>针对于上述问题，我们可以提出来另外一个存储结构类型 <code>weakMap</code>，其key值是会被清空的。</p><h4 id="weakMap"><a href="#weakMap" class="headerlink" title="weakMap"></a>weakMap</h4><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvV2Vha01hcA==">WeakMap-JavaScript | MDN<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><code>WeakMap</code> 对象是一组 <code>key/value</code> (键值对)的集合，其中的键是 <strong>弱引用</strong> 的。其 <code>key</code> 必须是对象，而 <code>value</code> 可以是任意的。</p><p><code>WeakMap</code> 的 key 只能是 <code>Object</code> 类型。 <strong>原始数据类型</strong> 是不能作为 key 的（比如 <code>Symbol</code>）。</p><p>所以我们就可以得出来一个结论了。</p><p><code>Map</code> 的 <code>key</code> 值是强引用类型，在堆内存中存在指向关系，所以不会被垃圾回收机制给清除掉。</p><p>而 <code>weakMap</code> 的 <code>key</code> 值是弱引用类型，会被垃圾回收机制清除掉。</p><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2RlZmluZVByb3BlcnR5">Object.defineProperty() | MDN Web<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p><p>同时，<code>Object.defineProperty()</code> 也是 Vue2.0 中双向绑定的核心实现原理。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;<span class="attr">value</span>: <span class="string">'hello'</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><h3 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h3><p>当该属性的 <code>enumerable</code> 键值为 <code>true</code> 时，该属性才会出现在对象的枚举属性中，<strong>默认为 <code>false</code></strong>。</p><p>在这里我们可以引出来一个问题，假如我们直接打印 <code>obj</code> 变量，会输出变量的属性和值吗？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;<span class="attr">value</span>: <span class="string">'hello'</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以发现，控制台中并未输出 <code>obj</code> 的任何属性。</p><p>原因是通过 <code>Object.defineProperty()</code> 定义的属性，都是<strong>不可枚举</strong>的（<strong><code>enumerable: false</code></strong>）。</p><p>我们可以通过修改 <code>enumerable</code> 来达到枚举的效果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'hello'</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123;name: 'hello'&#125;</span></span><br></pre></td></tr></table></figure><p>这样我们就可以打印出我们定义的属性了。</p><h3 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h3><p>当该属性的 <code>configurable</code> 键值为 <code>true</code> 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除，<strong>默认为 <code>false</code></strong>。</p><p>同样我们可以先思考一个问题，可以通过描述符 <code>delete</code> 删除我们自定义的属性吗？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">    value: <span class="string">'hello'</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">delete</span> obj.name</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123;name: 'hello'&#125;</span></span><br></pre></td></tr></table></figure><p>答案是不可以。</p><p>原因是通过 <code>Object.defineProperty()</code> 定义的属性，都是<strong>不可配置</strong>的（<strong><code>configurable: false</code></strong>）。</p><p>我们可以通过修改 <code>configurable</code> 来达到想要的结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'hello'</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>这样我们定义的属性就被删除了。</p><h3 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h3><p>当该属性的 <code>writable</code> 键值为 <code>true</code> 时，属性的值，也就是上面的 <code>value</code>，才能被<strong>赋值运算符</strong>改变。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'hello'</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">obj.name = <span class="string">'world'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// 'world'</span></span><br></pre></td></tr></table></figure><h3 id="getter-setter"><a href="#getter-setter" class="headerlink" title="getter/setter"></a>getter/setter</h3><p><strong><code>getter</code></strong> ：属性的 getter 函数，如果没有 getter，则为 <code>undefined</code>。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 <code>this</code> 对象（由于继承关系，这里的<code>this</code>并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。</p><p><strong><code>setter</code></strong> ：属性的 setter 函数，如果没有 setter，则为 <code>undefined</code>。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 <code>this</code> 对象。</p><p><strong>（注：如果我们定义了 <code>getter</code>，则不能再定义 <code>writable</code>）</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> other = <span class="string">''</span> <span class="comment">// 额外设置一个变量，用来设置setter</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  <span class="keyword">get</span>()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'--------'</span>);</span><br><span class="line">    <span class="keyword">return</span> other;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(val)&#123;</span><br><span class="line">    other = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">obj.name = <span class="string">'world'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// -------- 'world'</span></span><br></pre></td></tr></table></figure><p><strong>（注：我们需要额外定义一个变量 <em>other</em>）</strong></p><p>Vue的 <strong>数据劫持</strong> ，就是利用的<code>setter/getter</code></p><h4 id="Vue数据劫持"><a href="#Vue数据劫持" class="headerlink" title="Vue数据劫持"></a>Vue数据劫持</h4><p>我们先定义一个需要进行劫持的对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  name: <span class="string">'moxiaoshang'</span>,</span><br><span class="line">  age: <span class="number">26</span>,</span><br><span class="line">  address: &#123;</span><br><span class="line">    location: <span class="string">'昌平'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后我们去观察Vue的源码，一步一步的分析 <strong>数据劫持</strong> 的实现原理。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updata</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'更新视图'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    defineReactive(obj, key, obj[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, value</span>) </span>&#123;</span><br><span class="line">  observer(value)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(val) &#123;</span><br><span class="line">      <span class="keyword">if</span> (val !== value) &#123;</span><br><span class="line">        observer(val)</span><br><span class="line">        updata()</span><br><span class="line">        value = val</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">observer(data);</span><br></pre></td></tr></table></figure><ol><li><p>模拟更新方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updata</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'更新视图'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手写一个模拟更新的方法，使我们在调用 <em>get/set</em> 的时候更直观。</p></li><li><p>使用 <code>observer</code> 函数观察 <em>data</em> 的变化</p><p>将我们需要监听的对象传入函数中。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">oberver(data);</span><br></pre></td></tr></table></figure><p>将 <code>Object.defineProperty</code> 封装成一个可递归调用的函数。</p><p><strong>（注：<code>Object.defineProperty</code> 只能用在 <code>Object</code> 上，数组不识别）</strong></p><p>所以我们第一步需要进行类型判断，将不是 <code>Object</code> 的数据类型返回。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> obj; <span class="comment">// 类型判断</span></span><br></pre></td></tr></table></figure><p>随后，我们需要循环 <em>obj</em> 的每一个属性，并利用 <code>Object.defineProperty</code> 进行 <em>getter</em> 的遍历输出。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      <span class="keyword">get</span>()&#123; <span class="comment">// ... &#125;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样写会有一个问题，那就是整个代码的灵活性不高，所以在Vue源码中，我们会用一个新的函数 <code>defineReactive</code> 将内层代码进行封装。</p><p>这样我们的代码就变成了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  defineReactive(obj, key, obj[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义响应式函数 <code>defineReactive</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续将 <code>Object.defineProperty</code> 封装成一个函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(val) &#123;</span><br><span class="line">    update() <span class="comment">// 在此设置更新视图触发的函数，使其更直观</span></span><br><span class="line">    value = val <span class="comment">// 不需要额外定义全局变量 other</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里我们用到了 <strong>闭包</strong> 的思想，形参 <em>value</em> 被调用，所以不会被销毁。</p><p>所以我们在 <em>set</em> 的时候，不需要额外定义一个全局变量，直接使用 <em>value</em> 即可。</p><p>到这一步，我们就可以直接将 <em>set/get</em> 绑定在对象上了。</p><p><img data-src="pic10.png" alt="chrome控制台"></p><p>通过在控制台中的输出，我们又可以发现一个问题</p><p><img data-src="pic11.png" alt></p><p>内部属性并没有被绑定 <em>get/set</em> ，所以我们需要进行递归处理。</p></li><li><p>处理 <code>Object</code> 内部属性</p><p>非常简单，只需要在处理属性前，也就是响应式函数中进行递归处理即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, value</span>) </span>&#123;</span><br><span class="line">  observer(value) <span class="comment">// 将传入的值进行递归</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，内部属性就被绑定了 get/set 了。</p><p><img data-src="pic12.png" alt></p></li><li><p>直接赋值 <code>Object</code></p><p>接下来，我们再来处理另外一个特殊情况。</p><p>假如我们在属性中，直接赋值一个新的 <code>Object</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data.address = &#123;</span><br><span class="line">  location:<span class="string">'北京'</span></span><br><span class="line">&#125; <span class="comment">// 更新视图</span></span><br><span class="line">data.address.location = <span class="string">'昌平'</span> <span class="comment">// 没有任何输出</span></span><br></pre></td></tr></table></figure><p>这里我们原本应该会触发两次 <em>update函数</em> ，但是最终却只触发了一次。</p><p>因为我们在 <em>address</em> 属性中绑定了一个新的 <code>Object</code> ，而这个对象我们并未进行监听。</p><p>所以我们只需要在 <em>setter</em> 中，添加一个监听函数即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val !== value) &#123; <span class="comment">// 假如值相同，则不需要进行处理</span></span><br><span class="line">      observer(val) <span class="comment">// 进行属性监听</span></span><br><span class="line">      update()</span><br><span class="line">      value = val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>这种方法我们只能劫持 <code>Object</code> 对象类型，如果我们想要劫持 <code>Array</code> 数组，需要使用 <code>Proxy</code> 。</p><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJveHk=">Proxy - JavaScript | MDN<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><code>Proxy</code> 用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如 <em>属性查找</em> 、<em>赋值</em> 、<em>枚举</em> 、 <em>函数调用</em>等）。</p><p>我们来实例化一个 <code>Proxy</code> 对象，看一下实例中包含哪些属性。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(arr, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123; <span class="built_in">console</span>.log(<span class="built_in">arguments</span>) &#125;,</span><br><span class="line">  <span class="keyword">set</span>() &#123; <span class="built_in">console</span>.log(<span class="built_in">arguments</span>) &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(proxy[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>先来看一下 <code>setter</code> 上包含的属性。</p><p><img data-src="pic13.png" alt></p><ul><li>目标源</li><li>传入的key值</li><li>取到的value值</li><li><code>Proxy</code> 类</li></ul><p>再看一下 <code>getter</code></p><p><img data-src="pic14.png" alt></p><ul><li>目标源</li><li>传入的key值</li><li><code>Proxy</code> 类</li></ul><p>这样，我们可以清楚的看到，<code>setter</code> 比 <code>getter</code> 多了一个value值。</p><p>在Vue中，我们希望数组中的数据一变化，视图就会更新。但是 <code>Object.defindProperty</code> 并不支持数组的更新，所以我们通常会用 <code>Proxy</code> 将数组的方法进行重写。（<code>push()</code>,<code>shift()</code>,<code>unshift()</code>,<code>pop()</code> 等等…）</p><h3 id="Vue中的数组"><a href="#Vue中的数组" class="headerlink" title="Vue中的数组"></a>Vue中的数组</h3><p><strong>（注：在Vue3中，已经用 <code>Proxy</code> 代替 <code>Object.defindProperty</code> 来做数据劫持）</strong></p><p>先来看一下完全写法，随后我们一点一点来分析代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'更新视图'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(arr, &#123;</span><br><span class="line">    <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key === <span class="string">'length'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        update();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.push(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol><li><p>模拟更新方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updata</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'更新视图'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手写一个模拟更新的方法，使我们在调用 <em>get/set</em> 的时候更直观。</p></li><li><p><code>Proxy</code> 中的 <code>getter/setter</code> 的返回值</p><p>我们可以将 <code>Proxy</code> 中的属性进行操作，然后在<code>getter/setter</code>中，增加我们自定义的方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(arr, &#123;</span><br><span class="line">  <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">    update();</span><br><span class="line">    <span class="keyword">return</span> target[key] = value;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.push(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>但是这种写法是不推荐的。我们尽量不要去操作原数组，因为数组变化时，可能会调用 <code>push()</code> 、 <code>pop()</code> 等方法，这个时候 <code>key</code> 值可能会出现问题。所以我们需要使用 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVmbGVjdA==">Reflect<i class="fa fa-external-link-alt"></i></span> 进行一下优化。</p><p>优化后的代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(arr, &#123;</span><br><span class="line">  <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">    update();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.push(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>解决 <strong>自定义函数</strong> 错误触发次数的问题</p><p>这个时候我们会发现一个问题，我们自定义的函数被<strong>触发了两次</strong>，但是我们<strong>只使用了一次</strong>方法。</p><p><img data-src="pic15.png" alt></p><p>关于这个问题，原因也很简单。我们打印一下 <code>key</code> 值，就可以轻松发现，我们在修改数组时，不仅添加了值，还触发了一次 <code>length</code>。</p><p>因为数组的长度发生了改变，所以 <code>length</code> 也被传递到了 <code>Proxy</code> 的 <code>setter</code> 中。</p><p>我们可以通过判断 <em>length</em> 属性，来完成这个问题的修复。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (key === <span class="string">'length'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>在 <em>update()</em> 前，加上此判断即可。</p></li></ol><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMTAyMjkxMDgyMTE0OTMxMi8xMDMxNTQ5NTc4NDYyMDgw">箭头函数 | 廖雪峰的官网<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>首先，箭头函数简单来说，就是<strong>函数的缩写</strong>。</p><p><code>x =&gt; x * x</code> 等同于 <code>function (x) { return x * x }</code></p><p>箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连<code>{ ... }</code>和<code>return</code>都省略掉了。还有一种可以包含多条语句，这时候就不能省略<code>{ ... }</code>和<code>return</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">x =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> - x * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果参数不是一个，就需要用括号<code>()</code>括起来：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个参数:</span></span><br><span class="line">(x, y) =&gt; x * x + y * y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数:</span></span><br><span class="line">() =&gt; <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数:</span></span><br><span class="line">(x, y, ...rest) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> i, sum = x + y;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;rest.length; i++) &#123;</span><br><span class="line">        sum += rest[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SyntaxError:</span></span><br><span class="line">x =&gt; &#123; <span class="attr">foo</span>: x &#125;</span><br></pre></td></tr></table></figure><p>因为和函数体的<code>{ ... }</code>有语法冲突，所以要改为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ok:</span></span><br><span class="line">x =&gt; (&#123; <span class="attr">foo</span>: x &#125;)</span><br></pre></td></tr></table></figure><p>这里我们先要明确箭头函数的几个特点</p><ul><li>箭头函数内部的 <code>this</code> 是词法作用域，由上下文确定。</li><li>箭头函数不存在 <code>arguments</code> 属性</li></ul><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><ol><li><p><strong>普通函数</strong>执行，<strong><code>.</code> 前面</strong>是哪个对象，<strong><code>this</code> 就指向</strong>哪个对象。如果 <code>.</code> 前面<strong>没有调用</strong>的对象，那么就<strong>指向<code>window</code></strong> <em>（严格模式下指向<code>undefined</code>）</em></p></li><li><p><strong>构造函数</strong>执行，<code>this</code>是当前类的<strong>实例</strong>。</p></li><li><p><strong>箭头函数</strong>内部的 <code>this</code> 是词法作用域，由<strong>上下文确定</strong>。</p></li><li><p>给元素的某个<strong>事件绑定</strong>函数，函数触发，<strong>this指向当前元素</strong>。</p></li><li><p><code>call/apply/bind</code> 可以改变this的指向。</p></li></ol><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>ES6</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—前端基础之构造函数与类</title>
    <url>/2021/06/18/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B1%BB/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>用 <code>new</code> 关键字来调用的函数，称为 <strong>构造函数</strong>。</p><p>构造函数中一般有两个属性，一个是 <strong>原型上的属性</strong>，一个是 <strong>实例上的属性</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Animal(<span class="string">'小狗'</span>);</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Animal(<span class="string">'小猫'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a1.arr === a2.arr); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>实例的属性指向不同的存储空间（堆内存），所以输出结果是 <code>false</code>，也就是实例本身的属性。</p><p>通过定义原型上的属性，可以使实例拥有 <strong>原型上的属性</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Animal.prototype.address = &#123;<span class="attr">location</span>:<span class="string">'家里'</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a1.address === a2.address) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h3><p>首先我们要清楚 <strong>类（构造函数）</strong> 、<strong>原型</strong> 和 <strong>constructor</strong> 之间的关系。</p><ul><li>每一个类（函数）都具有 <code>prototype</code>，并且属性值是一个 <code>Object</code></li><li>对象上天生具有一个属性 <code>constructor</code>，指向类本身</li><li>每一个对象（<em>普通对象</em> 、 <em>prototype</em> 、<em>实例</em> 、<em>函数</em> 等 ）都具备 <code>__proto__</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">let</span> f1 = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure><p><code>__proto__</code>：当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<code>__proto__</code> 属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的<code>__proto__</code>属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null，真正的空值。</p><p><code>prototype</code>：包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。任何函数在创建的时候，其实会默认同时创建该函数的 <code>prototype</code> 对象。</p><p><code>constructor</code>：指向该对象的构造函数，每个对象都有构造函数。若对象本身不具备<code>constructor</code>属性，则会通过<code>__proto__</code>向原型链进行查找，找到原型链中constructor后，确定其指向，并进行继承。</p><p><img data-src="pic1.png" alt="原型"></p><p>关于 <strong>原型链查找机制</strong>，我个人是这么理解的。</p><p>首先实例的<code>__proto__</code>会始终指向其构造函数的<code>prototype</code>属性（<code>f.__proto__ === Fn.prototype</code>），构造函数和其所有父类（<code>Fn</code>、<code>Function</code>、<code>Object</code>）均指向<code>Function.prototype</code>，<code>Fn.prototype.__proto__</code>指向的是<code>Object.prototype</code>，而<code>Function.prototype.__proto__</code>指向<code>Object.prototype</code>。<code>Object.prototype.__proto__</code>指向<code>null</code>，就是此原型链的终点。</p><p><img data-src="pic2.png" alt="原型链"></p><p>关于原型链，可以将上图好好理解一下，这张图更直观的表述了<code>prototype</code>、<code>__proto__</code> 和 <code>constructor</code> 之间的关系。没事的时候也可以将他们画一下。</p><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p><strong>构造函数</strong> 其实 <strong>就是类</strong> 的一种。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.eat = <span class="string">'吃肉'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.address = &#123;<span class="attr">location</span>: <span class="string">'山里'</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tiger</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">Tiger.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'说话'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们模拟一个 <em>父类 <code>Animal</code></em> 和一个<em>子类 <code>Tiger</code></em></p><ol><li><p>继承父类实例上的属性</p><p>我们只需要子类上加一个 <code>.call</code> 改变一下 <em>this</em> 的指向即可</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tiger</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">10</span>;</span><br><span class="line">  Animal.call(<span class="keyword">this</span>); <span class="comment">//将父类的this指向子类，使子类继承父类中的属性。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tiger = <span class="keyword">new</span> Tiger();</span><br><span class="line"><span class="built_in">console</span>.log(tiger.eat); <span class="comment">// 吃肉</span></span><br></pre></td></tr></table></figure></li><li><p>继承父类原型上的方法</p><p>上述做法我们只继承了父类实例上的属性，并没有继承其原型上的属性。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(tiger.address); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>这里我们有这么几种解决方案</p><ul><li><p><code>父类.prototype.__proto__ = 子类.prototype</code></p><p>我们的子类和父类的 <code>prototype</code> 分别指向不同的方法和对象。所以我们为了使子类的原型继承父类原型上的方法，可以让子类的 <code>prototype.__proto__</code> 指向父类的 <code>prototype</code> 。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Tiger.prototype.__proto__ = Animal.prototype;</span><br><span class="line"><span class="built_in">console</span>.log(tiger.address); <span class="comment">// &#123;location: '山里'&#125;</span></span><br></pre></td></tr></table></figure><p>这样我们就实现了其中一种继承方法。</p></li><li><p><code>Object.create</code></p><p><code>Object.create()</code>方法创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Tiger.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(tiger.address); <span class="comment">// &#123;location: '山里'&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Object.setPrototypeOf</code></p><p>使用 <code>Object.setPrototypeOf()</code> 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或 <code>null</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(Tiger.prototype, Animal.prototype);</span><br></pre></td></tr></table></figure></li></ul><p>（<em>注：以上方法需要在子类的原型方法绑定前添加。</em>）</p><p>这种方法我们无法向父类传参，只能给子类传参。</p></li></ol><h3 id="ES6中的类（class）"><a href="#ES6中的类（class）" class="headerlink" title="ES6中的类（class）"></a>ES6中的类（class）</h3><p>首先，ES6与ES5类的实现思路相同，同样是利用 <em>原型链</em> 来进行实现的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.eat = <span class="string">'吃肉'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  say() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'say'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是最简单的一种类的实现方式。</p><p>但是 <strong>ES6的类</strong> 和ES5有几点不同</p><ul><li><p>类不可以被当做函数调用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Animal() <span class="comment">// Class constructor Animal cannot be invoked without 'new'</span></span><br></pre></td></tr></table></figure><p>ES6的类需要使用new作为关键字来进行实例化</p><p>同理，如果我们调用原型上的方法，可以将类实例化出来后，直接进行调用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal();</span><br><span class="line">a.__proto__.say(); <span class="comment">// say</span></span><br></pre></td></tr></table></figure><p>（<em>注：ES6规范中，若单独调用原型上的方法，this是不存在的</em>）</p><p>比如我们直接将原型上的方法实例化出来</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暂时修改一下Animal类上的say()方法，测试完后再将此方法改回</span></span><br><span class="line">say() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> say = a.__proto__.say;</span><br><span class="line">say(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>返回的结果就是 <code>undefined</code></p></li><li><p>包含静态方法（ES7中的静态属性）</p><p>ES6中允许类存在 <strong>私有方法（ES7中的私有属性）</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ES6</span></span><br><span class="line">  <span class="keyword">static</span> flag() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'test'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ES7</span></span><br><span class="line">  <span class="keyword">static</span> flag = <span class="string">'test'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Animal.flag()) <span class="comment">// test</span></span><br></pre></td></tr></table></figure><p>（<em>注：在ES6的环境中，不能使用ES7的写法</em>）</p><p>调用时，需要直接用类来进行调用，实例不能进行调用。</p></li><li><p>使用 <code>extends</code> 关键字实现继承</p><p><code>extends</code> 可以直接实现继承。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> Tiger(<span class="string">'老虎'</span>)</span><br><span class="line">t.say(); <span class="comment">// say</span></span><br><span class="line"><span class="built_in">console</span>.log(t.eat); <span class="comment">// 吃肉</span></span><br><span class="line"><span class="built_in">console</span>.log(t.name); <span class="comment">// 老虎</span></span><br></pre></td></tr></table></figure><p>首先，父类的方法与原型 直接继承给了子类。</p><p>随后，传递的值 <em>老虎</em> ，被直接传递给了父类的 <code>constructor</code> ，直接输出了结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123; &#125; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们还有一个需要注意的，父类存在自己的 <code>constructor</code> ，子类不能再定义 <code>constructor</code></p><p>如果想要实现此功能，需要使用关键字 <code>super</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name)&#123; <span class="comment">// Animal.call(this, name) </span></span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（<strong>提示：我们可以去 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFiZWxqcy5jbi8=">babel<i class="fa fa-external-link-alt"></i></span> 上查看ES6中class的实现方式，加深对class的理解</strong>）</p></li></ul><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>ES6</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
</search>
