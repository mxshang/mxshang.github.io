<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>学习笔记—编码的发展</title>
    <url>/2021/12/25/Buffer/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%BC%96%E7%A0%81%E7%9A%84%E5%8F%91%E5%B1%95/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="编码的发展"><a href="#编码的发展" class="headerlink" title="编码的发展"></a>编码的发展</h2><p>我们现在常用的编码是 <code>ASCII</code> 编码，汉字都是使用 <code>UTF-8</code> 格式。</p><p>编码一般分为以下几种</p><ul><li><strong>ASCII 码</strong></li><li><strong>GB2312</strong></li><li><strong>GBK</strong></li><li><strong>GB18030 (DBCS)</strong></li><li><strong>Unicode</strong></li><li><strong>UTF-8</strong> / <strong>UTF-16</strong></li><li>…</li></ul><h3 id="ASCII-码"><a href="#ASCII-码" class="headerlink" title="ASCII 码"></a>ASCII 码</h3><p><strong>ASCII码</strong> 的八位字节可以表现出 <em>256</em> 种不同的形态。</p><p>0-32 规定了特殊用途,一旦终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。<em>（如 遇上0×10, 终端就换行。遇上0×07, 终端就会发出嘟嘟嘟的声音 等。）</em></p><p>所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第 <em>127</em> 号。这样计算机就可以用不同字节来存储英语的文字了。</p><p><img data-src="pic2.png" alt="ASCII表"></p><p>因为计算机最早是在美国进行使用的，而他们也只使用了前 <em>127</em> 号。但是世界上存在那么多种语言，光是汉语就有好几万个汉字，这种编码格式显然是不太行的。</p><h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p>西欧一些国家用的不是英文，所以他们使用 <em>127</em> 号这后的空位来保存新的字母，一直编到了最后一位 <em>255<em>。</em>（不同国家表示的符号也是不同的，130 在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)）</em></p><p>而我们国家为了表示汉字，把 <em>127</em> 之后的符号取消了。</p><p>一个 <em>小于127</em> 的字符的意义与原来相同。但两个大于 127 的字符连在一起时，就表示一个汉字。前面的一个字节（<strong>高字节</strong>）从 <code>0xA1</code> 到 <code>0xF7</code>，后面一个字节（<strong>低字节</strong>）从 <code>0xA1</code> 到 <code>0xFE</code>。这种方式可以组合出大概 <code>(247-161)*(254-161) = 7998</code> 多个简体汉字。</p><p>而 <em>数学符号<em>、</em>日文假名</em> 和 ASCII里原来就有的 <em>数字<em>、</em>标点</em> 和 <em>字母</em> 都重新编成两个字长的编码。这就是 <strong>全角字符</strong>，<em>127</em> 以下那些就叫<strong>半角字符</strong>。</p><p>这种汉字方案叫做 <code>GB2312</code>。<code>GB2312</code> 是对 <code>ASCII</code> 的 <em>中文扩展</em> 。</p><h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h3><p>在使用过程中，发现 <code>GB2312</code> 还是不够用。于是便不再要求 <strong>低字节</strong> 一定是 <em>127</em> 之后的内码，只要第一个字节是大于 <em>127</em> ，就固定表示这是一个汉字的开始。</p><p>于是又增加了近 <em>20000</em> 个新的汉字（包括繁体字）和符号。</p><h3 id="GB18030-DBCS"><a href="#GB18030-DBCS" class="headerlink" title="GB18030 / DBCS"></a>GB18030 / DBCS</h3><p><code>GBK</code>扩成了<code>GB18030</code> 通称他们叫做 DBCS，增加了几千个新的少数民族的字。</p><p>在 DBCS 系列标准里，最大的特点是 <em>两字节长的汉字字符</em> 和 <em>一字节长的英文字符</em> 并存于同一套编码方案里。</p><p>就这样，各个国家都搞出了一套自己的编码标准。就导致会同时存在好多种不同的编码，互相之间不支持也不互通。</p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p><code>Unicode</code> 编码，开发人员应该并不陌生。</p><blockquote><p>ISO：International Organization for Standardization ，国际标准化组织</p><p>Unicode：Universal Multiple-Octet Coded Character Set ，简称 UCS，俗称 Unicode</p></blockquote><p><strong>ISO</strong> 的国际组织废了所有的地区性编码方案，重新搞一个包括了地球上 <em>所有文化<em>、</em>所有字母</em> 和 <em>文字</em> 的编码。</p><p><code>Unicode</code> 是一个很大的集合，现在的规模可以容纳 <em>100多万</em> 个符号。</p><p>ISO 组织直接规定必须用 <em>两个字节（16位）</em> 来表示所有的字符。<code>ASCII</code> 里的那些 <em>半角字符*，<code>Unicode</code> 保持其原编码不变，只是将其长度由原来的 *8</em> 位扩展为<em>16</em> 位，而其他文化和语言的字符则全部重新统一编码。</p><p>从 <code>Unicode</code> 开始，无论是半角的 <em>英文字母</em>，还是全角的 <em>汉字</em>，它们都是统一的一个字符。同时，也都是统一的 <em>两个字节</em>。</p><p><code>Unicode</code> 在很长一段时间内无法推广，直到互联网的出现。</p><h3 id="UTF"><a href="#UTF" class="headerlink" title="UTF"></a>UTF</h3><p>为解决 <code>Unicode</code> 如何在 <em>网络上传输</em> 的问题，面向传输的众多 <code>UTF</code> 标准出现了。</p><blockquote><p>UTF编码：Universal Character Set（UCS）Transfer Format</p></blockquote><p><code>UTF-8</code> 就是在互联网上使用最广的一种 <code>Unicode</code> 的实现方式。</p><p><code>UTF-8</code> 是每次以 <em>8位</em> 为单位进行数据传输，而 <code>UTF-16</code> 是每次以 <em>16位</em> 进行传输的。</p><p><code>UTF-8</code> 是一种变长的编码方式。<code>Unicode</code> 一个中文字符占 <em>2</em> 个字节，而 <code>UTF-8</code> 一个中文字符占 <em>3</em> 个字节。</p><p>换言之，<code>UTF</code> 就是 <code>Unicode</code> 的另一种实现方式。</p><h3 id="Base64-编码规范"><a href="#Base64-编码规范" class="headerlink" title="Base64 编码规范"></a>Base64 编码规范</h3><p><code>Base64</code> 是网络上最常见的用于传输 <em>8位</em> 字节码的编码方式之一。开发中可以替换掉路径，而且可以用于传输。</p><p><code>Base64</code> 编码是从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息。采用 <code>Base64</code> 编码具有不可读性，需要解码后才能阅读。</p><p><img data-src="pic3.png" alt="base64对应表"></p><p>我们平时会使用 <code>encodeURIComponent()</code> 方法将文字转换成 <em>16进制</em>。</p><h4 id="转化思路"><a href="#转化思路" class="headerlink" title="转化思路"></a>转化思路</h4><p>我们都知道，<em>一个汉字 3 个字节，一个字节 8 位</em> 。而 <code>Base64</code> 其实就是将一个汉字转换为 <code>3 * 8 = 4 * 6</code> 的格式，也就是说现在一个汉字会有 <em>4个字节</em> 的长度，转换后的结果会比之前大 1/3。</p><p>我们先随便输出一个汉字，并将其转换成16进制。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Buffer.from 可以将汉字转换成 16进制</span></span><br><span class="line"><span class="keyword">let</span> r = Buffer.from(<span class="string">'莫'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// &lt;Buffer e8 8e ab&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以发现，结果是 <em>3个字节</em> 长度的 16进制，挨个转换成 2进制。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">0xe8</span>).toString(<span class="number">2</span>)); <span class="comment">// 11101000</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">0x8e</span>).toString(<span class="number">2</span>)); <span class="comment">// 10001110</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">0xab</span>).toString(<span class="number">2</span>)); <span class="comment">// 10101011</span></span><br></pre></td></tr></table></figure><p>再将得到的 2进制 进行拼接，并转换成 <em>4个字节*，并在前面补 0，将其变成 *8位</em> 二进制 。然后我们会得到下面的结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 11101000 10001110 10101011</span></span><br><span class="line"><span class="comment">// 00111010 00001000 00111010 00101011</span></span><br></pre></td></tr></table></figure><p>这个结果最大是 <code>001111</code>，然后我们再将这个结果转换成 十进制。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">'00111010'</span>,<span class="number">2</span>)); <span class="comment">// 58</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">'00001000'</span>,<span class="number">2</span>)); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">'00111010'</span>,<span class="number">2</span>)); <span class="comment">// 58</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">'00101011'</span>,<span class="number">2</span>)); <span class="comment">// 43</span></span><br></pre></td></tr></table></figure><p>这样我们就会得到一个每位都 <em>不大于64</em> 的结果。</p><p>根据上面写的对应表，我们就可以推算出这个文字对应的 <code>Base64</code> 编码为 <code>6I6r</code>，也就是我们上面写的 <strong>莫</strong> 字。</p><p>把这种思路整理一下，我们就可以得到下述代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CHARTS = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> buf = Buffer.from(str);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> b <span class="keyword">of</span> buf)&#123;</span><br><span class="line">      result += b.toString(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.match(<span class="regexp">/(\d&#123;6&#125;)/g</span>).map(<span class="function"><span class="params">v</span>=&gt;</span><span class="built_in">parseInt</span>(v,<span class="number">2</span>)).map(<span class="function"><span class="params">v</span>=&gt;</span>CHARTS[v]).join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> r = transfer(<span class="string">'a'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(r);</span><br></pre></td></tr></table></figure><p>这样就完成了我们的 <code>Base64</code> 的转换。</p><blockquote><p>本篇文章由 <strong>莫小尚</strong> 创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>Node</tag>
        <tag>JS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—二进制和精度问题</title>
    <url>/2021/12/08/Buffer/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E8%BF%9B%E5%88%B6%E5%92%8C%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>所谓 <strong>二进制</strong>，就是只用 <em>0</em> 与 <em>1</em> 两个数字，在计数与计算时必须是 <strong>逢2进1</strong> <em>（如十进制的 10 就是二进制的 1010）</em>。</p><p>计算机中所有的内容全都是以 <strong>二进制</strong> 的形式进行存储的，而数据也都是以 <strong>二进制</strong> 的形式来表现的。</p><h3 id="精度问题"><a href="#精度问题" class="headerlink" title="精度问题"></a>精度问题</h3><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly8wLjMwMDAwMDAwMDAwMDAwMDA0LmNvbS8=">Floating Point Math<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>我们首先来思考一个问题，<code>0.1 + 0.2 === 0.3</code> 的输出结果是什么？</p><p>来看一下这道最经典的面试题。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>);</span><br></pre></td></tr></table></figure><p>这道题的结果是 <code>false</code> ，我们通过控制台打印可以发现， <em>0.1 + 0.2</em> 的结果并不是 <em>0.3</em>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span>); <span class="comment">// 0.30000000000000004</span></span><br></pre></td></tr></table></figure><p>导致这个问题的原因就和计算机的 <strong>二进制存储</strong> 有关。</p><p>首先我们要先明确计算机数据存储的两个概念。</p><ul><li>计算机将所有数据以 <strong>二进制</strong> 的形式存储。</li><li>计算机用 <strong>有限的大小</strong> 来存储数据。（因为现实生活中不存在无限大的内存或硬盘）</li></ul><p>计算机中的 <em>*最小单位是 *位（bit，比特）</em> **。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">- 8 bit =&gt; 1 byte;</span><br><span class="line"></span><br><span class="line">- 1024 byte =&gt; 1 Kb;</span><br><span class="line"></span><br><span class="line">- 1024 Kb =&gt; 1 Mb;</span><br><span class="line"></span><br><span class="line">- 1024 Mb =&gt; 1 Gb;</span><br><span class="line"></span><br><span class="line">- 1024 Gb =&gt; 1 T;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们在进行数据存储时，一般以 <strong>字节</strong> 来进行存储。</p><p><strong>字节（byte）</strong> 的最大值和最小值是 <em>0~255</em> ，也就是说取值范围是 <em>255</em> 。</p><p>取值范围的 <em>255</em> 是因为计算机是通过 <strong>二进制来进行数据存储</strong> 。</p><h3 id="进制的转换"><a href="#进制的转换" class="headerlink" title="进制的转换"></a>进制的转换</h3><p>二进制顾名思义就是 <strong>逢2进1</strong>，十进制就是 <strong>逢10进1</strong>。</p><p>又因为 <code>8bit = 1byte</code>，所以他们之间相差 255。</p><p>二进制 转 十进制 其实就是 <em>当前位的值乘以进制（2），次幂是当前所在位</em>，也就是 <code>1*2^n</code>。</p><p>具体计算代码如下。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">Math</span>.pow(<span class="number">2</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 255</span></span><br></pre></td></tr></table></figure><p>计算公式如下。<br>$$<br>∵ 1<em>2^n 且 n&lt;8<br>∴ s = 1</em>2^0 + 1<em>2^2 + … + 1</em>2^7<br>$$</p><p>从 十进制 转 二进制，就是 <em>当前数除以进制（2），并取余。然后将余数倒退，就是最终的结果</em>。比如，<em>5 的二进制就是 101</em>。</p><p><img data-src="pic1.png" alt="5除以2取余数"></p><p>在代码中，我们一般使用 <strong><code>parseInt()</code> 把 任意进制 转成 十进制</strong>。使用 <strong><code>toString()</code> 把 十进制 转成 任意进制</strong>。</p><ul><li>使用 <code>0x</code> 前缀表示 <strong>十六进制</strong>，<code>0o</code> 前缀表示 <strong>八进制</strong>，<code>0b</code> 前缀表示 <strong>二进制</strong>。如 <code>0x64</code> 表示 <em>十进制的100</em>，<code>0o555</code> 表示 <em>十进制的365</em>，<code>0b1111</code> 表示 十进制的15。</li><li><code>toString()</code> 如果不填入参数，则默认转换成 十进制。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 任意进制 转成 十进制</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">'20'</span>,<span class="number">10</span>)); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">'11'</span>,<span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">'20'</span>,<span class="number">16</span>)); <span class="comment">// 32</span></span><br><span class="line"><span class="comment">// 十进制 转成 任意进制</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">3</span>).toString(<span class="number">2</span>)); <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3.</span>.toString(<span class="number">2</span>)); <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">77</span>).toString(<span class="number">8</span>)); <span class="comment">// 115 </span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">77</span>).toString(<span class="number">16</span>)); <span class="comment">// 4d </span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">17</span>).toString(<span class="number">8</span>)); <span class="comment">// 21</span></span><br><span class="line"><span class="comment">// 十六进制 转成 任意进制</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">0x64</span>).toString(<span class="number">2</span>));  <span class="comment">// 1100100</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">0x32</span>).toString(<span class="number">8</span>)); <span class="comment">// 62</span></span><br></pre></td></tr></table></figure><h3 id="小数转换"><a href="#小数转换" class="headerlink" title="小数转换"></a>小数转换</h3><p>再回到我们最上面的题目。</p><p>我们现在需要算的是 <strong>小数（浮点数）</strong>，那么我们将小数转换成二进制进行存储，我们就需要用到 <strong>乘二取整法</strong>。</p><p>将 小数（浮点数）乘以2，若计算结果包含整数，则取出整数，记为1。反之则记为0。</p><p>如 <code>0.5 * 2 = 1 …… 0</code> ，则 <em>0.5</em> 的二进制为 <em>0.1</em>。</p><p>现在我们来看一下， <em>0.1</em> 的二进制是多少。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 乘二取整法</span></span><br><span class="line"><span class="comment">// 0.1 * 2 = 0.2 …… 0</span></span><br><span class="line"><span class="comment">// 0.2 * 2 = 0.4 …… 0</span></span><br><span class="line"><span class="comment">// 0.4 * 2 = 0.8 …… 0</span></span><br><span class="line"><span class="comment">// 0.8 * 2 = 1.6 …… 1</span></span><br><span class="line"><span class="comment">// 0.6 * 2 = 1.2 …… 1</span></span><br><span class="line"><span class="comment">// 0.2 * 2 = 0.4 …… 0</span></span><br><span class="line"><span class="comment">// ... 以此类推</span></span><br></pre></td></tr></table></figure><p>我们可以发现，结果是一个无限循环的二进制数 <code>0.0001100110011001100110011001100110011001100110011001101</code>。</p><p>同理我们也可以算出，<em>0.2</em> 的二进制是 <code>0.001100110011001100110011001100110011001100110011001101</code>。</p><p>我们可以发现，<em>0.1</em> 与 <em>0.2</em> 的二进制差了一位，无线数在计算机内部存储时会有长度限制，所以最终会存在错位的情况。</p><p>所以其十进制结果，最后会有几个 二进制单位的1 无法被计算。</p><p>这样才会导致 <code>0.1 + 0.2 === 0.30000000000000004</code>。</p><h3 id="精度问题的解决方案"><a href="#精度问题的解决方案" class="headerlink" title="精度问题的解决方案"></a>精度问题的解决方案</h3><p>推荐使用 <span class="exturl" data-url="aHR0cHM6Ly9tYXRoanMub3JnLw==">Math.js<i class="fa fa-external-link-alt"></i></span> 进行处理，他支持 <code>BigNumber</code> 的数据类型。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">'mathjs'</span>);</span><br><span class="line"><span class="keyword">let</span> big1 = math.bignumber(<span class="number">0.1</span>);</span><br><span class="line"><span class="keyword">let</span> big2 = math.bignumber(<span class="number">0.2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(math.add(big1, big2)); <span class="comment">// 0.3</span></span><br></pre></td></tr></table></figure><blockquote><p>本篇文章由 <strong>莫小尚</strong> 创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>Node</tag>
        <tag>JS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—Node中的EventLoop</title>
    <url>/2021/11/14/Node-%E4%B8%8A/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E7%9A%84EventLoop/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTQvMTAvZXZlbnQtbG9vcC5odG1s">JavaScript运行机制详解<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>首先，<code>process.nextTick</code>是node自己实现的方法，并<strong>不属于node中的EventLoop</strong>，他的<strong>优先级也比promise更高</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// nextTick</span></span><br><span class="line"><span class="comment">// promise</span></span><br></pre></td></tr></table></figure><p>我们可以看到，上述执行队列中，会<em>先输出nextTick，再输出promise</em>。</p><p>原因就是因为nextTick的执行位置，他会<strong>在执行上下文栈执行完毕后，立即执行nextTick</strong>。</p><p><img data-src="pic4.png" alt="node中的nextTick"></p><h2 id="Node中的EventLoop"><a href="#Node中的EventLoop" class="headerlink" title="Node中的EventLoop"></a>Node中的EventLoop</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL3poLWNuL2RvY3MvZ3VpZGVzL2V2ZW50LWxvb3AtdGltZXJzLWFuZC1uZXh0dGljay8=">Node.js事件循环、定时器和process.nextTick()<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>为了更好的学习和理解EventLoop与nextTick的关系，我们也可以参考下图。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数。</span><br><span class="line">   ┌───────────────────────────┐</span><br><span class="line">┌─&gt;│           timers          │ </span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">|   执行延迟到下一个循环迭代的 I&#x2F;O 回调。</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │     pending callbacks     │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">|   仅系统内部使用。</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │       idle, prepare       │</span><br><span class="line">│  └─────────────┬─────────────┘      </span><br><span class="line">|   检索新的I&#x2F;O事件;执行与 I&#x2F;O 相关的回调  ┌───────────────┐</span><br><span class="line">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class="line">│  │           poll            │&lt;─────┤  connections, │</span><br><span class="line">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class="line">│   setImmediate() 回调函数在这里执行。  └───────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐      </span><br><span class="line">│  │           check           │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">|  一些关闭的回调函数</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">└──┤      close callbacks      │  </span><br><span class="line">   └───────────────────────────┘</span><br></pre></td></tr></table></figure><p>这里每一个阶段都对应一个事件队列，当 event loop 执行到某个阶段时会将当前阶段对应的队列依次执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段。</p><p>我们可以通过以下代码来感受一下上述概念。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// timeout</span></span><br><span class="line"><span class="comment">// setImmediate</span></span><br></pre></td></tr></table></figure><p>这里我们可以发现，<em>timeout</em> 会在 <em>setImmediate</em> 之前输出。</p><p>但是这里会有一个问题，多次执行之后我们会发现，<em>timeout</em> 也会在 <em>setImmediate</em> 之后输出。</p><p>原因是因为当前默认<strong>执行主栈代码</strong>，主栈代码执行完毕后，<strong>再去执行宏任务队列</strong>。但是因为我们的<strong>定时器设定</strong>的时间是0，可能会<strong>有几毫秒的延迟</strong>，所以当主栈代码执行完毕后，定时器并<strong>没有到达指定的执行时间</strong>，所以会存在两个结果输出情况不一致的情况。</p><p>我们可以称他为 <strong><em>准备阶段时间</em></strong>。</p><p>假设我们目前存在这样一段代码，从I/O事件中执行<em>setImmediate</em> 与 <em>setTimeout</em>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">'./test.txt'</span>, <span class="string">'utf-8'</span>, () =&gt; &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//setImmediate</span></span><br><span class="line"><span class="comment">//timeout</span></span><br></pre></td></tr></table></figure><p>我们的代码在执行时，会先检测是否存在 <strong><em>timer</em>阶段</strong>，也就是定时器。没有的话，会去检测 <strong><em>poll</em>队列</strong>（I/O事件）是否为空。检测完毕后，再去检测是否存在 setImmediate，也就是 <strong><em>check</em>阶段</strong> 。检测完毕后，会进行轮询，也就是下一轮检测。</p><p>这样我们可以<strong>总结一下</strong>：</p><ol><li>检测Poll队列中是否为空，如果不为空则执行队列中的任务，直到超时或者全部执行完毕。</li><li>执行完毕后检测setImmediate队列是否为空，如果不为空则执行check阶段，如果为空则等待时间到达。时间到达后回到timer阶段。</li><li>等待时间到达是可能会出现新的callback，此时也在当前阶段被清空。</li></ol><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>搞清楚了Node中的EventLoop，那么EventLoop和微任务的关系又是什么样的呢？</p><p>我们可以看一道曾经腾讯的面试题</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'c'</span>);</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'d'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'e'</span>);</span><br><span class="line"><span class="comment">// c e d a b</span></span><br></pre></td></tr></table></figure><p>根据我们之前学过的知识我们可以推导出这道题的结果。</p><p>Node在执行时，会先将主执行栈代码执行完毕，这时<em>输出结果 c 、e<em>，将</em>promise.then()放入微任务队列<em>。然后会拿出一个宏任务并执行，先清空微任务队列，这时 *输出结果 d</em>。随后再执行定时器回调，*输出结果 a</em> 。然后根据Node中EventLoop的执行顺序，timer清空完毕后进入poll阶段，检查是否存在I/O事件。随后检测setImmediate队列，并将 <em>输出结果 b</em>。</p><hr><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>Node</tag>
        <tag>JS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—Node的全局对象</title>
    <url>/2021/11/05/Node-%E4%B8%8A/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E7%9A%84%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="Node中的全局对象"><a href="#Node中的全局对象" class="headerlink" title="Node中的全局对象"></a>Node中的全局对象</h2><blockquote><p>参考官网 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL3poLWNuL2RvY3Mv">Node.js官网<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>首先我们先要清楚一个概念。一个默认执行的js文件，使用node来执行他会把这个文件当成一个模块来执行。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>this是一个空对象，模块会默认将this给进行修改。</p><p>在前端（html）中，访问变量是通过<strong>window</strong>属性。而在后端（node）中，访问变量是通过<strong>global</strong>属性。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在node环境下运行</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="keyword">this</span>); <span class="comment">// global</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>我们可以在控制台中，查看打印出来的结果。</p><p><img data-src="pic3.png" alt="global"></p><p>其中有很多我们经常用到的方法，例如<em>setTimeout</em>、<em>clearTimeout</em>、<em>setInterval</em>、<em>clearInterval</em>、setImmediate、<em>clearImmediate</em>等等。</p><p><em>（我们可以使用 <code>console.dir(this, {showHidden: true})</code> 查看隐藏属性，更全面的观察global。）</em></p><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。</p><p>但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个<strong>专门存放二进制数据的缓存区</strong>。</p><p><em>（后期会有博客对此进行详细说明）</em></p><h3 id="dirname-filename"><a href="#dirname-filename" class="headerlink" title="__dirname / __filename"></a><strong>__dirname</strong> / <strong>__filename</strong></h3><ul><li><strong>__dirname</strong> ：表示当前文件执行时的 <em>固定目录</em> ，也就是目录的绝对路径。</li><li><strong>__filename</strong> ：表示当前文件自己执行位置的 绝对路径。</li></ul><p>使用 <strong>__dirname</strong> 和 <strong>__filename</strong> 的路径，是准确的绝对路径。</p><h3 id="process"><a href="#process" class="headerlink" title="process"></a>process</h3><blockquote><p>参考官网 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wcm9jZXNzLmh0bWw=">process<i class="fa fa-external-link-alt"></i></span></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process);</span><br></pre></td></tr></table></figure><h4 id="platform"><a href="#platform" class="headerlink" title="platform"></a>platform</h4><p>表示<strong>当前运行的平台</strong>（win、mac 等等）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.platform); <span class="comment">// win32</span></span><br></pre></td></tr></table></figure><p><em>win32表示我当前运行的平台是 windows，而 mac的输出结果是 darwin。</em></p><p>我们可以根据其输出结果的不同，做不同的命令配置。</p><h4 id="chdir"><a href="#chdir" class="headerlink" title="chdir"></a>chdir</h4><p><code>change directory</code>，<strong>修改当前文件运行目录</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改前文件位置 d:\****\****\test\demo</span></span><br><span class="line">process.chdir(<span class="string">'../'</span>)</span><br><span class="line"><span class="comment">// 修改后文件位置 d:\****\****\test</span></span><br></pre></td></tr></table></figure><p><em>此方法我们很少会应用到。</em></p><h4 id="cwd"><a href="#cwd" class="headerlink" title="cwd"></a>cwd</h4><p><code>current working directory</code>的缩写，表示<strong>当前工作目录</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.cwd()); <span class="comment">// d:\****\****\test\demo</span></span><br></pre></td></tr></table></figure><p>当前文件运行在哪个目录中，他就会显示哪个目录。</p><p>假设我们换一下运行此文件的目录（如在上级目录运行此文件），那结果就会显示运行文件的位置。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.cwd()); <span class="comment">// d:\****\****\test</span></span><br></pre></td></tr></table></figure><p>在webpack中，<em>webpack会使用此方法自动查找并运行目录下的webpack.config.js文件</em>。</p><h4 id="env"><a href="#env" class="headerlink" title="env"></a>env</h4><p>表示当前的<strong>环境变量</strong>，而环境变量分为 <em>用户变量</em> 和 <em>系统变量</em> 。</p><p>在实际场景中，我们可以通过此变量来判断当前的运行环境（<em>生产环境、开发环境 和 测试环境 等等</em>）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">"dev"</span>) &#123;</span><br><span class="line">    <span class="comment">// 开发环境</span></span><br><span class="line">    <span class="comment">// do something ... </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 生产环境</span></span><br><span class="line">    <span class="comment">// do something ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（<em>因目前Node各版本设置process.env的差异，在此不做配置环境变量的演示了，配置方法以 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2RvY3MvbGF0ZXN0LXYxNC54L2FwaS9wcm9jZXNzLmh0bWwjcHJvY2Vzc19wcm9jZXNzX2Vudg==">process.env官网<i class="fa fa-external-link-alt"></i></span> 为准</em>）</p><h4 id="argv"><a href="#argv" class="headerlink" title="argv"></a>argv</h4><p>表示启动时<strong>传入的命令行参数</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.argv); </span><br><span class="line"><span class="comment">// ['C:\\Program Files\\nodejs\\node.exe', 'd:\\****\\****\\test\\demo\\index.js']</span></span><br></pre></td></tr></table></figure><p>其中返回了一个数组，第一个属性表示 <em>执行node所在的.exe文件</em> ，第二个属性表示 <em>当前执行的文件</em> 。</p><p>在实际场景中，我们可能会在命令行中输入其他需要传入的指令。</p><p>比如要启动一个server程序，我们就需要拟定一个端口号<code>--port 3000</code>。我们再使用上面的变量，输出的结果就会多出来 <code>--port</code> 和 <code>3000</code>。这样我们就可以对用户传递的参数进行解析，从而生成对应的功能。</p><p>（<em>我们也可以使用 *</em><span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY29tbWFuZGVy">commander<i class="fa fa-external-link-alt"></i></span>** 来解析我们想要的参数。后续文章中，我们也会使用此插件，开发一套cli脚手架。*）</p><h4 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h4><p>表示<strong>延迟加载</strong>，他和<code>setImmediate()</code>都属于延迟加载。但是setImmediate是<strong>将任务放到队列前面</strong>，而nextTick是<strong>将任务放到队列末尾</strong>。</p><p><em>下一篇文章我会细讲一下nextTick。</em></p><hr><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>Node</tag>
        <tag>JS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—Node中模块化规范</title>
    <url>/2021/11/15/Node-%E4%B8%8A/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="模块化与全局对象"><a href="#模块化与全局对象" class="headerlink" title="模块化与全局对象"></a>模块化与全局对象</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0LXYxNi54L2RvY3MvYXBpL2dsb2JhbHMuaHRtbA==">Global objects|Node.js<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>首先，模块化包括 <em>require()</em> 、<em>exports</em> 和 <em>module</em> 等。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(global.exports); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(global.module); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(global.require); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>但是当我们在控制台打印时，发现其结果都是 <em>undefined</em>。我们却可以直接对这些属性进行访问，比如<code>console.log(require)</code>。</p><p>这里需要注意，global上有的属性叫做<strong>全局属性</strong>，可以直接访问。但 <em>require()</em> 、<em>exports</em> 和 <em>module</em> 也可以直接访问，但是他们却不在global对象上。</p><p><em>每个文件都是一个模块，模块化的实现借助的是函数。</em></p><p>而这个函数里面有五个参数，分别是 <em>__dirname*、</em>__filename* 、<em>require()</em> 、<em>exports</em> 和 <em>module<em>。</em>（后续我会写一篇文章来实现模块化）</em></p><h2 id="模块化的规范"><a href="#模块化的规范" class="headerlink" title="模块化的规范"></a>模块化的规范</h2><p>模块化规范包括以下几种</p><ul><li>CommonJs规范</li><li>ESModule规范</li><li>AMD</li><li>CMD</li><li>UMD</li><li>SystemJs</li><li>…</li></ul><p><strong>为什么要有模块化规范？</strong></p><p>JS 诞生的时候，仅仅是为了实现网页表单的本地校验和简单的 dom 操作处理。所以并没有模块化的规范设计。</p><p>项目小的时候，我们可以通过命名空间、局部作用域、自执行函数等手段实现变量不冲突。但是到了大一点的项目，各种组件，各种第三方插件和各种 js 脚步融合的时候，就会发现这些技巧远远不够。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>最早的时候，一些项目组会采用 <strong>单例设计模式</strong> 来解决这个问题。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成员a</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  aa()&#123; </span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 成员b</span></span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">  bb()&#123;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种解决方式就会出现 <em>命名过长，难以调用</em> 等问题。所以他 <em>解决了，但没有完全解决</em>。</p><h3 id="AMD、CMD"><a href="#AMD、CMD" class="headerlink" title="AMD、CMD"></a>AMD、CMD</h3><p>为了解决模块化的问题，人们用 <strong>文件拆分</strong> 的方式，配合 iife *<em>自执行函数 *</em>来解决。也就是 <em>AMD、CMD</em>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xx = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>这种方式在前端中需要请求顺序，也就出现了依赖问题。比如我们现在有一个文件a，他需要依赖文件b和文件c，但是c文件又需要依赖文件d。这时候就出现了文件之间的依赖问题，我们并不知道每个文件需要依赖的文件都有谁。</p><p>这就是以前出现的依赖前置 <code>define([&#39;jquery&#39;,&#39;xxx&#39;],function(){ // ... })</code></p><h3 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h3><p>它可以通过运行时或者编译时让同一个代码模块在使用 CommonJs、CMD 甚至是 AMD 的项目中运行。未来同一个 JavaScript 包运行在浏览器端、服务区端甚至是 APP 端都只需要遵守同一个写法就行了。</p><p>简单来说，他的出现就是为了兼容CommonJs、CMD和AMD，但是他并<em>不兼容ESModule<em>。</em>（所以我们在平时发布组件库时，就会将代码打包成 UMD 和 ESModule 两种）</em></p><h3 id="CommonJs和ESModule的区别"><a href="#CommonJs和ESModule的区别" class="headerlink" title="CommonJs和ESModule的区别"></a>CommonJs和ESModule的区别</h3><p><em>CommonJs</em> 和 <em>ESModule</em> 的定义都是一样的，<strong>一个文件就是一个模块</strong>。</p><ul><li><p><strong>CommonJs的用法</strong>： <em>require()</em> 是使用其他模块，<em>module.exports</em> 是导出模块。</p></li><li><p><strong>ESModule的用法</strong>：<em>import</em> 是使用其他模块，<em>export</em> 是导出模块。</p><p><em>CommonJs</em> 是<strong>基于Node的I/O操作</strong>，如果我想进行模块的引入和导出，我就需要使用Node来进行操作。</p></li></ul><p>而 <em>ESModule</em> 是<strong>基于浏览器的请求</strong>，如果我想进行引入导出的操作，我就需要使用浏览器。</p><p>我们也可以理解为，<strong><em>ESModule</em> 是静态的</strong>，而 <strong><em>CommonJs</em>是动态的</strong>。所以我们平时才会使用 <em>require()</em> 来对资源进行动态引入。 <em>（注：目前ES7中支持 import(‘./xxx’)来对资源进行动态引入）</em></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ESModule不可以动态引入资源</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="comment">// 这种写法不成立</span></span><br><span class="line">  <span class="keyword">import</span> xxx <span class="keyword">from</span> <span class="string">'./xxx'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CommonJs可以动态引入资源</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./xxx'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>(在现在的实际项目中，我们一般会使用webpack来对文件进行自动编译。)</em></p><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>Node</tag>
        <tag>JS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—EJS模板引擎的使用与原理</title>
    <url>/2021/11/29/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94EJS%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>首先我们要先清楚，什么是 <strong>模板引擎</strong> ？</p><p>模板引擎的诞生是为了将显示与数据分离。</p><p>模板技术多种多样，但其本质是将模板文件和数据通过模板引擎生成最终的HTML代码。</p><p>这里我们以最常见的模板引擎 <em>EJS</em> 举例说明。</p><h3 id="EJS的使用"><a href="#EJS的使用" class="headerlink" title="EJS的使用"></a>EJS的使用</h3><p>本篇文章我们不讲使用，主要是为了手写实现 <code>EJS</code> 的原理。</p><blockquote><p>参考官网 <span class="exturl" data-url="aHR0cHM6Ly9lanMuYm9vdGNzcy5jb20v">EJS|嵌入式JavaScript模板引擎<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>首先我们先对EJS进行安装。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 利用NPM安装</span><br><span class="line">$ npm install ejs</span><br></pre></td></tr></table></figure><p>在目录中，我们可以创建一个 <code>template.html</code> 的html文件。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%=name%</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%=age%</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加两个标签用来做渲染。</p><p>再创建一个 <code>ejs.js</code> 的文件。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ejs = <span class="built_in">require</span>(<span class="string">'ejs'</span>); <span class="comment">// 导入ejs</span></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> r = <span class="keyword">await</span> ejs.renderFile(<span class="string">'./template.html'</span>,&#123;<span class="attr">name</span>:<span class="string">'momo'</span>,<span class="attr">age</span>:<span class="number">26</span>&#125;) <span class="comment">// 使用renderFile进行渲染</span></span><br><span class="line">    <span class="built_in">console</span>.log(r); <span class="comment">// 打印出结果</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>打印后发现，<em>name</em> 和 <em>age</em> 已经被渲染在了视图<em>（字符串）</em>上。</p><p><img data-src="pic18.png" alt="node控制台中打印结果"></p><p>通过上述的打印结果，我们便可以尝试手写实现 <code>ejs类</code>。</p><h3 id="EJS的实现原理"><a href="#EJS的实现原理" class="headerlink" title="EJS的实现原理"></a>EJS的实现原理</h3><p>首先，先根据需要的参数内容，实现一个类<em>（函数）</em>，里面包含一个 <code>readerFile</code> 方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ejs = &#123;</span><br><span class="line">  readerFile(filename,options)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来实现一套简单的 <code>renderFile</code> 方法。</p><h4 id="简单情况"><a href="#简单情况" class="headerlink" title="简单情况"></a>简单情况</h4><p>先做一套最简单的实现，熟悉一下原理和逻辑。</p><p>来看一下完整代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">"util"</span>);</span><br><span class="line"><span class="keyword">const</span> read = util.promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ejs = &#123;</span><br><span class="line">  <span class="keyword">async</span> renderFile(filename, options) &#123;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="keyword">await</span> read(filename, <span class="string">"utf-8"</span>);</span><br><span class="line">    content = content.replace(<span class="regexp">/&lt;%=(.+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> options[<span class="built_in">arguments</span>[<span class="number">1</span>]];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为 <code>readerFile</code> 需要对文件进行读写，所以我们还需要封装一个可以进行读写的 <code>read</code> 方法。</p><p>根据我之前文章中的写法，我们可以利用 <a href="https://mxshang.github.io/2021/08/05/Promise/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Promise%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95/">promisify</a> 对读写方法进行封装。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> read = util.promisify(fs.readFile);</span><br></pre></td></tr></table></figure><p>这样我们就得到了一个可以进行异步读写的 <code>read</code> 函数。</p><p>随后我们将 <code>read</code> 函数放到我们上面的 <code>readerFile</code> 方法中，我们现在就得到了一个可以读取html模板的方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ejs = &#123;</span><br><span class="line">  <span class="keyword">async</span> renderFile(filename, options) &#123;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="keyword">await</span> read(filename,<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(content); <span class="comment">// 可以直接打印出html文件模板</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>随后我们就可以对方法进行进一步处理了。</p><p>下一步我们就需要对 <code>&lt;%= ... %&gt;</code> 进行替换处理了。</p><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9yZWdleHAvcmVnZXhwLXN5bnRheC5odG1s">正则表达式 | 菜鸟教程<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>使用 <em>正则表达式</em> 对匹配的内容进行替换处理即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ejs = &#123;</span><br><span class="line">  <span class="keyword">async</span> renderFile(filename, options) &#123;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="keyword">await</span> read(filename,<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="comment">// 正则匹配内容，替换并输出结果</span></span><br><span class="line">    content = content.replace(<span class="regexp">/&lt;%=(.+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> options[<span class="built_in">arguments</span>[<span class="number">1</span>]]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样我们就实现了一套最简单的 <code>ejs.renderFile</code> 方法。</p><h4 id="复杂情况"><a href="#复杂情况" class="headerlink" title="复杂情况"></a>复杂情况</h4><p>实现了上面的简单情况，我们再来实现一种复杂情况。</p><p>还是上面那个例子，假设我们在 <code>html</code> 模板中去渲染 <em>数组</em>。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%arr.forEach((item)=</span>&gt;</span>&#123;%&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">%=item%</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%&#125;)%</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>js</code> 中也许要进行对应的修改。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js</span></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> r = <span class="keyword">await</span> ejs.renderFile(<span class="string">"./template.html"</span>, &#123;</span><br><span class="line">    arr: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(r); <span class="comment">// 数组模板被渲染出来了</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>我们上面的简单情况的实现方式就无法满足这个需求，所以我们需要一套处理复杂情况的实现方式。</p><p>我们需要对上面的 <strong>简单情况</strong> 的实现方式代码进行一些 <strong>修改</strong> 。</p><p>先来看一下完整的实现代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">"util"</span>);</span><br><span class="line"><span class="keyword">const</span> read = util.promisify(fs.readFile);</span><br><span class="line"><span class="comment">// 复杂情况的实现</span></span><br><span class="line"><span class="keyword">let</span> ejs = &#123;</span><br><span class="line">  <span class="keyword">async</span> renderFile(filename, options) &#123;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="keyword">await</span> read(filename, <span class="string">"utf-8"</span>);</span><br><span class="line">    content = content.replace(<span class="regexp">/&lt;%=(.+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'$&#123;'</span> + <span class="built_in">arguments</span>[<span class="number">1</span>] + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> head = <span class="string">'let str = "";\nwith(obj)&#123;\nstr +=`'</span>;</span><br><span class="line">    <span class="keyword">let</span> body = content = content.replace(<span class="regexp">/&lt;%(.+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'`\n'</span> + <span class="built_in">arguments</span>[<span class="number">1</span>] + <span class="string">'\nstr+=`'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> foot = <span class="string">'`&#125; return str'</span></span><br><span class="line">    <span class="keyword">let</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'obj'</span>, head + body + foot)</span><br><span class="line">    <span class="keyword">return</span> fn(options);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> r = <span class="keyword">await</span> ejs.renderFile(<span class="string">"./template.html"</span>, &#123;</span><br><span class="line">    arr: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>在实现代码之前，我们需要先对其实现原理进行一些分析。</p><ol><li><p><strong>字符串拼接</strong></p><p><code>webpack.loader</code> 的底层实现其实就是 <em>字符串拼接</em> 。我们可以利用这种思路，来对我们需要重新拼接的模板进行拆分并拼接。</p><p>我们先来看一下完整的 <code>html</code> 文件是什么样的。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%arr.forEach((item)=</span>&gt;</span>&#123;%&gt;</span><br><span class="line">    <span class="comment">&lt;!-- &lt;li&gt;&lt;%=item%&gt;&lt;/li&gt; --&gt;</span></span><br><span class="line">  	<span class="comment">&lt;!-- 上面是原本需要输出的结果，这里先不考虑item --&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%&#125;)%</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在我们读取文件时，我们其实读取到的是一串 <em>字符串</em> 。</p><p>所以我们最终 <em>需要输出的模板</em> ，其实是下面这个样子的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">""</span>;</span><br><span class="line"><span class="comment">// 截取第一个&lt;% 之前的代码 </span></span><br><span class="line">str += <span class="string">`&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">&lt;html lang="en"&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">    &lt;meta charset="UTF-8"&gt;</span></span><br><span class="line"><span class="string">    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;</span></span><br><span class="line"><span class="string">    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;Document&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;`</span></span><br><span class="line"><span class="comment">// 拼接 forEach 的结果</span></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    str += <span class="string">`&lt;li&gt;1&lt;/li&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 拼接 末尾</span></span><br><span class="line">str += <span class="string">`</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;`</span></span><br></pre></td></tr></table></figure><p>要将代码拼接成上述效果， <em>实现原理的代码</em> 就变成了这样。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">let</span> ejs = &#123;</span><br><span class="line">  <span class="keyword">async</span> renderFile(filename, options) &#123;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="keyword">await</span> read(filename, <span class="string">"utf-8"</span>);</span><br><span class="line">    <span class="keyword">let</span> head = <span class="string">'let str = "";\nstr +=`'</span>;</span><br><span class="line">    <span class="keyword">let</span> body = content = content.replace(<span class="regexp">/&lt;%(.+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'`\n'</span> + <span class="built_in">arguments</span>[<span class="number">1</span>] + <span class="string">'\nstr+=`'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> foot = <span class="string">'`'</span></span><br><span class="line">    <span class="keyword">return</span> head + body + foot;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>with</code> 处理循环</strong></p><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvU3RhdGVtZW50cy93aXRo">with - JavaScript | MDN<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>为什么要用 <code>with</code> ？ 因为 <code>with</code> 可以使当前代码运行在指定的作用域内。</p><p>所以 <em>最终模板</em> 就会被渲染成这样。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">""</span>;</span><br><span class="line"><span class="comment">// obj就是传入的参数 options，也就是 &#123;arr:[1,2,3]&#125;</span></span><br><span class="line"><span class="keyword">with</span>(obj)&#123;</span><br><span class="line">str += <span class="string">`&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">&lt;html lang="en"&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">    &lt;meta charset="UTF-8"&gt;</span></span><br><span class="line"><span class="string">    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;</span></span><br><span class="line"><span class="string">    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;Document&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;`</span></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    str += <span class="string">`&lt;li&gt;1&lt;/li&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line">str += <span class="string">`</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么会有一个 <code>obj</code> ？ 下一步分析中会详细说明。</p><p>我们再对 <em>实现代码</em> 进行一些修改。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">let</span> head = <span class="string">'let str = "";\nwith(obj)&#123;\nstr +=`'</span>;</span><br><span class="line"><span class="keyword">let</span> body = content = content.replace(<span class="regexp">/&lt;%(.+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'`\n'</span> + <span class="built_in">arguments</span>[<span class="number">1</span>] + <span class="string">'\nstr+=`'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> foot = <span class="string">'`&#125;'</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>其实就是在需要拼接的代码里面，加上 <code>with</code> 就可以了。</p></li><li><p><strong><code>new Function</code> 创建函数模板</strong></p><p>在上一步中，我们出现了一个不知名参数 <code>obj</code>。</p><p>我在注释中解释为，<em>传入的参数</em> 。</p><p>通过一个函数，将参数传入 模板中，并执行最终的结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">with</span> (obj) &#123;</span><br><span class="line">    str += <span class="string">`&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">&lt;html lang="en"&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">    &lt;meta charset="UTF-8"&gt;</span></span><br><span class="line"><span class="string">    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;</span></span><br><span class="line"><span class="string">    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;Document&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      str += <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;li&gt;1&lt;/li&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    str += <span class="string">`</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">fn(&#123; <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &#125;);</span><br></pre></td></tr></table></figure><p>其实就是在最外层套了一个 <code>function</code> 函数，里面有传入的参数 <em>{arr: [1, 2, 3]}</em>。</p><p>这样，我们在 <em>实现代码</em> 中，便可以使用 <a href="https://mxshang.github.io/2021/11/16/Node-%E4%B8%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/">new Function</a> 来实现此思路。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="keyword">let</span> foot = <span class="string">'`&#125; return str'</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'obj'</span>, head + body + foot)</span><br><span class="line"><span class="keyword">return</span> fn(options);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><code>obj</code> 作为参数，<em>拼接的字符串</em> 作为函数执行。</p><p>这时我们可以发现，结果变成了我们想要的样子。</p><p>现在我们来进行最后一步，处理循环的结果。</p></li><li><p><strong>处理循环结果</strong></p><p>我们先将 <code>html</code> 里面的注释去掉。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%arr.forEach((item)=</span>&gt;</span>&#123;%&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">%=item%</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;li&gt;1&lt;/li&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%&#125;)%</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过上面分析中的函数模板，要输出 <code>item</code> ，其实只要使用 <em>模板字符串 <code>${}</code></em> 即可。</p><p>所以我们可以对上面的模板添加一个替换条件即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">content = content.replace(<span class="regexp">/&lt;%=(.+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'$&#123;'</span> + <span class="built_in">arguments</span>[<span class="number">1</span>] + <span class="string">'&#125;'</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这样我们就实现了 <code>ejs.renderFile</code> 方法的 <strong>复杂情况</strong>。</p></li></ol><p>在实际工作和面试中，很少会手写这种形式的代码。</p><p>我们只需要了解其实现原理即可。</p><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>Node</tag>
        <tag>JS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—Node中的Events模块</title>
    <url>/2021/11/30/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E7%9A%84Events%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="Events模块"><a href="#Events模块" class="headerlink" title="Events模块"></a>Events模块</h2><blockquote><p>参考官网 <span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvZXZlbnRzLmh0bWw=">events 事件触发器 | Node.js<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><code>Events</code> 模块是Node最重要的模块，它提供了一个属性 <code>EventEmitter</code>，<code>EventEmitter</code> 的核心是事件发射与事件监听器。</p><p>Node中大部分的模块，都继承自 <code>Events</code> 模块。</p><ul><li><code>Events</code> 模块是Node对 <strong>发布订阅模式</strong>（<code>publish/subscribe</code>）的实现。一个对象通过这个模块，向另一个对象传递消息。</li><li>该模块通过 <code>EventEmitter</code> 属性，提供了一个构造函数。该构造函数的实例具有 <code>on</code> 方法，可以用来监听指定事件，并触发回调函数。</li><li>任意对象都可以发布指定事件，被 <code>EventEmitter</code> 实例的on方法监听到。</li></ul><h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><blockquote><p>关于 <a href="https://mxshang.github.io/2021/07/12/Promise/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Promise%E4%B9%8B%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/">发布订阅模式</a> ，可以参考我之前的博客文章。</p></blockquote><p>关于 <code>Events</code> 中的发布订阅模式，我们要先清楚它的几个常用方法。</p><ul><li><strong>订阅方法</strong>：<code>on</code> 方法用来订阅事件，订阅是将方法对应成一种一对多的关系。</li><li><strong>发布方法</strong>：<code>emit</code> 用来执行订阅的事件。</li><li><strong>取消订阅</strong>：<code>off</code> 方法可以移除对应的事件监听。</li><li><strong>订阅一次</strong>：<code>once</code> 绑定事件当执行后自动删除订阅的事件。</li></ul><h4 id="on-和-emit"><a href="#on-和-emit" class="headerlink" title="on 和 emit"></a>on 和 emit</h4><p><code>on</code> 方法的第一个参数用来设定类名，第二个参数也是一个函数，里面可以接收发布时传入的参数。</p><p><code>emit</code> 方法第一个参数是类名，之后的参数都是传入 <code>on</code> 方法函数中的参数。</p><p><code>on</code> 和 <code>emit</code> 具体应用可以参考下面这个简单的Demo。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="comment">// 自定义一个 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 原型继承 需要通过实例来调用继承方法</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(Cat.prototype, EventEmitter.prototype);</span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, <span class="string">'睡'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> eat = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(b, <span class="string">'吃'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">cat.on(<span class="string">'猫咪'</span>, sleep)</span><br><span class="line">cat.on(<span class="string">'猫咪'</span>, eat)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  	<span class="comment">// 小胡子 吃</span></span><br><span class="line">  	<span class="comment">// 小胖仙 睡</span></span><br><span class="line">    cat.emit(<span class="string">'猫咪'</span>, <span class="string">'小胖仙'</span>, <span class="string">'小胡子'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>现在我们可以实现一套 <code>on</code> 和 <code>emit</code> 方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._event = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// on 方法</span></span><br><span class="line">EventEmitter.prototype.on = <span class="function"><span class="keyword">function</span> (<span class="params">eventName, callBack</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._event) &#123;</span><br><span class="line">        <span class="keyword">this</span>._event = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._event[eventName]) &#123;</span><br><span class="line">        <span class="keyword">this</span>._event[eventName].push(callBack) <span class="comment">// 相当于 &#123;eventName:[fn1,fn2]&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._event[eventName] = [callBack]; <span class="comment">// 相当于 &#123;eventName:[fn1]&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// emit 方法</span></span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span> (<span class="params">eventName, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._event[eventName].forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">        fn(...args)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="off"><a href="#off" class="headerlink" title="off"></a>off</h4><p><code>off</code> 方法的第一个参数用来设定类名，第二个参数传入需要被移除的函数回调。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  	<span class="comment">// 小胡子 吃</span></span><br><span class="line">  	<span class="comment">// 小胖仙 睡</span></span><br><span class="line">    cat.emit(<span class="string">'猫咪'</span>, <span class="string">'小胖仙'</span>, <span class="string">'小胡子'</span>)</span><br><span class="line">  	cat.off(<span class="string">'猫咪'</span>, sleep);</span><br><span class="line">  	<span class="comment">// 小胡子 吃</span></span><br><span class="line">    cat.emit(<span class="string">'猫咪'</span>, <span class="string">'小胖仙'</span>, <span class="string">'小胡子'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>这样我们可以大概判断出来，移除掉和我们传入函数相同的函数，我们很快想到 <a href="https://mxshang.github.io/2021/06/18/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BES6%E7%9A%84%E6%95%B0%E7%BB%84/">filter</a> 方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// off 方法</span></span><br><span class="line">EventEmitter.prototype.off = <span class="function"><span class="keyword">function</span> (<span class="params">eventName, callBack</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._event &amp;&amp; <span class="keyword">this</span>._event[eventName]) &#123;</span><br><span class="line">        <span class="keyword">this</span>._event[eventName] = <span class="keyword">this</span>._event[eventName].filter(</span><br><span class="line">          fn =&gt; fn !== callBack &amp;&amp; fn.c !== callBack <span class="comment">// fn.c参考下面的once方法实现</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="once"><a href="#once" class="headerlink" title="once"></a>once</h4><p><code>once</code> 方法的第一个参数用来设定类名，第二个参数传入只需要执行一次的函数回调。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> demolition =<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'拆家'</span>);</span><br><span class="line">&#125;</span><br><span class="line">cat.once(<span class="string">'猫咪'</span>, demolition)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  	<span class="comment">// ...... 拆家</span></span><br><span class="line">    cat.emit(<span class="string">'猫咪'</span>, <span class="string">'小胖仙'</span>, <span class="string">'小胡子'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>这样我们可以根据之前实现的 <code>on</code> 和 <code>off</code> 来实现此方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// once 方法</span></span><br><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span> (<span class="params">eventName, callBack</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> one = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        callBack();</span><br><span class="line">        <span class="keyword">this</span>.off(eventName, one);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.on(eventName, one);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来这个方法好像没有什么问题，执行起来也全都是正确的。</p><p>但是在一种特殊情况下的时候，还是出现了错误。</p><p>那种情况就是如果我们在执行 <code>once</code> 方法之前，就已经通过 <code>off</code> 方法将其移除了。</p><p>我们实现的方法就不能实现这个需求了，所以我们还需要对 <code>once</code> 方法进行一些修改 <em>（ <code>off</code> 方法已经处理过了）</em>。</p><p>添加一个自定义属性，用来对函数进行 “缓存” 。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span> (<span class="params">eventName, callBack</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> one = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    one.c = callBack; <span class="comment">// 自定义一个属性</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就实现了 <code>once</code> 方法。</p><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>Node</tag>
        <tag>JS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—Node中模块查找规范</title>
    <url>/2021/11/22/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E6%A8%A1%E5%9D%97%E6%9F%A5%E6%89%BE%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><p>在学习其他模块之前，我们先要清楚 <em>文件模块中的查找规范</em> 。</p><h2 id="模块查找规范"><a href="#模块查找规范" class="headerlink" title="模块查找规范"></a>模块查找规范</h2><p>引用自定义模块时，会自动查找目标目录下的 <em>index.js文件</em> 。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /jQuery/index.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">"jquery"</span></span><br><span class="line"><span class="comment">// /main.js</span></span><br><span class="line"><span class="keyword">const</span> jQuery = <span class="built_in">require</span>(<span class="string">'./jQuery'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(jQuery); <span class="comment">// jquery</span></span><br></pre></td></tr></table></figure><p>但是如果我们不去定义 <em>index.js</em>，则会出现无法查找文件的问题，也就是报错。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /jQuery/a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">"jquery"</span></span><br><span class="line"><span class="comment">// /main.js</span></span><br><span class="line"><span class="keyword">const</span> jQuery = <span class="built_in">require</span>(<span class="string">'./jQuery'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(jQuery); <span class="comment">// Cannot find module './jQuery'</span></span><br></pre></td></tr></table></figure><p>这样我们就需要一个描述文件 <code>package.json</code> ，在文件中有一个 <code>main</code> 属性，可以定义文件入口。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /jQuery/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"main"</span>:<span class="string">"./jQuery/a.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们再重新打印，发现结果被成功打印了出来。</p><p>所以我们可以总结一下文件模块的 <strong>查找规范</strong>：</p><ul><li>在 <strong>最新的node版本</strong>中，默认 <em>先查找同名文件</em> 。如果没找到，则尝试添加查找 <em>.js和.json文件</em> 。如果还是没有，会查找 <em>同名文件夹（当成了一个包）</em>，找到后，会先找 <em>package.json</em>文件。如果没有，则会继续查找 <em>index.js文件</em>。如果依旧不存在，则会报错。</li><li>在 <strong>老版本的node中</strong>， 如果 <em>有package.json</em> 的情况下，会<em>先找同名包</em>。如果 <em>没有package.json</em>，会去 <em>查找同名文件</em>。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 新版node查找流程</span><br><span class="line">│</span><br><span class="line">└───┤ 同名文件</span><br><span class="line"> │	</span><br><span class="line"> │──┤ 同名.js &#x2F; 同名.json</span><br><span class="line"> │</span><br><span class="line"> │──┤ 同名文件夹</span><br><span class="line">    │</span><br><span class="line">    │───┤ pageage.json</span><br><span class="line">    │</span><br><span class="line">    └───┤ index.js</span><br><span class="line">   </span><br><span class="line"> 都没找到，则抛出一个错误。</span><br></pre></td></tr></table></figure><p>这就是node的自定义模块查找规范，我们在平时面试的时候可能会遇到这种问题。</p><p>比如介绍一下 <em>node的模块查找机制<em>，我们就可以用这种方式去介绍。</em>（目前一般很少有问老版本node的查找机制，一般都会问两种查找机制的区别，感兴趣的可以去查阅相关资料。）</em></p><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>Node</tag>
        <tag>JS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—Node的基本概念</title>
    <url>/2021/11/02/Node-%E4%B8%8A/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="Node的基本概念"><a href="#Node的基本概念" class="headerlink" title="Node的基本概念"></a>Node的基本概念</h2><h3 id="什么是Node？"><a href="#什么是Node？" class="headerlink" title="什么是Node？"></a>什么是Node？</h3><p>Node.js是一个基于 Chrome V8 引擎的JavaScript运行环境(runtime)，Node不是一门语言是让js运行在后端的运行时，并且不包括javascript全集，因为在服务端中不包含DOM和BOM，Node也提供了一些新的模块例如http、fs模块等。Node.js 使用了事件驱动、非阻塞式 I/O 的模型，使其轻量又高效并且Node.js 的包管理器 npm，是全球最大的开源库生态系统。到此我们已经对node有了简单的概念。</p><h3 id="Node的高并发"><a href="#Node的高并发" class="headerlink" title="Node的高并发"></a>Node的高并发</h3><p>Node在处理高并发，I/O密集场景有明显的性能优势。</p><ul><li>高并发，是指在同一时间并发访问服务器。</li><li>I/O密集指的是文件操作、网络操作、数据库,相对的有CPU密集，CPU密集指的是逻辑处理运算、压缩、解压、加密、解密。</li></ul><p>Web主要场景就是接收客户端的请求读取静态资源和渲染界面，所以Node非常适合Web应用的开发。</p><p>说到高并发，肯定就会想起多线程。那么多线程和高并发之间的关系和区别又是什么呢？</p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>首先我们先来了解一下什么是<strong>多线程</strong></p><p><img data-src="pic1.png" alt="多线程示意图"></p><p>后端语言（包括Java、C++等）存在一个<strong>线程池</strong>，每发送一次请求，线程池都会分配一个线程给服务器，用来处理请求，以此类推。因为多线程语言的特点是<strong>同步请求</strong>，所以在多线程发送请求时，可能会存在单个线程阻塞的情况，需要等待当前这个线程的任务处理完毕后，才会释放线程并放回到线程池，方便下一批任务的使用。当前线程数超过线程池最大可分配数量时，可能就会出现等待的情况。</p><ul><li><p><strong>多线程优点</strong>：可以<em>高效高速的处理多个api请求</em>（<em>图片压缩、大量计算 等…</em>），属于<strong>cpu密集型</strong>。</p></li><li><p><strong>多线程缺点</strong>：<em>不安全性</em>，假设我们有多个线程需要对数据库同一个资源进行操作（例如对同一个数据进行修改），就会出现数据安全性的问题 [<em>需要对资源进行加锁操作</em>]。</p></li></ul><p>多线程并非一起做某一件事，靠的是切换上下文（分时），所以<strong>多线程会浪费一些资源</strong>。</p><blockquote><p>关于多线程的具体概念，可以去查阅相关的资料。</p></blockquote><h4 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h4><p><strong>高并发</strong>是单线程的一个概念。</p><ul><li><strong>高并发优点</strong>：不需要开启多个线程，<strong>节省资源</strong>。</li><li><strong>高并发缺点</strong>：<strong>不适合做复杂操作</strong>，如果需要做复杂操作，可以开启子进程。</li></ul><p><em>Node是多线程的，但是其主线程是单线程。所以我们一直都说，Node其实是单线程语言。</em></p><h3 id="同步异步和阻塞非阻塞"><a href="#同步异步和阻塞非阻塞" class="headerlink" title="同步异步和阻塞非阻塞"></a>同步异步和阻塞非阻塞</h3><ul><li><strong>同步</strong>就是在执行某段代码时，代码没有得到返回之前，其他代码无法执行，当得到了返回值后可以继续执行其他代码。</li><li><strong>异步</strong>就是在执行某段代码时，代码不会立即得到返回结果，可以继续执行其他代码，返回值通过回调来获取。</li></ul><blockquote><p>关于<a href="https://mxshang.github.io/2021/10/26/Promise/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Generator%E5%92%8Casync-await/">同步阻塞与异步非阻塞</a>，可以参考我之前的文章。</p></blockquote><h3 id="Node中的EventLoop"><a href="#Node中的EventLoop" class="headerlink" title="Node中的EventLoop"></a>Node中的EventLoop</h3><p><img data-src="pic2.png" alt="Node中EventLoop原理"></p><ul><li>1.我们写的js代码会交给v8引擎进行处理。</li><li>2.代码中可能会调用nodeApi，node会交给libuv库处理</li><li>3.libuv通过阻塞i/o和多线程实现了异步io。</li><li>4.通过事件驱动的方式，将结果放到事件队列中，最终交给我们的应用。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数。</span><br><span class="line">   ┌───────────────────────────┐</span><br><span class="line">┌─&gt;│           timers          │ </span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">|   执行延迟到下一个循环迭代的 I&#x2F;O 回调。</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │     pending callbacks     │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">|   仅系统内部使用。</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │       idle, prepare       │</span><br><span class="line">│  └─────────────┬─────────────┘      </span><br><span class="line">|  检索新的I&#x2F;O事件;执行与 I&#x2F;O相关的回调  ┌───────────────┐</span><br><span class="line">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class="line">│  │           poll            │&lt;─────┤  connections, │</span><br><span class="line">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class="line">│  setImmediate() 回调函数在这里执行。  └───────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐      </span><br><span class="line">│  │           check           │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">|  一些关闭的回调函数</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">└──┤      close callbacks      │  </span><br><span class="line">   └───────────────────────────┘</span><br></pre></td></tr></table></figure><p>这里每一个阶段都对应一个事件队列,当event loop执行到某个阶段时会将当前阶段对应的队列依次执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段。</p><p><em><code>process.nextTick()</code> 从技术上讲不是事件循环的一部分。优先级高于微任务</em></p><p><strong>poll阶段:</strong></p><ol><li><p>检测Poll队列中是否为空，如果不为空则执行队列中的任务，直到超时或者全部执行完毕。</p></li><li><p>执行完毕后检测setImmediate队列是否为空，如果不为空则执行check阶段，如果为空则等待时间到达。时间到达后回到timer阶段</p></li><li><p>等待时间到达是可能会出现新的callback，此时也在当前阶段被清空</p></li></ol><hr><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>Node</tag>
        <tag>JS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—Node中第三方模块</title>
    <url>/2021/11/23/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h2><p>第三方模块的引用也是 <em>没有绝对路径</em> 的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(r);</span><br></pre></td></tr></table></figure><p>第三方模块的 <strong>引用形式主要分为两种</strong>：</p><ul><li><p><strong>全局模块</strong>，直接<strong>安装到电脑的npm目录下</strong>。</p></li><li><p><strong>内置的第三方模块</strong>，默认会沿着 <strong>当前目录向上查找 <code>node_modules</code> 下的同名文件夹，先根据 <code>package.json</code> 中的 <code>main</code> 设定的文件查找。如不存在，再到 <code>index.js</code> 中查找</strong>。如果自己的目录下未找到 <code>node_modules</code>，则会向上查找。<em>（可以通过打印 <code>module.paths</code> 进行路径查找）</em></p><p>假设我们在当前目录下，新建一个 <code>node_modules</code> ，在里面自定义一个文件夹名为 <code>co</code>，文件夹内包含一个 <code>index.js</code> 文件。文件里面写上内容 <code>module.exports = &quot;hello&quot;</code>。</p><p>这时我们再重新打印，发现上面的结果变成了 <code>hello</code>。</p><p>原因就是因为 <strong>第三方模块的查找规则</strong>。</p></li></ul><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm5wbWpzLmNvbS8=">npm Docs<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tLw==">npm<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>作为前端工程师，应该对<code>npm</code>并不陌生。（ <em>现在不建议使用 <code>cnpm</code> ，无法锁定版本，可能会出现很多奇怪的问题。目前推荐使用 <code>nrm</code> 或 <code>yarn</code></em> ）</p><p>这里我们介绍一下 ” <em>3n模块</em> “</p><ul><li><code>npm</code> 全称 <code>node package manager</code> ，是nodejs的包管理器 ，用于node插件管理，包括安装、卸载、管理依赖等。</li><li><code>nrm</code> 全称 <code>node registry manager</code> ，是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在 npm 源间切换。<em>（例：<code>nrm use taobao</code> 、 <code>nrm use cnpm</code> 等…）</em></li><li><code>nvm</code> 全称 <code>node version manager</code> ，是一个nodejs的版本管理工具，通过它可以安装和切换不同版本的 node 和 npm。</li></ul><p>使用npm安装的模块就是 <strong>全局模块</strong>，这种模块无法被 <code>require</code> 引用，<strong>只能通过命令行使用</strong>。</p><p><img data-src="pic11.png" alt="npm root -g"></p><p>我们之所以可以在 <em>cmd控制台</em> 直接访问npm或node，是因为在环境变量的Path属性上进行了配置。</p><p>而我们通过 npm安装的 <strong>全局模块</strong> ，会 <em>在npm目录下生成一个快捷方式</em> ，所以我们可以通过命令行使用全局模块。</p><h3 id="配置命令行命令"><a href="#配置命令行命令" class="headerlink" title="配置命令行命令"></a>配置命令行命令</h3><p>假设我们现在有一个需要在命令行中输出的文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; .&#x2F;bin&#x2F;www</span><br><span class="line">console.log(&#39;a&#39;)</span><br></pre></td></tr></table></figure><p>我们该如何进行配置呢？</p><p>首先通过命令行 <code>npm init -y</code> 生成默认的配置文件。</p><p><img data-src="pic12.png" alt="package.json"></p><p>在文件中添加属性 <code>bin</code> ，并在 <code>bin</code> 中添加相应的文件路径。<em>（我们也可以自定义一个命令，进行简便操作）</em></p><p><img data-src="pic13.png" alt="package.json"></p><p>我们将配置文件配置好后，需要放置到全局环境下。 这时有两种方式可以进行操作：</p><ul><li>发布到全局模块环境，并进行发布。</li><li>使用 <code>npm link</code> ，将我们当前文件link到 <em>node_module</em> 文件夹下。<em>（当前推荐使用这种，方便调试）</em></li></ul><p>这时我们可以看到，当前自定义命令 <code>&quot;gm&quot;</code> 已经映射到了我们当前的文件目录。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 控制台打印</span><br><span class="line">C:\Users\XXX\AppData\Roaming\npm\gm -&gt; C:\Users\XXX\AppData\Roaming\npm\node_modules\global-modules\bin\www</span><br><span class="line">C:\Users\XXX\AppData\Roaming\npm\node_modules\global-modules -&gt; D:\xxxx\xxxx\xxxx\xxx\xxx\global-modules</span><br></pre></td></tr></table></figure><p>但是我们现在还无法直接使用 <code>&quot;gm&quot;</code> 命令，我们还需要配置一个运行方式。</p><p>在我们之前创建好的文件最开头，输入 <code>#! /usr/bin/env node</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env node</span><br><span class="line">console.log(&#39;a&#39;)</span><br></pre></td></tr></table></figure><p>这行代码的意思就是告诉我们的命令行，当前文件是用当前环境变量里面node运行的。</p><p>修改了运行方式，我们需要重新运行 <code>npm link --force</code> 。<em>（<code>--force</code> 覆盖之前的配置文件）</em></p><p>这样我们就可以在命令行中输出我们配置文件中的内容了。</p><p><img data-src="pic14.png" alt="控制台输出"></p><p>我们可以通过这种方式，实现一些自定义的全局包，就可以采用这种方式进行配置。</p><p><strong>总结一下</strong>：</p><ol><li>先生成默认的配置文件。</li><li>配置 <code>bin</code> 命令。</li><li>在指定文件下添加执行方式 <code>#! /usr/bin/env node</code>。</li><li>将此包放到npm下，可以发布到全局环境，也可以使用 <code>npm link</code> 进行临时调试。</li></ol>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>Node</tag>
        <tag>JS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—Node中require的实现</title>
    <url>/2021/11/20/Node-%E4%B8%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%ADrequire%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="require"><a href="#require" class="headerlink" title="require"></a>require</h2><p>在上一篇文章中，我们了解到了如何去通过 <em>调试查看Node源码</em>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 require 引入文件</span></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = a;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure><p>通过调试查看 <code>require</code> 方法源码，其实现思路主要为以下几点。</p><ol><li><code>require</code> 方法的是 <code>Module</code> 模块的原型方法，也就是 <code>Module.prototype.require</code>。</li><li>通过 <code>Module._resolveFilename</code> 方法，将传入的路径转换为绝对路径。并添加文件的后缀名。<em>（.js、.json 等）</em></li><li><code>new Module</code> 拿到转换完毕的绝对路径，并创造一个模块并导出。（<em>其中包含一个属性id [ 当前文件路径 ]，还有一个 exports</em>）</li><li><code>Module.load</code> 对模块进行加载。</li><li>根据文件后缀 <code>Module._extensions[&#39;.js&#39;]</code> 去做策略加载。</li><li><code>fs.readFileSync</code> 同步读取文件。</li><li>增加了一个函数的外壳 <em>（ wrapper包装 ）</em> 让这个函数执行，并且让 <code>Module.exports</code> 作为当前上下文的 <code>this</code> 。</li><li>最终用户会拿到 <code>Module.exports</code> 的封装后的返回结果。</li></ol><p>所以，最终会返回一个 <code>Module.exports</code> 对象。通过以上思路，我们就可以实现一套 <code>require</code> 方法。</p><h3 id="实现require方法"><a href="#实现require方法" class="headerlink" title="实现require方法"></a>实现require方法</h3><p>根据上述规则，我们可以模拟实现一套 <code>require</code> 方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> vm = <span class="built_in">require</span>(<span class="string">'vm'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.exports = &#123;&#125;; </span><br><span class="line">&#125;</span><br><span class="line">Module.wrapper = [</span><br><span class="line">    <span class="string">`(function(exports,require,module,__filename,__dirname)&#123;`</span>,</span><br><span class="line">    <span class="string">`&#125;)`</span></span><br><span class="line">];</span><br><span class="line">Module._extensions = &#123;</span><br><span class="line">    <span class="string">'.js'</span>(<span class="built_in">module</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> content = fs.readFileSync(<span class="built_in">module</span>.id, <span class="string">'utf8'</span>);</span><br><span class="line">        content = Module.wrapper[<span class="number">0</span>] + content + Module.wrapper[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">let</span> fn = vm.runInThisContext(content);</span><br><span class="line">        <span class="keyword">let</span> exports = <span class="built_in">module</span>.exports;</span><br><span class="line">        <span class="keyword">let</span> dirname = path.dirname(<span class="built_in">module</span>.id);</span><br><span class="line">        fn.call(exports, exports, _require, <span class="built_in">module</span>, <span class="built_in">module</span>.id, dirname);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'.json'</span>(<span class="built_in">module</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> content = fs.readFileSync(<span class="built_in">module</span>.id, <span class="string">'utf8'</span>);</span><br><span class="line">        <span class="built_in">module</span>.exports = <span class="built_in">JSON</span>.parse(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Module._resolveFilename = <span class="function"><span class="keyword">function</span> (<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> filePath = path.resolve(__dirname, filename);</span><br><span class="line">    <span class="keyword">let</span> isExists = fs.existsSync(filePath);</span><br><span class="line">    <span class="keyword">if</span> (isExists) &#123;</span><br><span class="line">        <span class="keyword">return</span> absPath;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(Module._extensions);</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">						<span class="keyword">let</span> newPath = filePath + keys;</span><br><span class="line">						<span class="keyword">if</span> (fs.existsSync(newPath)) <span class="keyword">return</span> newPath;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'module not exists'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Module.prototype.load = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> extName = path.extname(<span class="keyword">this</span>.id);</span><br><span class="line">    Module._extensions[extName](<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Module._cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_require</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    filename = Module._resolveFilename(filename);</span><br><span class="line">    <span class="keyword">let</span> cacheModule = Module._cache[filename];</span><br><span class="line">    <span class="keyword">if</span> (cacheModule) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheModule.exports; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(filename);</span><br><span class="line">    Module._cache[filename] = <span class="built_in">module</span></span><br><span class="line">    <span class="built_in">module</span>.load();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们来进行一步一步的解析。</p><ol><li><p>首先，我们需要先引入需要用到的内置模块（<code>fs</code>、<code>path</code> 和 <code>vm</code>）。</p><p>自定义一个 <em>函数方法 <code>_require</code></em> ，这就是我们最终需要实现的方法，第一个参数接受传入的路径。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> vm = <span class="built_in">require</span>(<span class="string">'vm'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_require</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>随后我们还需要一个 <code>Module._resolveFilename</code> 方法将传入的路径转换成绝对路径，并添加后缀。</p><p>因为使用 <code>Module</code> 方法，我们我们也需要声明一个名为 <code>Module</code> 的构造函数。</p><p>随后将路径传入 <code>Module._resolveFilename</code>方法中。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Module._resolveFilename = <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> filePath = path.resolve(__dirname, id);</span><br><span class="line">    <span class="built_in">console</span>.log(filePath); <span class="comment">// d:\xxx\xxx\xxx\a</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_require</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    filename = Module._resolveFilename(filename); <span class="comment">// 绝对路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们发现目前打印的结果是没有后缀的<em>（不确定用户是否填写后缀）</em>，所以我们需要使用 <code>fs.existsSync</code> 判断当前路径是否存在。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module._resolveFilename = <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">let</span> isExists = fs.existsSync(filePath);</span><br><span class="line">  <span class="keyword">if</span> (isExists) <span class="keyword">return</span> filePath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果存在，则直接返回结果。如果不存在，我们就需要给当前路径尝试添加后缀。</p></li><li><p>这里我们就需要添加后缀，我们需要先定义一个 <code>Module._extensions</code> 方法来对后缀进行分类。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module._extensions = &#123;</span><br><span class="line">    <span class="string">'.js'</span>() &#123;&#125;,</span><br><span class="line">    <span class="string">'.json'</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们将定义的后缀方法的 <code>keys</code> 添加到路径上，并再次进行路径判断。</p><p>路径存在则直接返回结果，如果路径不存在，这次就需要 <strong>返回一个错误</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module._resolveFilename = <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(isExists)&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(Module._extensions);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">			<span class="keyword">let</span> newPath = filePath + keys;</span><br><span class="line">			<span class="keyword">if</span> (fs.existsSync(newPath)) <span class="keyword">return</span> newPath;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'module not exists'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以保证我们 <em>传入的路径</em>，无论是加后缀或者不加后缀，都会返回一个 <em>当前路径的绝对路径</em>，且 <em>一定会找到当前文件</em>。</p></li><li><p>我们就已经创建好了一个 <strong>绝对引用路径</strong>，方便我们后续进行读取。</p><p>现在我们就需要根据这个路径，创建一个可以导出的模块。</p><p>这个模块就属于 <code>Module</code> 构造函数，根据我们一开始查看源码时总结的定义，我们知道 模块全部都是通过 <code>Module.exports</code> 方法进行导出的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id; <span class="comment">// 绝对路径</span></span><br><span class="line">    <span class="keyword">this</span>.exports = &#123;&#125;; <span class="comment">// 默认导出的是空对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_require</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    filename = Module._resolveFilename(filename); <span class="comment">// 绝对路径</span></span><br><span class="line">  	<span class="keyword">let</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(filename);</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们路径和导出的架子就有了，现在我们需要对中间部分进行处理。</p></li><li><p>其实所谓的 中间部分，也就是让用户对 <code>Module.exports</code> 赋值<em>（目前导出的是空对象）</em>。</p><p>根据源码的定义，我们需要定义一个 <code>module.load</code> 来对模块进行加载。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module.prototype.load = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> extName = path.extname(<span class="keyword">this</span>.id); <span class="comment">// 获取后缀名</span></span><br><span class="line">    Module._extensions[extName](<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_require</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">module</span>.load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种定义的好处就是，我们可以根据传入的后缀名，调用不同的处理策略。实现文件的 <strong>策略加载</strong>。</p><p>这样我们的 <code>module</code> 就会被传到上面的 <code>Module._extensions</code> 方法中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module._extensions = &#123;</span><br><span class="line">    <span class="string">'.js'</span>(<span class="built_in">module</span>) &#123;&#125;,</span><br><span class="line">    <span class="string">'.json'</span>(<span class="built_in">module</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步我们就需要完善一下 <code>Module._extensions</code> 方法。</p></li><li><p>我们先来完善一下 <code>json</code> 方法，因为这个是最好实现的。</p><p>我们先随便定义一个 <code>.json</code> 文件来进行测试。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.json</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">"name"</span> : <span class="string">"MXShang"</span>,</span><br><span class="line">	<span class="attr">"age"</span> : <span class="number">26</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们来完善一下 <code>Module._extensions[json]</code> 方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module._extensions = &#123;</span><br><span class="line">    <span class="string">'.js'</span>() &#123;&#125;,</span><br><span class="line">    <span class="string">'.json'</span>(<span class="built_in">module</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> content = fs.readFileSync(<span class="built_in">module</span>.id, <span class="string">'utf8'</span>)</span><br><span class="line">        <span class="built_in">module</span>.exports = <span class="built_in">JSON</span>.parse(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取绝对路径，通过 <code>fs.readFileSync</code> 同步读取内容，并输出。</p><p>很好理解也很简单，接下来我们看一下 <code>Module._extensions[js]</code>。</p></li><li><p>在实现 <code>Module._extensions[js]</code> 方法前，我们先需要完成一个函数的外壳 <em>（ wrapper包装 ）</em> ，也就是我们之前文章中经常提到的，包含五个参数的函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module.wrapper = [</span><br><span class="line">    <span class="string">`(function(exports,require,module,__filename,__dirname)&#123;`</span>,</span><br><span class="line">    <span class="string">`&#125;)`</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>然后我们来实现 <code>Module._extensions[js]</code> 方法。</p><p>思路与实现 <code>.json</code> 相似，先将绝对路径的内容读出来，并将内容放到 <em>wrapper</em> 中。。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module._extensions = &#123;</span><br><span class="line">		<span class="string">'.js'</span>(<span class="built_in">module</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> content = fs.readFileSync(<span class="built_in">module</span>.id, <span class="string">'utf8'</span>);</span><br><span class="line">        content = Module.wrapper[<span class="number">0</span>] + content + Module.wrapper[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以得到一个 <em>被wrapper包裹的代码字符串</em>。</p></li><li><p>现在我们来将字符串变成可以执行的函数。使用 <code>vm.runInThisContext</code> 将字符串变成函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module._extensions = &#123;</span><br><span class="line">		<span class="string">'.js'</span>(<span class="built_in">module</span>) &#123;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">      	<span class="keyword">let</span> fn = vm.runInThisContext(content); <span class="comment">// 获取最终执行的函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们需要明确一下 <code>fn</code> 的执行位置，也就是其 <em>this的指向</em>。</p><p>不用多说，this一定是指向 <code>module.exports</code> 的，所以我们需要通过 <code>fn.call</code> 方法来将函数的this指向当前构造函数。</p><p>然后我们再根据最终的函数，依次获取一下需要传递的五个参数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module._extensions = &#123;</span><br><span class="line">		<span class="string">'.js'</span>(<span class="built_in">module</span>) &#123;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">      	<span class="keyword">let</span> exports = <span class="built_in">module</span>.exports; <span class="comment">// 当前this也就是exports参数。this = exports = module.exports</span></span><br><span class="line">        <span class="keyword">let</span> dirname = path.dirname(<span class="built_in">module</span>.id); <span class="comment">// 当前文件执行位置的绝对略经</span></span><br><span class="line">      	fn.call(exports, exports, _require, <span class="built_in">module</span>, <span class="built_in">module</span>.id, dirname); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这一步我们就可以发现，<code>require</code> 方法实际上就是通过 <code>Module</code> 作为一个 <strong>中间层</strong> 来实现的。</p><p>至此，我们的 <code>require</code> 方法的整体思路就实现了。</p><p>但是我们还有一个小问题，就是如果我们多次引入文件，是没有缓存的。所以我们需要 <em>对结果进行缓存</em> 。</p></li><li><p>定义一个 <code>Module._cache</code> 来对结果进行缓存。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个 Module._cache</span></span><br><span class="line">Module._cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在模块加载前，先将定义好的module模块结果进行缓存</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_require</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    Module._cache[filename] = <span class="built_in">module</span>; <span class="comment">// 根据文件名进行缓存</span></span><br><span class="line">    <span class="built_in">module</span>.load();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前模块已经被缓存过 <em>（加载过）</em> ，直接将缓存好的模块导出就可以了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_require</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">  	<span class="keyword">let</span> cacheModule = Module._cache[filename];</span><br><span class="line">    <span class="keyword">if</span> (cacheModule) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheModule.exports; </span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">let</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(filename);</span><br><span class="line">    Module._cache[filename] = <span class="built_in">module</span>; <span class="comment">// 根据文件名进行缓存</span></span><br><span class="line">    <span class="built_in">module</span>.load();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就实现了一套 <code>require</code> 方法。</p></li></ol><p>通过阅读源码，并通过源码手写方法，可以使我们更好的使用方法，也可以提升我们的技术。</p><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>Node</tag>
        <tag>JS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—Node中关于require的补充</title>
    <url>/2021/11/21/Node-%E4%B8%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E5%85%B3%E4%BA%8Erequire%E7%9A%84%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><p>看过上一篇文章，我们对 <code>require</code> 的基本使用和其实现原理已经了解的差不多了。</p><p>通过对源码的学习，我们也会产生以下几个问题。</p><h2 id="关于require的几个问题"><a href="#关于require的几个问题" class="headerlink" title="关于require的几个问题"></a>关于require的几个问题</h2><p>首先，我们还是定义两个文件，一个导出一个引入。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 require 引入文件</span></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">"hello"</span>;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>在上一篇源码分析的文章中，我们提到过这么一个点。</p><p><code>this = module.exports = exports</code> <em>（具体可以参考我上一篇文章 <a href="https://mxshang.github.io/2021/11/20/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%ADrequire%E7%9A%84%E5%AE%9E%E7%8E%B0/">require的实现</a>）</em></p><p>那如果我们在这里输出 <code>module.exports === exports</code> ，结果又会如何呢？</p><h3 id="module-exports、exports和this的关系"><a href="#module-exports、exports和this的关系" class="headerlink" title="module.exports、exports和this的关系"></a>module.exports、exports和this的关系</h3><p>首先，我们先看一下上面那个问题的结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.exports === exports); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.exports === <span class="keyword">this</span> , exports === <span class="keyword">this</span>); <span class="comment">// true true</span></span><br></pre></td></tr></table></figure><p>输出的结果是 <code>true</code>，我们还可以发现这三个值互换结果都是相等的。就是因为 <code>this = module.exports = exports</code> 。</p><p>既然他们三个是相等的，那么我是不是就可以直接 用 <code>exports = &quot;hello&quot;</code> 来输出结果了呢？</p><p>答案是<strong>不行</strong>。原因也很简单，因为我们在定义的时候是采用 <code>let exports = module.exports = {}</code> 的这种定义方式进行定义，文件在引用时，返回的是 <code>module.exports</code> 的值。 我们给 <code>exports</code> 赋值为 <em>hello</em> ，但 <code>module.exports</code> 依旧是空的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大概意思，具体实现可参考源码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> exports = <span class="built_in">module</span>.exports = &#123;&#125;;</span><br><span class="line">  exports = <span class="string">"hello"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们既然知道了这种赋值方式不行是因为<strong>值引用</strong>的问题，那么我们很快就可以想到。 是否可以利用堆栈内存的特性，给他们绑定一个属性呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line">exports.a = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">this</span>.a = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">module</span>.exports.a = <span class="string">"hello"</span>;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a.a); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>我们发现，这三种形式都可以进行值的传递和引用。其含义就是 <em>定义其堆内存中地址的值</em>， 且修改堆的值的指向。</p><p>假设我们同时定义 <code>module.exports</code> 和 属性，那么结果会获取 <code>module.exports</code> 的值，不会获取属性。</p><p><em>（注：不能直接修改 <code>this</code> 的值，可能会发生一些错误）</em></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports.a = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">"world"</span>;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// world</span></span><br></pre></td></tr></table></figure><p>因为 <code>module.exports</code> 的<strong>优先级是最高的</strong>，因为最终还是将 <code>module.exports</code>导出。<em>（所以 <code>require</code> 方法不支持多种写法同时导出）</em></p><h3 id="module-exports的简化"><a href="#module-exports的简化" class="headerlink" title="module.exports的简化"></a>module.exports的简化</h3><p>看过上面的定义，我们可以简单整理一下 <code>module.exports</code> 的简化写法。</p><h4 id="exports简化"><a href="#exports简化" class="headerlink" title="exports简化"></a>exports简化</h4><p>我们现在需要将模块内的多个值导出。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports.a = <span class="string">"a"</span>;</span><br><span class="line"><span class="built_in">module</span>.exports.b = <span class="string">"b"</span>;</span><br><span class="line"><span class="built_in">module</span>.exports.c = <span class="string">"c"</span>;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(); <span class="comment">// &#123; a: 'a', b: 'b', c: 'c' &#125;</span></span><br></pre></td></tr></table></figure><p>这样写会很麻烦，所以我们可以使用 <code>exports</code> 来进行简化</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line">exports.a = <span class="string">"a"</span>;</span><br><span class="line">exports.b = <span class="string">"b"</span>;</span><br><span class="line">exports.c = <span class="string">"c"</span>;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="comment">// ...  &#123; a: 'a', b: 'b', c: 'c' &#125;</span></span><br></pre></td></tr></table></figure><p>就是对代码进行简化。</p><h4 id="module-exports简化"><a href="#module-exports简化" class="headerlink" title="module.exports简化"></a>module.exports简化</h4><p>现在有多个方法需要导出，我们就可以用下面的方式简写。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  fn1()&#123;&#125;,</span><br><span class="line">  fn2()&#123;&#125;,</span><br><span class="line"> 	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种就是 <code>module.exports</code> 结合 ES6 的一种简写方式。</p><p>至此，我们的 <em>Node的文件模块</em> 和 <em><a href="https://mxshang.github.io/2021/11/16/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/">Node的核心模块</a></em> 就总结完毕了。</p><p>下一篇文章我会总结一下 <em>Node中第三方模块</em>。</p><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>Node</tag>
        <tag>JS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—Node中的模块调试</title>
    <url>/2021/11/19/Node-%E4%B8%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL3poLWNuL2RvY3MvZ3VpZGVzL2RlYnVnZ2luZy1nZXR0aW5nLXN0YXJ0ZWQv">调试-入门指南 | Node.js 官网<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>当我们在写代码时（尤其是手写插件源码），总会出现一些不可预料的问题。所以我们这个时候就需要去对代码进行调试。</p><p>在上一篇文章中，我们希望去实现 <code>require</code>，这个时候我们就需要通过调试功能，去理解一下 <code>require</code> 内部的运行机制到底是什么样的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 require 引入文件</span></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = a;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure><p>下面我将会列举几种调试方式，并且使用其中一种来完成上一篇文章中遗留的问题。</p><h3 id="vscode调试"><a href="#vscode调试" class="headerlink" title="vscode调试"></a>vscode调试</h3><p>我们在使用 <em>Visual Studio Code</em> 编译器时，可以在右侧发现一个类似于瓢虫的标志。</p><p>点开后，我们可以创建一个 <code>launch.json</code> 的配置文件。</p><p><img data-src="pic5.png" alt="创建launch.json文件"></p><p>随后我们创建一个用来调试 <em>node.js</em> 的文件。</p><p>而我们就会得到下图中的配置文件，现在我们需要删除红框中的内容。</p><p><img data-src="pic6.png" alt="launch.json配置文件"></p><p>在文件 <em>b.js</em> 里面打一个断点，这样我们就可以进行调试了。</p><p><img data-src="pic7.png" alt="文件断点与调试"></p><p>点击 <em>单步调试</em> ，我们就可以看到源码了。</p><p><img data-src="pic8.png" alt="require源码"></p><p>这样我们就大概了解如何使用 <em>vscode</em> 进行代码调试了，后续我们可以通过这种方式加强我们对源码的学习。</p><h3 id="chrome调试"><a href="#chrome调试" class="headerlink" title="chrome调试"></a>chrome调试</h3><p>说起调试，我们就不得不说一下 浏览器调试。这里我们以 chrome谷歌浏览器为例。</p><p>首先，我们需要进行命令行配置。 输入 <code>node --inspect-brk</code>，在后面再加上我们需要调试的文件。</p><p>随后我们打开 chrome浏览器，输入链接 <code>chrome://inspect/#devices</code> ，这样就会进入浏览器的开发者工具界面。</p><p>我们就可以在页面中看到以下内容。<em>（此过程需要等待几秒到几分钟）</em></p><p><img data-src="pic9.png" alt="chrome开发者工具"></p><p>随后我们可以看见我们调试的文件。</p><p><img data-src="pic10.png" alt="调试工具"></p><p>操作使用上和vscode调试是相似的。</p><p>在下一篇文章中，我会使用这种调试方法去分析一下require的源码。</p><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>Node</tag>
        <tag>JS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—Node的VM模块详解</title>
    <url>/2021/11/17/Node-%E4%B8%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%ADVM%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvdm0uaHRtbA==">vm 虚拟机 | Node 官网<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>在上一篇文章中，我们提到了一个问题。</p><p><em>字符串如何能变成 JS 执行呢？</em></p><p>我们详细介绍了两种方法，分别是 <a href="https://mxshang.github.io/2021/11/16/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/">eval函数</a> 和 <a href="https://mxshang.github.io/2021/11/16/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/">new Function</a> 。</p><p>在这里我们需要再强调一下， 由 <code>Function</code> 构造器创建的函数不会创建当前环境的闭包，它们总是被创建于全局环境，因此在运行时它们只能访问全局变量和自己的局部变量，不能访问它们被 <code>Function</code> 构造器创建时所在的作用域的变量。这一点与使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval" target="_blank" rel="noopener"><code>eval</code></a> 执行创建函数的代码不同。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">global.a = <span class="number">100</span>; <span class="comment">// 挂在到全局对象global上</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">200</span>; <span class="comment">// this !== global</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"console.log(a)"</span>)() <span class="comment">// 100</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"console.log(b)"</span>)() <span class="comment">// b is not defined</span></span><br></pre></td></tr></table></figure><p><code>Function</code> 可以获取全局变量，所以他还是可能会有变量污染的情况出现。<code>Function</code> 是 <em>模块引擎的实现原理</em> ，后续我会出一篇文章进行单独讲解。</p><p>还有一种解决方案，我们在上一次文章中没有进行详细的展开，那就是 <strong><code>vm</code>模块</strong> 。</p><h2 id="vm模块"><a href="#vm模块" class="headerlink" title="vm模块"></a>vm模块</h2><p>在上述文字中，我一直在强调一个概念，那就是 <strong>变量的污染</strong>。</p><p>VM的特点就是不受环境的影响，也可以说他就是一个 <strong>沙箱环境</strong> <em>（沙箱模式给模块提供一个环境运行而不影响其它模块和它们私有的沙箱）</em>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="built_in">require</span>(<span class="string">'vm'</span>)</span><br><span class="line">global.a = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 运行在当前环境中[当前作用域]</span></span><br><span class="line">vm.runInThisContext(<span class="string">'console.log(a)'</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="comment">// 运行在新的环境中[其他作用域]</span></span><br><span class="line">vm.runInNewContext(<span class="string">'console.log(a)'</span>); <span class="comment">// a is not defined</span></span><br></pre></td></tr></table></figure><p>在这里我们要强调一下，因为 <strong>在Node中全局变量是在多个模块下共享的，所以尽量不要在global中定义属性。</strong> Demo中的定义是为了方便理解。</p><p>假设我们在同级目录下有一个文件 <em>1.js</em> ，里面定义了 <code>global.a = 100;</code>。 现在我们引入这个文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">requrie(./<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><p>我们可以发现，在当前文件中我们并没有定义变量a，仅仅只是把两个模块文件关联在了一起。这就是我上面提到的，<strong>Node中全局变量是在多个模块下共享的。</strong></p><p>他的原理是因为在 <em>Node</em> 的环境中，全局中有一个执行上下文。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟一下Node的全局环境</span></span><br><span class="line"><span class="comment">// vm.runInThisContext在当前全局环境执行，但不会产生新函数</span></span><br><span class="line">- <span class="function"><span class="keyword">function</span>(<span class="params">exports, module, require, __dirname, __filename</span>)</span>&#123; <span class="comment">// ... &#125;</span></span><br><span class="line">- vm.runInThisContext ...</span><br><span class="line"><span class="comment">// vm.runInNewContext在全局环境之外执行</span></span><br><span class="line">vm.runInNewContext ...</span><br></pre></td></tr></table></figure><p>所以，<code>vm.runInThisContext</code> 可以访问到 <code>global</code>上的全局变量，但是访问不到自定义的变量。而 <code>vm.runInNewContext</code> 访问不到 <code>global</code>，也访问不到自定义变量，他存在于一个全新的执行上下文。</p><p>而我们<code>require</code> 就是通过 <code>vm.runInThisContext</code> 实现的。</p><p>实现<code>require</code> 主要可以分为以下四步。</p><ol><li>读取需要引入的文件。</li><li>读取到文件后，将代码封装成一个函数。</li><li>通过 <code>vm.runInThisContext</code> 将他转变成 JS 语法。</li><li>代码调用。</li></ol><p>假设我们现在有以下两个文件。分别是 <em>a.js</em> 和 <em>b.js</em></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件a通过module.exports导出一个变量，在文件b中使用require进行接收。</span></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">"a"</span></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// a</span></span><br></pre></td></tr></table></figure><p>我们可以通过上面的四个步骤，分析一下导入导出的实现逻辑是什么样的。</p><ol><li><p><em>读取文件。</em></p><p>将需要引入的文件内容引入到需要接收的文件里，就会变成这个样子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">module</span>.exports = <span class="string">"a"</span>;</span><br></pre></td></tr></table></figure><p>但是这种形式，Node根本解析不了，所以我们就需要进行第二步。</p></li><li><p><em>将读取的文件封装成函数。</em></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = (<span class="function"><span class="keyword">function</span>(<span class="params">exports, module, require, __dirname, __filename</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="string">"a"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports</span><br><span class="line">&#125;)(...args) <span class="comment">// exports, module, require, __dirname, __filename 将五个参数传入</span></span><br></pre></td></tr></table></figure><p>封装成函数的原因，我们可以参考下面这个例子。</p><p>假设我们现在传入的不是字符串，而是一个函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这样我们在解析的时候，就会被解析成下面这种格式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = (<span class="function"><span class="keyword">function</span>(<span class="params">exports, module, require, __dirname, __filename</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports</span><br><span class="line">&#125;)(...args) <span class="comment">// exports, module, require, __dirname, __filename 将五个参数传入</span></span><br></pre></td></tr></table></figure><p>我们导出的是 <code>module.exports</code>，所以在模块文件中定义的变量a，也只属于当前这个执行上下文。</p><p>在解析的时候，变量a 会被放到函数中。真正的实现了 <strong>作用域分离</strong>。</p></li><li><p><em><code>vm.runInThisContext</code> 解析成可执行的Js代码</em></p><p>我们处理过的代码会以字符串的形式存在，所以我们需要通过<code>vm.runInThisContext</code>将字符串进行解析。</p></li><li><p><em>进行代码调用</em></p><p>在此之前，我们其实还需要对代码进行调试。</p></li></ol><p>下一篇文章我会详细讲解一下 <strong>Node中的模块调试</strong>。</p><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>Node</tag>
        <tag>JS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—Node的核心模块</title>
    <url>/2021/11/16/Node-%E4%B8%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="动态模块与静态模块"><a href="#动态模块与静态模块" class="headerlink" title="动态模块与静态模块"></a>动态模块与静态模块</h2><blockquote><p>关于之前文章中 <a href="https://mxshang.github.io/2021/11/15/Node/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/">动态静态</a> 的含义。</p></blockquote><p>首先，es6Module属于<em>“静态模块”</em>，commonjs属于<em>“动态模块”</em>。</p><p><em>静态模块</em> 是可以在编译的时候进行引入分析的，他可以进行 <em><code>tree-shaking</code>（webpack打包时自动去掉不用的代码）*。而 *动态模块</em> 是在代码执行的时候引入模块的，他不可以进行 <em><code>tree-shaking</code></em>。</p><blockquote><p>关于 <code>tree-shaking</code> ，可以参考 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9UcmVlX3NoYWtpbmc=">Tree Shaking | MDN<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>文件用webpack打包之后，文件就会从 <em>es6Module规范 转换成 commonjs规范</em>。</p><h2 id="模块的规范与分类"><a href="#模块的规范与分类" class="headerlink" title="模块的规范与分类"></a>模块的规范与分类</h2><p>首先，我们先回顾一下 <strong>commonjs模块规范</strong>：</p><ul><li>每个js <em>文件都是一个模块</em>。（每个模块外面都有一个函数）</li><li>模块的导出 <code>module.exports</code></li><li>模块的导入 <code>require</code></li></ul><p>而模块中也有自己的分类，下面我们介绍一下 <strong>模块分类</strong>：</p><ol><li><strong>核心模块</strong> 也叫内置模块，包括<code>fs</code>、<code>http</code>、<code>path</code>、<code>vm</code> 等等。在使用时 <em>不需要进行安装*，直接引入即可。引入的时候也 *不需要添加绝对路径或相对路径</em> 。</li><li><strong>第三方模块</strong> 也就是别人定义的模块，像 <code>co</code> 等等。此类模块在使用的时候 <em>需要进行安装</em>。</li><li><strong>自定义模块</strong> 是用户自己封装或定义的模块，在使用的时候需要 <em>通过绝对路径或者相对路径进行引入</em>。</li></ol><h2 id="常用的核心模块"><a href="#常用的核心模块" class="headerlink" title="常用的核心模块"></a>常用的核心模块</h2><h3 id="fs模块"><a href="#fs模块" class="headerlink" title="fs模块"></a>fs模块</h3><ol><li><p><strong>fs.readFileSync</strong></p><p>我们先举个 <strong>核心模块</strong> 的例子。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="comment">// require内部使用的就是readFileSync来实现的</span></span><br><span class="line"><span class="keyword">let</span> r = fs.readFileSync(<span class="string">'./test.js'</span>,<span class="string">'utf8'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(r);</span><br></pre></td></tr></table></figure><p>首先，<code>require</code> 是<strong>同步方法</strong>。假设<code>require</code> 是异步的话，那么每引入一个模块，我们都需要在其成功的回调中写我们下一步需要执行的代码，这样就会造成代码的冗余和堆积。</p><p>所以 <code>require</code> 的内部就是使用 <em>readFileSync</em> 来实现的。</p></li><li><p><strong>fs.existsSync</strong></p><p>我们在读取文件时，如果读取的文件不存在，那么就会发生异常。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> r = fs.readFileSync(<span class="string">'./testxxx.js'</span>,<span class="string">'utf8'</span>); <span class="comment">// 假设此文件不存在</span></span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>这时我们可以使用 <code>existsSync</code> 来对文件进行判断。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> f = fs.existsSync(<span class="string">'./testxxx.txt'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(f); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>此方法目前只有 同步方法，<del>异步方法已经被废弃了</del>。</p></li></ol><h3 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a>path模块</h3><ol><li><p><strong>path.resolve</strong></p><p><code>path</code>模块是专门用来处理路径的。</p><p><code>path.resolve</code> 方法会把一个路径或路径片段的序列解析为一个绝对路径。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(path.resolve(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>));</span><br><span class="line"><span class="comment">// d:\xxx\xxx\xxx\a\b\c</span></span><br></pre></td></tr></table></figure><p>他会将当前绝对路径为前缀，将传入的参数以 <code>\</code> 分割，并解析成新的绝对路径。</p><p>但是这样会出现一个问题，假设我们现在切换一下执行目录，那么路径就会发生错误。原因是因为<code>path.resolve</code> 默认采用的解析方式是 <code>process.cwd()</code> 。</p><p>为了使路径正确，我们可以采用以下解决方案。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(path.resolve(__dirname ,<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'/'</span>)); <span class="comment">// 路径回到了根目录下</span></span><br></pre></td></tr></table></figure><p><em>（注：如果路径中存在 <code>/</code>，当前路径会回到跟目录下 ）</em></p></li><li><p><strong>path.join</strong></p><p><code>path.join</code> 是将传入的参数进行路径拼接，不会添加任何路径。</p><p>参数中如果存在 <code>/</code>，也会被拼接在一起。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(path.join(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'/'</span>));</span><br><span class="line"><span class="comment">// a\b\c\</span></span><br></pre></td></tr></table></figure><p>所以我们可以使用这种方法进行绝对路径的拼接。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(path.join(__dirname ,<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'/'</span>)); <span class="comment">// 路径被拼接在一起</span></span><br></pre></td></tr></table></figure><p>*<em>在某些情况下，<code>path.join</code>和 <code>path.resolve</code> 是可以互换使用的。但是在路径中出现 <code>/</code> 的情况下，还是使用 <code>path.join</code>更好。 *</em></p></li><li><p><strong>path.extname</strong></p><p><code>path.extname</code> 会获取文件扩展名，也可以说就是文件的类型。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(path.extname(<span class="string">'text.min.js'</span>)); <span class="comment">// .js</span></span><br></pre></td></tr></table></figure></li><li><p><strong>path.basename</strong></p><p><code>path.basename</code> 方法返回 <code>path</code> 的最后一部分。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(path.basename(<span class="string">'d:/xxx/xxx/xxx/test.js'</span>,<span class="string">'.js'</span>));  <span class="comment">// test</span></span><br></pre></td></tr></table></figure><p>若不传最后一个参数，则会直接返回最后的文件名 <code>test.js</code></p></li><li><p><strong>path.relative</strong></p><p><code>path.basename</code> 方法会根据当前路径，<em>获取相对路径</em>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(path.basename(<span class="string">'a/b/c/test.js'</span>,<span class="string">'a'</span>));  <span class="comment">// ..\..\..</span></span><br></pre></td></tr></table></figure></li><li><p><strong>path.dirname</strong></p><p><code>path.dirname</code> 方法会获取当前文件的父路径。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(path.dirname(<span class="string">'a/b/c'</span>));  <span class="comment">// a/b</span></span><br></pre></td></tr></table></figure><p><em>__dirname的实现就是用的<code>path.dirname</code>。</em></p></li></ol><h3 id="vm模块"><a href="#vm模块" class="headerlink" title="vm模块"></a>vm模块</h3><p>在说这个模块之前，我们可以先思考一个问题。</p><p><em>字符串如何能变成JS执行呢？</em></p><ol><li><p><strong>eval函数</strong></p><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2wuY29tLmNuL2pzcmVmL2pzcmVmX2V2YWwuYXNw">eval()函数<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>我们第一个想到的就是 <code>eval()</code> 函数，他可以将传入的字符串或表达式转换成可以执行的JS代码，且 <code>eval()</code> 函数会受当前执行环境影响。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">'console.log(a)'</span>); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure></li><li><p><strong>new Function</strong></p><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24=">Function | MDN<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><code>new Function</code> 会将传入的字符串作为 <em>函数<em>，将传入的前几个参数作为 *函数的参数</em>。且 *在Node环境中</em> 他不会受外界的影响，因为 <code>new Function</code> 与 <em>最外级作用域是平级</em> 的，在浏览器中不受影响。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'b'</span>,<span class="string">'console.log(a)'</span>)(); <span class="comment">// a is not defined</span></span><br></pre></td></tr></table></figure></li><li><p><strong>vm模块</strong></p><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvdm0uaHRtbA==">vm 虚拟机 | Node官网<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><code>vm</code> 模块允许在 V8 虚拟机上下文中编译和运行代码。</p><p><em>（关于<code>vm</code>模块的使用和原理，我会在后续文章中详细讲解）</em></p></li></ol><hr><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>Node</tag>
        <tag>JS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—EventLoop事件循环</title>
    <url>/2021/10/30/Promise/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94EventLoop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p><code>EventLoop</code>即事件循环，是指浏览器或 <code>Node</code> 的一种解决 <code>JavaScript</code> 单线程运行时不会阻塞的一种机制，也就是我们经常使用<strong>异步</strong>的原理。</p><p>JavaScript是单线程语言。在当前页面进程中，<em>JS是主线程</em>，而我们常说的异步操作，属于<em>异步线程</em>。</p><p>在这里我们就要先清楚两个名词，<strong>进程</strong> 和 <strong>线程</strong>。</p><ul><li><strong>进程</strong>：是计算机分配任务的最小单位。计算机分配任务时，会按照 <em>进程</em> 进行任务分配。</li><li><strong>线程</strong>：一个进程中包含多个线程。</li></ul><p>对于前端来说，我们接触最多的浏览器，就是由多个进程组成的。</p><h3 id="浏览器进程"><a href="#浏览器进程" class="headerlink" title="浏览器进程"></a>浏览器进程</h3><p>关于浏览器的进程，包含以下几点</p><ul><li><p><strong>每个标签页是一个进程</strong>，他们互不影响。<em>假设我们当前某个页面出现问题卡住了（如死循环等），其他页面不会被当前页面影响。</em></p></li><li><p>每个<strong>浏览器有一个主进程</strong>，也就是我们的用户界面。</p></li><li><p><strong>渲染进程</strong>，每个标签页里，都有一个渲染进程，而 <em>渲染进程中又包含多个进程</em>。</p></li><li><p><strong>网络进程</strong>，发送网络请求以及处理网络请求等。</p></li><li><p><strong>GPU进程</strong> 与 <strong>3D绘制进程</strong>，用来提高页面的加载速度，以及加载复杂的页面特效。</p></li><li><p><strong>第三方插件</strong> 等等…</p></li></ul><h3 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h3><p>渲染进程中包括多个线程</p><ul><li><strong>GUI渲染线程</strong> ，用来对页面进行渲染，也可以叫做 <em>UI渲染线程</em> 。</li><li><strong>JS引擎线程</strong> ，用来加载页面中的JS语法，<em>他和 GUI渲染线程 互斥，也就是说他们两个只能同时加载一个线程</em>。</li><li><strong>事件循环线程</strong> ，也就是 <strong><em>EventLoop</em></strong>。他也是一个独立的线程。<em>JS执行时可能会调用异步方法，而这些方法就是 <strong>EventLoop</strong> 调度执行的。</em></li><li><code>click</code>、<code>setTimeout</code>、<code>ajax</code> 等也是一个独立线程。</li></ul><blockquote><p>搞懂 <strong>EventLoop</strong> ，需要先明白 <strong>堆栈队列</strong> 等概念，后续有时间的话我会更新一篇文章专门对此概念进行详述，感谢大家的关注。</p></blockquote><h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><ul><li><strong>宏任务</strong>：<code>script</code>、<code>ajax请求</code>、<code>ui 渲染</code>、<code>setTimeout</code>、<code>setInterval</code>、<code>postMessage</code>、<code>MessageChannel</code>、<code>SetImmediate</code>、<code>event事件</code></li><li><strong>微任务</strong>：<code>promise</code>、<code>mutationObserver</code>、<code>process.nextTick</code></li></ul><p><img data-src="pic5.png" alt></p><p>JS在执行时，会 <em>自上向下执行</em>，也就是一个 <strong>执行栈</strong>，其中包括 <strong>同步代码 *<em>和 *</em>异步代码</strong>。</p><p>遇到同步代码时，如果是函数会创建一个 <strong>执行上下文</strong>，并放入执行栈中，<em>执行完毕后再出栈</em>。</p><p>遇到异步代码时，我们需要将异步任务放入到一个 <strong>事件队列（或消息队列）</strong>[ <em>队列的特点是先进先出</em> ] 中（内部会调用浏览器提供的Api来将任务放入队列）。</p><p>当我们执行上下文 <em>全部执行完毕</em> 后。<strong>事件队列</strong> 会不停的 <em>对队列进行扫描*，并将队列里 *符合规则（执行完毕或到达时间）</em> 的任务放到执行上下文中并执行。而进行扫描的队列就是 <strong>事件循环线程</strong>，他会对 <em>执行栈</em> 进行<em>循环检测</em> ，当 <em>执行栈为空</em> 的情况下，才会将 <em>符合规则的一个任务放到执行上下文中并执行（注：每次只放入一个）</em>。</p><p>上述的这些异步任务，我们还可以称其为 <strong>宏任务</strong> 。其中包括一些特殊的异步任务，我们可以称为 <strong>微任务</strong>。</p><p>每一次循环检测的时候，都会创建一个 <strong>宏任务队列</strong>（可能会有异步任务，也可能会没有）。而每一个宏任务队列中，都包含一个<strong>微任务队列</strong>。这个微任务队列会在每一次循环检测时，将结果进行清空。</p><p>换言之就是，<strong>每次循环检测会创建一个宏任务队列，这个队列中包含一个微任务队列。宏任务队列清空并输出结果之前，会先对微任务队列进行任务扫描，并清空。然后才会扫描符合规则的宏任务，并将任务放到执行栈中。</strong></p><p>如果存在<strong>UI渲染</strong>等情况，则会在<strong>每次循环的微任务队列清空完毕</strong>后，对页面<strong>进行渲染</strong>。</p><h3 id="代码题"><a href="#代码题" class="headerlink" title="代码题"></a>代码题</h3><p>通过以下几道代码题可以更好的帮我们理解上述概念。</p><ol><li><p><strong>微任务和UI渲染</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.style.background = <span class="string">'red'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">	<span class="built_in">document</span>.body.style.background = <span class="string">'yellow'</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>结果是 <code>1、3、2、yellow</code>，且屏幕不会出现闪烁的情况。</p><p>因为页面的ui渲染会在每次微任务队列清空之后执行，所以不会出现闪烁的情况。</p><p>要验证此结论，可以通过添加一个宏任务事件来进行测试。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.style.background = <span class="string">'red'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">	<span class="built_in">document</span>.body.style.background = <span class="string">'yellow'</span>;</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">document</span>.body.style.background = <span class="string">'green'</span>;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>在多次刷新页面后，可以看到有一个小小的闪烁的情况。</p><p>通过这个测试，我们也可以得到一个更严谨的言论。<strong>UI渲染（GUI渲染）会在达到渲染时机时，才会出现闪烁的情况。</strong></p></li><li><p><strong>事件任务</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">button.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'listener1'</span>);</span><br><span class="line">	<span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'micro task1'</span>))</span><br><span class="line">&#125;)</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'listener2'</span>);</span><br><span class="line">	<span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'micro task2'</span>))</span><br><span class="line">&#125;)</span><br><span class="line">button.click(); <span class="comment">// click1() click2()</span></span><br></pre></td></tr></table></figure><p>结果是 <code>listener1、listener2、micro task1、micro task2</code>。</p><p>首先我们先明确一个概念，那就是 <code>button.click()</code> 相当于将两个事件当成普通函数来执行，也就等价于以下代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'listener1'</span>);</span><br><span class="line">	<span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'micro task1'</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'listener2'</span>);</span><br><span class="line">	<span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'micro task2'</span>))</span><br><span class="line">&#125;</span><br><span class="line">fn1(); fn2()</span><br></pre></td></tr></table></figure><p>所以就可以理解成，先执行 执行上下文 中的函数，再执行事件循环队列中的异步事件。</p><p>但是如果我们不使用<code>button.click()</code>，而是直接使用点击事件呢？</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">button.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(<span class="string">'listener1'</span>);</span></span><br><span class="line"><span class="javascript">	<span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'micro task1'</span>))</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="actionscript">button.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(<span class="string">'listener2'</span>);</span></span><br><span class="line"><span class="javascript">	<span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'micro task2'</span>))</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果是 <code>listener1、micro task1、listener2、micro task2</code> 。</p><p>上述代码中的点击事件属于<strong>宏任务</strong>，所以我们相当于向<strong>宏任务队列</strong>中添加了两个宏任务，根据宏任务队列的执行原则，会先<strong>清空微任务队列</strong>。所以会输出上面的结果。</p></li><li><p><strong>定时器任务</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)</span><br><span class="line">	setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)</span><br><span class="line">	&#125;, <span class="number">0</span>);</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>);</span><br><span class="line">	<span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'Promise2'</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>结果是 <code>Promise1、setTimeout1、Promise2、setTimeout2</code>。</p><p>上述代码在执行时，会先执行最外层的 script脚本（宏任务），会先将外层的<em>微任务Promise1放入微任务队列<em>，</em>宏任务setTimeout1放入宏任务队列*。在 *执行script宏任务</em> 时，会 <em>清空微任务队列</em>，也就是会先将 <strong><em>Promise1</em>输出</strong> 。然后将里面的 <em>宏任务setTimeout2再次放入宏任务队列</em>。这时根据宏任务队列顺序，需要 <em>执行宏任务setTimeout1</em>，将 <strong><em>setTimeout1</em>输出</strong>，然后再将<em>微任务Promise2放入微任务队列</em>。这时 <em>执行宏任务setTimeout2</em>，先 清空微任务队列，<strong>输出Promise2</strong>，随后再将 <strong>setTimeout2输出</strong>。</p></li><li><p><strong>常见面试题</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">    resolve(<span class="number">7</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">async</span> (); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>结果是 <code>1、6、2、3、8、7、4、5</code>。</p><p>思路依旧是根据事件循环线程的输出思路，将宏任务放入宏任务队列，微任务放入微任务队列。宏任务队列执行时，会先清空并输出现有微任务队列中的结果，然后再将宏任务中的结果输出。所以最终结果就是上述结果。</p></li></ol><hr><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>Promise</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—Promise之高阶函数与设计模式</title>
    <url>/2021/07/12/Promise/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Promise%E4%B9%8B%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue 全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p><strong>高阶函数的特点</strong></p><ul><li>一个函数的参数是一个函数（回调函数就是一种高阶函数）</li><li>一个函数返回一个函数</li></ul><p>我们平时会用到的 <code>reduce</code> 、 <code>map</code> 等方法就是高阶函数。</p><h3 id="before-方法"><a href="#before-方法" class="headerlink" title="before 方法"></a>before 方法</h3><p>假设我们现在有这样一个场景，我们写了一个业务代码，而现在我们需要扩展当前的业务代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// todo something...</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"say"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要在业务代码之前对其进行相应的处理，但是我们如果对业务代码的封装方法进行处理，会使整个代码变得很难处理和复用。</p><p>所以我们需要在 <code>Function.prototype</code> 原型链上绑定一个 <em>before 方法</em> ，使业务代码调用前，先调用一下这个方法。实现对扩展代码进行统一的管理。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    callback();</span><br><span class="line">    <span class="keyword">this</span>(); <span class="comment">// 箭头函数会查找其上级作用域的this指向</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>（注：我们这里的回调函数需要使用箭头函数，原因是箭头函数不存在 this 指向，他会查找上级作用域的 <a href="https://mxshang.github.io/2021/05/28/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BES6-2/">this 指向</a>）</em></p><p>这样我们在使用业务代码前，就可以直接调用其 <strong>回调函数</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> beforeSay = say.before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"before say"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">beforeSay(); <span class="comment">// before say  say</span></span><br></pre></td></tr></table></figure><p>这里符合高阶函数的两个特点，所以其也是一种 <strong>高阶函数</strong>。</p><p>最终达到了我们想要的效果，业务代码 与 扩展代码 实现了分离。</p><p>同时，我们也可以进行传参。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// todo something...</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"say"</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 箭头函数不存在arguments属性，所以我们使用剩余运算符来进行参数传递</span></span><br><span class="line">    callback();</span><br><span class="line">    <span class="keyword">this</span>(...args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> beforeSay = say.before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"before say"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">beforeSay(<span class="string">"hello"</span>, <span class="string">"world"</span>); <span class="comment">// before say  say</span></span><br></pre></td></tr></table></figure><h3 id="after-方法"><a href="#after-方法" class="headerlink" title="after 方法"></a>after 方法</h3><p>假设现在有这样一串代码，我们需要根据传递的参数来判断何时执行函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newFn = after(<span class="number">3</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"after"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">newFn(); <span class="comment">// ...</span></span><br><span class="line">newFn(); <span class="comment">// ...</span></span><br><span class="line">newFn(); <span class="comment">// after</span></span><br></pre></td></tr></table></figure><p>上面我们传入了一个 <em>3</em>，并传入了一个自定义函数。在第三次时，执行了我们的自定义函数。</p><p>接下来我们来完成 <code>after</code> 函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">after</span>(<span class="params">times, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义内容</span></span><br><span class="line">    <span class="keyword">if</span> (--times === <span class="number">0</span>) &#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是利用 <em>闭包</em> 的思想，完成了函数的封装。</p><p>上述代码同样符合 高阶函数 的特点，所以这也是一种<strong>高阶函数</strong>。</p><h3 id="函数柯理化"><a href="#函数柯理化" class="headerlink" title="函数柯理化"></a>函数柯理化</h3><p>首先，我们可以先看一个这样的需求案例。</p><p>假设我们现在需要对几个数进行求和运算，可能平时我们会直接用下面这个函数进行封装。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c + d + e;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>如果我们对传递的参数进行分别传递呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>这个时候，我们就无法再用上面的函数进行运算了。</p><p>我们需要用到一个全新的高阶函数，<strong>函数柯理化</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> curring = <span class="function">(<span class="params">fn, arr = []</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = fn.length;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> concatVal = [...arr, ...args];</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; len) &#123;</span><br><span class="line">      <span class="keyword">return</span> curring(fn, arr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn(...concatVal);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(curring(sum)(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>, <span class="number">5</span>)); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>整体思路其实就是将后续传入的所有参数，拼接成一组完整的参数，最终实现 <strong>函数柯理化</strong>。</p><h3 id="异步并发问题"><a href="#异步并发问题" class="headerlink" title="异步并发问题"></a>异步并发问题</h3><p>假设现在有多个异步并发请求，我们该如何同时获得最终结果呢？</p><p>这里我们会用到 <code>Node</code> 中的 <code>fs</code> 模块。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>); <span class="comment">// file System</span></span><br></pre></td></tr></table></figure><p>这是一个用来 <em>操作文件</em> 的模块。</p><p>随后我们可以在其子目录下创建两个 .txt 文件，随便往里面写一些内容用来测试。</p><p><img data-src="pic1.png" alt></p><p>然后我们来使用 <code>readFile</code> 直接操作文件。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">"./name.txt"</span>, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// zhangsan</span></span><br><span class="line">&#125;);</span><br><span class="line">fs.readFile(<span class="string">"./test.txt"</span>, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// test</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样我们就模拟了两个异步操作。</p><p>现在我们想将这两个结果直接放到一个变量中。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> allVal = &#123;&#125;;</span><br><span class="line">fs.readFile(<span class="string">"./name.txt"</span>, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  allVal.name = data;</span><br><span class="line">&#125;);</span><br><span class="line">fs.readFile(<span class="string">"./test.txt"</span>, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  allVal.test = data;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(allVal); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以看到输出结果是空的，原因是这两个读取操作是异步的。</p><p>那么我们该如何获取这个结果呢？</p><p>我们有如下几个解决方法</p><ol><li>模拟一个 <em>cb</em> 方法并创建一个计数变量 <em>index_，每次执行完一个异步方法后，都在 _index</em> 上加 1。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> cb = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (++index === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(allVal);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">fs.readFile(<span class="string">"./name.txt"</span>, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  allVal.name = data;</span><br><span class="line">  cb();</span><br><span class="line">&#125;);</span><br><span class="line">fs.readFile(<span class="string">"./test.txt"</span>, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  allVal.test = data;</span><br><span class="line">  cb();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样写会有一个问题，就是当我们需要调用的异步方法过多时，会十分难以操作，同时我们还需要创建一个额外的全局变量。</p><ol start="2"><li><p>利用上面的 <em>after 方法</em> 的思路</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">after</span>(<span class="params">times, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (--times === <span class="number">0</span>) &#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cb = after(<span class="number">2</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(allVal);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>利用闭包的思想，将回调函数存储到堆内存里。直到触发时，再输出结果。</p></li></ol><p>这样我们就完成了异步并发问题的处理，最优的选择就是利用闭包的方式，也就是上面的 _第二种_。</p><h2 id="两种设计模式"><a href="#两种设计模式" class="headerlink" title="两种设计模式"></a>两种设计模式</h2><h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>首先，发布订阅模式分为两个部分，分别是 <code>on</code> 和 <code>emit</code>，同时我们还包含一个存储属性 <code>arr</code>。</p><ul><li><strong>on</strong> 就是把一些需要用到的函数维护到一个数组中</li><li><strong>emit</strong> 就是将数组中的函数依次执行</li><li><strong>arr</strong> 用来对函数进行存储</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> event = &#123;</span><br><span class="line">  arr: [], <span class="comment">// 作为一个存储属性</span></span><br><span class="line">  on(fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.arr.push(fn);</span><br><span class="line">  &#125;,</span><br><span class="line">  emit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.arr.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn());</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，我们可以用这种设计模式来进行异步操作了。</p><p>我们还是用上述异步操作的例子。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>); <span class="comment">// file System</span></span><br><span class="line"><span class="keyword">let</span> allVal = &#123;&#125;;</span><br><span class="line">fs.readFile(<span class="string">"./name.txt"</span>, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  allVal.name = data;</span><br><span class="line">&#125;);</span><br><span class="line">fs.readFile(<span class="string">"./test.txt"</span>, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  allVal.test = data;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(allVal);</span><br></pre></td></tr></table></figure><p>下面我们来进行一下异步存储操作，依次输出我们想要的结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绑定输出函数到 on 上，以便我们对结果进行观察</span></span><br><span class="line">event.on(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"读取了一个"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">event.on(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 自定义异步操作全部执行完后，需要输出的结果</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(allVal).length === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(allVal);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 在每个异步函数下绑定 emit</span></span><br><span class="line">fs.readFile(<span class="string">"./name.txt"</span>, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  allVal.name = data;</span><br><span class="line">  event.emit();</span><br><span class="line">&#125;);</span><br><span class="line">fs.readFile(<span class="string">"./test.txt"</span>, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  allVal.test = data;</span><br><span class="line">  event.emit();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 最终输出结果： 读取了一个  读取了一个  &#123; name: 'zhangsan', test: 'test' &#125;</span></span><br></pre></td></tr></table></figure><p>我们可以用这种设计模式的开发思想，完成多种需求的开发。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>首先，这种设计模式既然被称为观察者模式，那么肯定就存在一个 <em>观察者</em> 和一个 <em>被观察者<em>。</em>观察者</em> 需要放到 <em>被观察者</em> 中，<em>被观察者</em> 的状态发生变化，会通知 _观察者_。<strong>（注：Vue 的双向绑定的实现原理使用的就是 _观察者模式_）</strong></p><p>其内部也是基于 <em>发布订阅模式</em> 实现的，所以我们平时会将 <em>观察者模式</em> 和 <em>发布订阅模式</em> 放到一起理解。</p><p>我们可以通过模拟一个宠物与主人之间的状态关系的例子，来进一步理解一下这个设计模式。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 观察者模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 被观察者</span></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.observers = [];</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">"开心"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  attach(o) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.push(o);</span><br><span class="line">  &#125;</span><br><span class="line">  setState(newState) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = newState;</span><br><span class="line">    <span class="keyword">this</span>.observers.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn.update(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 观察者</span></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  update(pets) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"知道了"</span> + pets.name + <span class="string">"的心情十分的"</span> + pets.state);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Subject(<span class="string">"花花"</span>);</span><br><span class="line"><span class="keyword">let</span> master1 = <span class="keyword">new</span> Observer(<span class="string">"大白"</span>);</span><br><span class="line"><span class="keyword">let</span> master2 = <span class="keyword">new</span> Observer(<span class="string">"小白"</span>);</span><br><span class="line">cat.attach(master1);</span><br><span class="line">cat.attach(master2);</span><br><span class="line">cat.setState(<span class="string">"伤心"</span>);</span><br><span class="line"><span class="comment">// 大白知道了花花的心情十分的伤心</span></span><br><span class="line"><span class="comment">// 小白知道了花花的心情十分的伤心</span></span><br></pre></td></tr></table></figure><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>Promise</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—Promise的介绍与实现</title>
    <url>/2021/07/28/Promise/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Promise%E7%9A%84%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue 全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9vcnBoYW5lZC9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZQ==">Promise|MDN<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><em>Promise 出现的原因</em>：处理多个并发请求，利用 <strong>链式调用</strong> 解决了 <strong>回调地狱</strong> 的问题。</p><p>Promise 存在三种状态，<em>成功（resolve）</em>、<em>失败（reject）</em>和 <em>等待（pending）</em>。</p><p>首先， <em>Promise是一个类</em> ，需要通过关键字 <code>new</code> 来进行实例化。</p><p>Promise接受一个 <code>executor</code> 函数作为执行器，执行器是立即执行的。同时又会接受两个参数作为 <em>成功</em> 和 <em>失败</em> 的回调。</p><p><img data-src="pic2.png" alt></p><p>当我们不去执行 <em>成功</em> 或 <em>失败</em> 的回调，当前这个Promise的状态就会维持在 <em>等待</em> 状态。Promise类会返回一个Promise类，方便下一次调用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(promise) <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>Promise 实例的返回值会根据调用的函数，来判断当前返回的是 <em>成功状态</em> 或 <em>失败状态</em>，并且会将传入参数返回。在调用函数时，若不传入参数，则会返回 <em>undefined</em>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 什么都不传</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(promise); <span class="comment">// Promise &#123; undefined &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功状态</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(promise); <span class="comment">// Promise &#123; 'success' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 失败状态</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'failed'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(promise); <span class="comment">// Promise &#123; &lt;rejected&gt; 'failed' &#125;</span></span><br></pre></td></tr></table></figure><p>每一个Promise的实例上，都有一个 <code>.then</code> 方法输出上一个实例传入的结果。当前实例状态被改变后，将无法再进行改变。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// success</span></span><br><span class="line">&#125;, (error) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样的话，我们就可以总结出来 Promise 的几个特点。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><em>Promise</em> 是一个类，无需考虑兼容性等问题。</li><li><em>Promise</em> 会传入一个函数（<code>executor</code>）作为执行器，此执行器是立即执行的。</li><li><code>executor</code> 提供了两个函数（<code>resolve</code> 和 <code>reject</code>）用来描述当前 <em>Promise</em> 的状态，而当前实例存在三种状态，<em>成功状态</em> 、 <em>失败状态</em> 和 <em>等待状态</em> ，当前实例默认为 <em>等待状态*。如果调用 <code>resolve</code> 则状态变为 *成功状态</em> ，调用 <code>reject</code> 或 发生异常 则状态变为 <em>失败状态</em> 。</li><li><em>Promise</em> 一旦状态变化后，则不能再更改。</li><li>每个 <em>Promise</em> 实例都有一个 <code>.then</code> 方法。</li></ol><p>我们可以根据 <em>Promise</em> 的几个特点，手写一套属于自己的 <em>Promise</em>。</p><h2 id="手写实现-Promises-A-规范"><a href="#手写实现-Promises-A-规范" class="headerlink" title="手写实现 Promises/A+ 规范"></a>手写实现 Promises/A+ 规范</h2><blockquote><p>文档规范 <span class="exturl" data-url="aHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8=">Promises/A+<i class="fa fa-external-link-alt"></i></span></p><p>注：代码内容为连续内容，请依序观看。谢谢</p></blockquote><h3 id="Promise的基础功能"><a href="#Promise的基础功能" class="headerlink" title="Promise的基础功能"></a>Promise的基础功能</h3><p>根据上述特点，我们就可以简单实现出 <em>Promise</em> 的效果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PEDDING = <span class="string">'PEDDING'</span>; <span class="comment">// 等待状态</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'FULFILLED'</span>; <span class="comment">// 成功状态</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'REJECTED'</span>; <span class="comment">// 失败状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123; </span><br><span class="line">    <span class="keyword">this</span>.status = PEDDING; <span class="comment">// 默认状态</span></span><br><span class="line">    <span class="keyword">this</span>.result = <span class="literal">undefined</span>; <span class="comment">// 成功的回调</span></span><br><span class="line">    <span class="keyword">this</span>.reason = <span class="literal">undefined</span>; <span class="comment">// 失败的回调</span></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function">(<span class="params">result</span>) =&gt;</span> &#123; <span class="comment">// 成功 resolve 函数</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === PEDDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = FULFILLED; <span class="comment">// 修改状态</span></span><br><span class="line">        <span class="keyword">this</span>.result = result; <span class="comment">// 添加回调</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123; <span class="comment">// 失败 reject 函数</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === PEDDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = REJECTED; <span class="comment">// 修改状态</span></span><br><span class="line">        <span class="keyword">this</span>.reason = reason; <span class="comment">// 添加回调</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">this</span>.reason = error;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123; <span class="comment">// 成功时调用的方法</span></span><br><span class="line">      onFulfilled(<span class="keyword">this</span>.result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123; <span class="comment">// 失败时调用的方法</span></span><br><span class="line">      onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span></span><br></pre></td></tr></table></figure><p>参考 <span class="exturl" data-url="aHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8=">Promise A+规范<i class="fa fa-external-link-alt"></i></span>，我们可以简单实现出来一版 <em>Promise</em> 类的简易实现版。</p><h3 id="实现Promise的异步功能"><a href="#实现Promise的异步功能" class="headerlink" title="实现Promise的异步功能"></a>实现Promise的异步功能</h3><p>实现 <em>Promise</em> 的异步，我们需要先明确，Promise中只有在触发 <code>.then</code> 方法时（<em>也就是</em><code>resolve</code> 和 <code>reject</code> ），才是异步的。所以我们利用这样一个思路。</p><p>当用户调用 <code>.then</code> 方法时，<em>Promise</em> 此时可能是 <em>等待状态</em>，我们需要先将其暂存起来。后续调用 <code>resolve</code> 和 <code>reject</code> 时，再去触发对应的 <code>onFulfilled</code> 和 <code>onRejected</code></p><p>根据上面的描述，我们可以捕捉到 <em>暂存</em> 和 <em>触发</em> 这两个关键词，那么我们就可以使用 <a href="https://mxshang.github.io/2021/07/12/Promise/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Promise%E4%B9%8B%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/">发布订阅</a> 的设计模式来实现此功能。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.onResolveCallbacks = []; <span class="comment">// 用来存储 成功的回调</span></span><br><span class="line">    <span class="keyword">this</span>.onRejectCallbacks = []; <span class="comment">// 用来存储 失败的回调</span></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === PEDDING) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">this</span>.onResolveCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === PEDDING) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">this</span>.onRejectCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === PEDDING) &#123;</span><br><span class="line">      <span class="keyword">this</span>.onResolveCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        onFulfilled(<span class="keyword">this</span>.result)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">this</span>.onRejectCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span></span><br></pre></td></tr></table></figure><p>建立<em>两个</em> 用来存储回调函数的<em>数组<em>，先将需要执行的函数</em>存储进数组</em> 中。当异步执行完后，再依次 <em>执行数组内存储的函数</em>。</p><h3 id="Promise链式调用"><a href="#Promise链式调用" class="headerlink" title="Promise链式调用"></a>Promise链式调用</h3><p>首先我们先要清楚，Promise的出现解决了哪些问题？</p><ul><li>处理多个并发请求</li><li><strong>链式调用</strong>解决了回调地狱的问题</li></ul><p>回调地狱是什么？ 回调地狱就是我们平时在处理业务代码时，下一个接口的api参数需要用到上一个接口的参数。代码上可能就会出现多级嵌套的情况，导致代码阅读起来十分困难。</p><p>这里我们就需要用到Promise的链式调用，也就是 <code>.then</code> 方法的循环调用，当调用 <code>.then</code> 方法后，会返回一个新的Promise。</p><p>我们先封装一个Promise的异步函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">path, encoding</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(path, encoding, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) reject(err)</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们需要清楚链式调用出现的几种情况。</p><ol><li><p><code>.then</code> 方法返回的是一个 <em>普通值（不是 Promise）</em> 的情况下，会作为外层下一次<code>.then</code> 方法的 <strong>成功结果</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">readFile(<span class="string">'./a.txt'</span>, <span class="string">'utf8'</span>).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">// 1</span></span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>.then</code> 方法执行出错，会走到外层下一次<code>.then</code> 方法的 <strong>失败结果</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">readFile(<span class="string">'./a.txt'</span>, <span class="string">'utf8'</span>).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err); <span class="comment">// Error: error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><em>(注：执行错误需要 <code>throw new Error()</code>，如果直接使用 <code>return new Error()</code>，属于返回一个<strong>Error对象</strong>，会执行下一次的成功结果)</em></p></li><li><p>无论上一次 <code>.then</code> 方法执行结果是 <em>成功</em> 还是 <em>失败</em>，只要返回的是普通值，都会执行下一次<code>.then</code> 方法的 <em>成功结果</em>。</p><p>如<strong>路径</strong>填写错误，Promise会默认执行第一层<code>.then</code>方法的<strong>错误结果</strong>，并<strong>返回undefined</strong>。则下一层的执行结果是<strong>成功结果</strong>，<strong>值为undefined</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路径填写错误</span></span><br><span class="line">readFile(<span class="string">'./a.txt1'</span>, <span class="string">'utf8'</span>).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 相当于在此处 return undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(err); <span class="comment">// 错误原因</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">// undefined</span></span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>如果 <code>.then</code> 方法返回的是一个 Promise 对象，此时会根据 Promise 的结果来处理是成功结果还是失败结果<em>（传入的是成功或失败的内容）</em>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">readFile(<span class="string">`<span class="subst">$&#123;bathPath&#125;</span>a.txt`</span>, <span class="string">'utf8'</span>).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readFile(<span class="string">`<span class="subst">$&#123;bathPath&#125;</span><span class="subst">$&#123;result&#125;</span>`</span>, <span class="string">'utf8'</span>)</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err1'</span>, err);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success2'</span>, result); <span class="comment">// success2 b</span></span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err2'</span>, err); <span class="comment">// error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p><strong>（总结：如果返回的是一个普通值（不是 Promise），就会传递给下一次 <code>.then</code> 方法的成功。如果返回的是一个失败的Promise 或者 抛出异常，就会传递给下一次 <code>.then</code> 方法的失败。）</strong></p><h3 id="手写实现promise链式调用"><a href="#手写实现promise链式调用" class="headerlink" title="手写实现promise链式调用"></a>手写实现promise链式调用</h3><p>根据上述特点和情况，我们每次在 <code>.then</code> 方法调用后都要返回一个新的 Promise 实例。所以我们可以对之前写好的 <code>.then</code> 方法进行相应的修改。</p><p>我们首先来处理 <strong>普通值（不是 Promise）</strong> 的情况。</p><p>（<em>注：在这里我们单独提出来了一个 <code>x</code>，用来进行后续处理</em>）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对 .then() 方法进行改写</span></span><br><span class="line">then(onFulfilled, onRejected) &#123;</span><br><span class="line">	<span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="comment">// 返回一个 promise 实例</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.result)</span><br><span class="line">				resolve(x);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">				reject(e)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">				resolve(x)</span><br><span class="line">			&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">				reject(e)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.status === PEDDING) &#123;</span><br><span class="line">			<span class="keyword">this</span>.onResolveCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.result)</span><br><span class="line">					resolve(x);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">					reject(e)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">this</span>.onRejectCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">					resolve(x)</span><br><span class="line">				&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">					reject(e)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用上述思路对之前的方法进行改造，这样我们就可以对 <strong>普通值</strong> 进行处理。</p><p>上述处理 <strong>普通值</strong> 的情况，我们可以稍加改动，使其可以处理更多的情况。为此我们需要封装一个 <code>resolvePromise()</code> 函数来进行处理。</p><p><code>resolvePromise()</code>需要接受四个参数，分别是 <em>当前实例promise</em> 、 <em>结果x</em> 、<em>成功回调resolve</em> 、 <em>失败回调reject</em>。</p><p>为了可以将当前实力promise作为参数传递，我们需要先用异步方法 <code>setTimeout</code> （其他方法也可以） 将其进行封装。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">then(onFulfilled, onRejected) &#123;</span><br><span class="line">	<span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="comment">// 返回一个 promise 实例</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.result)</span><br><span class="line">          <span class="comment">// 在此处进行封装处理</span></span><br><span class="line">          resolvePromise(promise, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// ... 后面代码进行同样的修改</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以读取到 <em>promise实例</em> 了，下面我们来实现 <code>resolvePromise()</code> 函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (promise === x) &#123;</span><br><span class="line">		<span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'错误'</span>))</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// promise 兼容性</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> x === <span class="string">'object'</span> &amp;&amp; x !== <span class="literal">null</span>) || <span class="keyword">typeof</span> x === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.then <span class="comment">// 通过defineProperty实现时，取值时可能会有异常</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        then.call(x, y =&gt; &#123;</span><br><span class="line">        	resolve(y)</span><br><span class="line">      	&#125;, r =&gt; &#123;</span><br><span class="line">      		reject(r)</span><br><span class="line">      	&#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    	reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 普通值</span></span><br><span class="line">  	resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（<em>注：在工作中，我们可能会调用别人封装的Promise，里面可能会有问题。所以我们还需要进行一步处理，也就是在代码里面加个*</em>锁*<em>，确保代码的严谨性。</em>）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> x === <span class="string">'object'</span> &amp;&amp; x !== <span class="literal">null</span>) || <span class="keyword">typeof</span> x === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> called = <span class="literal">false</span>; <span class="comment">// 定义一个参数</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.then <span class="comment">// 通过defineProperty实现时，取值时可能会有异常</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        then.call(x, y =&gt; &#123;</span><br><span class="line">          <span class="comment">// 在这里进行异常判断</span></span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">					called = <span class="literal">true</span></span><br><span class="line">        	resolve(y)</span><br><span class="line">      	&#125;, r =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">					called = <span class="literal">true</span></span><br><span class="line">      		reject(r)</span><br><span class="line">      	&#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">    	reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就实现了 Promise 的链式调用。</p><h3 id="特殊情况处理"><a href="#特殊情况处理" class="headerlink" title="特殊情况处理"></a>特殊情况处理</h3><h4 id="嵌套Promise"><a href="#嵌套Promise" class="headerlink" title="嵌套Promise"></a>嵌套Promise</h4><p>可能还会出现这种情况，我们在 <code>.then</code> 方法的 <code>resolve</code> 中传入一个 <em>Promise实例</em> ，这种情况我们要如何处理呢？</p><p>如下情况</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	resolve(<span class="number">1</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    	resolve(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        	resolve(<span class="number">200</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>针对上述特殊情况，我们需要继续对之前的<code>resolvePromise()</code> 函数 进行改造。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> x === <span class="string">'object'</span> &amp;&amp; x !== <span class="literal">null</span>) || <span class="keyword">typeof</span> x === <span class="string">'function'</span>) &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        then.call(x, y =&gt; &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        	<span class="comment">// 一直解析，直到不是 Promise 为止</span></span><br><span class="line">					resolvePromise(promise, y, resolve, reject)</span><br><span class="line">      	&#125;, r =&gt; &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">      	&#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键点就是在于<strong>递归调用</strong>，直到其值为<strong>普通值</strong>为止。</p><h4 id="参数穿透"><a href="#参数穿透" class="headerlink" title="参数穿透"></a>参数穿透</h4><p>我们在调用 <code>.then</code>方法 时，还会出现下面这种情况</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	resolve(<span class="number">100</span>)</span><br><span class="line">  <span class="comment">// reject('err')</span></span><br><span class="line">&#125;).then().then().then().then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(result); <span class="comment">// 100</span></span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(err); <span class="comment">// 如果传入，则输出 err</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不传入参数的情况下，结果会一直进行传递，直到输出为止。</p><p>这种参数穿透的情况，我们也需要在代码上进行改造。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">then(onFulfilled, onRejected) &#123;</span><br><span class="line">  <span class="comment">// 对 onFulfilled 进行处理</span></span><br><span class="line">	onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">err</span> =&gt;</span> &#123;<span class="keyword">throw</span> err&#125;; <span class="comment">// 抛出的情况下才会输出错误结果，所以要用 throw</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise测试"><a href="#Promise测试" class="headerlink" title="Promise测试"></a>Promise测试</h2><p>我们可以对自己封装的Promise进行测试，需要用到测试包 <code>promises-aplus-tests</code> 。</p><p>在Promise实例目录下执行如下代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install promises-aplus-tests -g</span><br><span class="line">promises-aplus-tests .&#x2F;promise.js</span><br></pre></td></tr></table></figure><p>他会自动检测我们封装的Promise是否符合 Promise A+ 规范。</p><p>在我们封装的 Promise 文件下添加 <strong>延迟对象</strong> 。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ... 自己封装的 Promise</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要进行测试用的代码</span></span><br><span class="line"><span class="built_in">Promise</span>.deferred = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> dfd = &#123;&#125;;</span><br><span class="line">	dfd.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		dfd.resolve = resolve</span><br><span class="line">		dfd.reject = reject</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> dfd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span></span><br></pre></td></tr></table></figure><p>（<em>注：<code>catch</code> 和 <code>all</code> 等都不属于Promise规范中包含的方法</em>）</p><p>检测完后，我们可以看到其输出结果，根据结果我们可以清楚自己封装的 Promise 是否可以正常运行。</p><p><img data-src="pic3.png" alt></p><p>至此，我们就封装好了一个<em>Promise</em>。</p><h3 id="延迟对象"><a href="#延迟对象" class="headerlink" title="延迟对象"></a>延迟对象</h3><p>用来帮我们减少一次套用，应用并不算广泛。有点类似于代理。</p><p>我们可以对最一开始我们自己的 <em>readFile读取操作</em> 进行封装。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">path, encoding</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dfd = <span class="built_in">Promise</span>.deferred();</span><br><span class="line">	fs.readFile(path, encoding, (err, data) =&gt; &#123;</span><br><span class="line">		<span class="keyword">if</span> (err) <span class="keyword">return</span> dfd.reject(err)</span><br><span class="line">		dfd.resolve(data)</span><br><span class="line">	&#125;)</span><br><span class="line">  <span class="keyword">return</span> dfd.promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>Promise</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—Generator和async/await</title>
    <url>/2021/10/26/Promise/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Generator%E5%92%8Casync-await/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="同步阻塞与异步非阻塞"><a href="#同步阻塞与异步非阻塞" class="headerlink" title="同步阻塞与异步非阻塞"></a>同步阻塞与异步非阻塞</h2><p>在了解异步的发展之前，我们要先清楚一个概念。那就是 <strong>同步异步与阻塞</strong>。</p><p>在执行代码的过程中，我们可能调用了某个方法。在调用方法时，如果方法没有执行完毕的话，后续的其他代码就无法向下执行，那么我当前的状态就是 <em>阻塞态</em>。 反之，便是 <em>非阻塞态</em>。</p><p>通过上述描述我们清楚了一个道理，那就是 <strong>阻塞与非阻塞指的是调用方的状态</strong>。</p><p>而针对于<em>被调用方</em> ，延迟发送结果我们就可以称为 <em>异步</em> ，而实时发送结果我们就可以称为 <em>同步</em> 。<strong>同步与异步指的是被调用方的状态</strong>。</p><p>所以在实际概念中，<strong>同步非阻塞是可能存在的，<em>但异步阻塞是一定不存在的</em></strong>。</p><p><code>Promise</code> 最早是为了解决异步的回调地狱问题，但是却并没有从根本上解决这个问题，所以我们可以考虑使用 <code>Generator</code>。</p><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTUvMDQvZ2VuZXJhdG9yLmh0bWw=">Generator函数的含义与用法<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><code>Generator</code> 是协程在 ES6 的实现，最大特点就是可以<strong>交出函数的执行权</strong>（即暂停执行）。</p><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>在普通函数中，我们可以利用 <em>return</em> 将函数的控制权交还给被调用的代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n + n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> it = read(<span class="number">1</span>); <span class="comment">// 调用foo函数</span></span><br></pre></td></tr></table></figure><p>函数在执行过程中，如果没有遇到<code>return</code>语句（函数末尾如果没有<code>return</code>，就是隐含的<code>return undefined;</code>），控制权无法交回被调用的代码。</p><p>而我们的 <code>Generator</code> 的语法与函数相似，却又有一些不同。</p><p><code>Generator</code>由<code>function*</code>定义（注意多出的<code>*</code>号），并且，除了<code>return</code>语句，还可以用<code>yield</code>返回多次。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">read</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 生成器，他的执行结果叫做迭代器</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = read();  <span class="comment">// 默认没有执行</span></span><br><span class="line"><span class="comment">// next方法触发回调</span></span><br><span class="line">it.next();</span><br></pre></td></tr></table></figure><p>定义的函数我们可以叫他 <em>生成器</em>，其执行结果我们可以叫做 <em>迭代器</em>。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>关于 <code>Generator</code> 的实现原理，我们可以从 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFiZWxqcy5jbi8=">babel官网<i class="fa fa-external-link-alt"></i></span> 上进行查看。</p><p><img data-src="pic4.png" alt></p><p>通过打印，我们可以很清楚的发现一件事情。 那就是 <code>Genetator</code> 实现原理的核心方法就是 <code>switch...case</code>。</p><p>我们每次在执行代码时，会在遇到 <code>yield</code> 时，将控制权交还给被调用的代码。等待下一次 <code>.next()</code> 方法，再执行后续的代码。</p><h3 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h3><blockquote><p>假设我们现在有一个文件 <em>a.txt<em>，里面有 *b.txt的路径（如 ./b.txt）</em>， 再将此内容作为参数，继续请求路径为 *b.txt</em> 的文件，得到结果 b。</p></blockquote><p>实现上述需求，利用 <code>Generator</code> 可以<strong>解决</strong>我们在请求过程中的<strong>回调地狱问题</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> readFile = util.promisify(fs.readFile);</span><br><span class="line"><span class="comment">// 解决了回调地狱</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">yield</span> readFile(<span class="string">'./a.txt'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    data = <span class="keyword">yield</span> readFile(data, <span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依旧存在回调地狱的问题</span></span><br><span class="line"><span class="keyword">let</span> it = read()</span><br><span class="line"><span class="keyword">let</span> &#123; value &#125; = it.next()</span><br><span class="line">value.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; value &#125; = it.next(data)</span><br><span class="line">    value.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> &#123; value &#125; = it.next(data)</span><br><span class="line">        <span class="built_in">console</span>.log(value) <span class="comment">// b</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们可以发现，发送请求时，我们利用 <code>Generator</code> 对异步请求进行了封装，使代码看起来更整洁了。</p><p>但是在调用的时候，依旧存在回调地狱的问题。</p><p>调用的回调地狱问题，我们可以使用 <a href="https://github.com/tj/co" target="_blank" rel="noopener"><em>tj/co</em></a> 库来进行处理。</p><p>这个库的实现原理，就是实现 <code>async/await</code> 的核心思路。</p><h3 id="co插件"><a href="#co插件" class="headerlink" title="co插件"></a>co插件</h3><p>使用co库，可以直接将 <code>Generator</code> 函数的<strong>最终结果返回</strong>，而且会使代码看起来更简洁优雅。</p><p><code>npm install co</code> 先安装插件库。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"></span><br><span class="line">co(read()).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data) <span class="comment">// b</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>直接会将结果返回。</p><h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">it</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 异步迭代，我们只能使用递归的方式</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> &#123;</span><br><span class="line">                value,</span><br><span class="line">                done</span><br><span class="line">            &#125; = it.next(data);</span><br><span class="line">            <span class="comment">// 如果执行完毕，则将最终结果返回</span></span><br><span class="line">            <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                resolve(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">Promise</span>.resolve(value).then(next, reject)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        next();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>还是参考上面那个例子。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"><span class="keyword">let</span> readFile = util.promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">yield</span> readFile(<span class="string">'./a.txt'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    data = <span class="keyword">yield</span> readFile(data, <span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co(read()).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data) <span class="comment">// b</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>async/await</code> 的实现思路就是 <code>Generator</code>，将 <code>Generator</code> 中的 <em>function</em> * 替换成 <em>async function</em> ，把 <em>yield</em> 替换成 <em>await</em> 。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> readFile(<span class="string">'./a.txt'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    data = <span class="keyword">await</span> readFile(data, <span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data) <span class="comment">// b</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样我们就可以直接输出最终结果。</p><p>可以说 <code>async/await</code> 是目前解决回调地狱问题的最优方案。</p><hr><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>Promise</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—Npm的介绍与使用</title>
    <url>/2021/11/22/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94npm%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="npm的介绍与使用"><a href="#npm的介绍与使用" class="headerlink" title="npm的介绍与使用"></a>npm的介绍与使用</h2><blockquote><p>官方网站 <span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tLw==">https://www.npmjs.com/<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><code>npm</code> 全称 <code>node package manager</code> ，是 nodejs 的包管理器 ，用于 node 插件管理，包括安装、卸载、管理依赖等。</p><h3 id="常用命令与配置"><a href="#常用命令与配置" class="headerlink" title="常用命令与配置"></a>常用命令与配置</h3><p>这里我们只总结一些平时工作中会经常用到的 <em>命令</em> 和 <em>配置</em>。</p><h4 id="npm-init"><a href="#npm-init" class="headerlink" title="npm init"></a>npm init</h4><p>默认安装一个 <code>package.json</code> 的文件，直接使用 <code>npm init -y</code> 进行安装。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"npm"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来介绍几个重要字段。</p><ul><li><strong>name</strong> ：当前包的 <strong>名字</strong> ，也就是最终发布到 <span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tLw==">npm官网<i class="fa fa-external-link-alt"></i></span> 上包的名字，不能和已有的包重名。</li><li><strong>version</strong>: 当前包的 <strong>版本号</strong> 。</li><li><strong>main</strong>：当前包的 <strong>入口文件</strong> ，也就是使用 <code>require</code> 默认引入的文件。</li><li><strong>scripts</strong>：可以配置一些 <strong>执行脚本</strong> ，如 <em>测试脚本</em> 等。</li><li><strong>license</strong>：<strong>协议许可</strong>。</li></ul><h4 id="npm-install"><a href="#npm-install" class="headerlink" title="npm install"></a>npm install</h4><p><code>npm install</code> 安装指定的包，简写为 <code>npm i</code>。 后面可以添加 <em>依赖关系</em>。</p><p>安装方式分为 <strong>全局安装</strong> 和 <strong>本地安装</strong>。</p><ul><li><p><strong>全局安装</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装一个全局 http 服务。</span></span><br><span class="line">npm install http-server -g</span><br></pre></td></tr></table></figure><p><strong>全局安装</strong> 的意思很简单，就是安装的模块会被安装到全局下。</p><p>可以在命令行中直接使用安装的包，其实只是在 <code>/user/local/bin</code> 目录下做了个 <em>链接</em> 连接到 <code>/usr/local/lib/node_modules/http-server/bin/http-server</code> 这个文件下。</p><p>当我们执行 <code>http-server</code> 这个命令时，会调用<em>链接</em> 到这个文件。<em>（mac因为有权限问题，这里我们可以加 <code>sudo</code> 来执行命令）</em></p><blockquote><p>关于此部分的使用，可以参考 我的博客 <a href="https://mxshang.github.io/2021/11/23/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/">node中第三方模块</a>。</p></blockquote><p>我们可以自己来尝试写一个包，创建bin目录，新增www文件。随便起一个名字。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #! 表示采用node来执行此文件，同理 shell可以表示 sh</span></span><br><span class="line"><span class="meta">#! /usr/bin/env node</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'莫小尚'</span>);</span><br></pre></td></tr></table></figure><p>更新 <code>package.json</code> 文件</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"bin": &#123;</span><br><span class="line">	"my-pack":"./bin/www" // 这里要注意名字和你建立的文件夹相同</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>再用一个常用的命令实现链接的功能。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm link</span><br></pre></td></tr></table></figure><p>这样我们在命令行中直接输入 <code>my-pack</code> 就可以 打印出结果。</p></li></ul><ul><li><p><strong>本地安装</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install webpack --save-dev</span><br></pre></td></tr></table></figure><p><strong>本地安装</strong> 就是在项目中使用，而非在命令行中使用。</p><p>执行上述命令，可以生成一个 <code>package-lock.json</code> 文件。</p><p>安装后的模块被安装到了 <code>node_modules</code> 下，并且在 <code>package.json</code> 中也增加了一些内容。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"devDependencies": &#123;</span><br><span class="line">    "webpack": "^4.39.3"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过添加后缀，指定版本号来安装包。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i jquery@2.2.0</span><br></pre></td></tr></table></figure><p><em>（默认执行 <code>npm i</code>会安装项目中所需要的依赖，如果只想安装生产环境依赖可以增加 <code>--production</code>参数）</em></p><p>下面我们来介绍一下 <code>package-lock</code> 文件。</p></li></ul><h5 id="package-lock-文件"><a href="#package-lock-文件" class="headerlink" title="package-lock 文件"></a>package-lock 文件</h5><p><code>package-lock.json</code> 的作用是 <em>锁定依赖安装结构</em> ，保证在任意机器上执行 <code>npm install</code> 都会得到完全相同的 <code>node_modules</code> ，因为<code>package-lock.json</code> 存储所有安装的信息。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"my-pack"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"lockfileVersion"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"requires"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">  <span class="attr">"@webassemblyjs/ast"</span>: &#123; </span><br><span class="line">      <span class="attr">"version"</span>: <span class="string">"1.8.5"</span>, <span class="comment">// 当前依赖的版本</span></span><br><span class="line">      <span class="attr">"resolved"</span>: <span class="string">"https://registry.npm.taobao.org/@webassemblyjs/ast/download/@webassemblyjs/ast-1.8.5.tgz"</span>, <span class="comment">// 从哪个渠道安装的</span></span><br><span class="line">      <span class="attr">"integrity"</span>: <span class="string">"sha1-UbHF/mV2o0lTv0slPfnw1JDZ41k="</span>, <span class="comment">// 内容hash</span></span><br><span class="line">      <span class="attr">"dev"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"requires"</span>: &#123;</span><br><span class="line">      <span class="attr">"@webassemblyjs/helper-module-context"</span>: <span class="string">"1.8.5"</span>,</span><br><span class="line">      <span class="attr">"@webassemblyjs/helper-wasm-bytecode"</span>: <span class="string">"1.8.5"</span>,</span><br><span class="line">      <span class="attr">"@webassemblyjs/wast-parser"</span>: <span class="string">"1.8.5"</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><em>（如果手动更新了 <code>package.json</code>文件，执行安装命令会下载对应的新版本，并且会自动更新 <code>package-lock</code> 文件）</em></p><h4 id="scripts配置"><a href="#scripts配置" class="headerlink" title="scripts配置"></a>scripts配置</h4><p>在 <code>package.json</code> 中可以定义自己的脚本通过 <code>npm run</code> 来执行。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">   "hello": "echo hello",</span><br><span class="line">   "build": "webpack"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用 <code>npm run hello</code> 执行自定义脚本，也可以使用 <code>npm run build</code> 执行<code>node_modules/.bin</code> 目录下的 <em>webpack文件</em>。</p><ul><li><p><code>npm run</code> 命令执行时，会把 <code>./node_modules/.bin/</code> 目录添加到执行环境的 <code>PATH</code> 变量中。因此如果某个 <strong>命令行包</strong> 未全局安装，而只安装在了当前项目的 <code>node_modules</code> 中，通过 <code>npm run</code> 一样可以执行该命令。</p></li><li><p>执行 <em>npm脚本</em> 时要传入参数，需要在命令后加 <code>--</code> 标明。如 <code>npm run hello -- --port 3000</code> 可以将 <code>--port</code> 参数传给<code>hello</code> 命令。</p></li><li><p>npm 提供了 <code>pre</code> 和 <code>post</code> 两种钩子机制。可以定义某个脚本前后的执行脚本，没有定义默认会忽略。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">   "prehello":"echo prehello",</span><br><span class="line">   "hello": "echo hello",</span><br><span class="line">   "posthello":"echo posthello"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><em>（通过打印 全局 env 和 在项目下执行 <code>npm run env</code>来对比<code>PATH</code>属性，不难发现在执行 <code>npm run</code> 的时候确实会将 <code>./node_modules/.bin/</code> 目录添加到<code>PATH</code> 中）</em></p><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>依赖关系分为以下几种：</p><ul><li><strong>开发依赖</strong> <code>devDependencies</code>，开发时使用的依赖，上线时就不需要了。如 <em>webpack</em> 、 <em>gulp</em> 等。</li><li><strong>生产依赖</strong> <code>dependencies</code>，开发时会用，上线的时候也需要。如 <em>vue</em> 等。</li><li><strong>同等依赖</strong> <code>peerDependencies</code>，安装某个库时，提示需要用到的其他依赖。如 <em>安装bootstrap</em> ，则需要用到依赖 <em>jQuery</em> 。</li><li><strong>可选依赖</strong> <code>optionalDependencies</code>，如果有一些依赖包即使安装失败，项目仍然能够运行或者希望npm继续运行。</li><li><strong>打包依赖 (捆绑依赖)</strong> <code>bundledDependencies</code>，将这个对象中的包打包到最终的发布包里，就是将节点内的包压缩到一个压缩包中。</li></ul><p>开发中用的最多的就是 <strong>开发依赖</strong> 、 <strong>生产依赖</strong> 和 <strong>同等依赖</strong>。</p><h4 id="开发依赖-和-生产依赖"><a href="#开发依赖-和-生产依赖" class="headerlink" title="开发依赖 和 生产依赖"></a>开发依赖 和 生产依赖</h4><p>开发依赖，<strong>开发环境所需要的依赖</strong>。同理，生产依赖，就是 <strong>生产环境所需要的依赖</strong>。</p><ul><li><strong>–save</strong>：将保存配置信息到 <em>package.json*，默认为 *dependencies</em> 节点中。</li><li><strong>–save-dev</strong>：默认为 <em>devDependencies</em> 节点中。</li></ul><p>在实际开发中，我们 <strong>不填写任何标识</strong>，则会默认安装到 <strong>生产环境</strong> 中。</p><p><img data-src="pic15.png" alt="devDependencies节点"></p><p>假设我们需要安装到 <strong>开发环境</strong> ，则填写标识 <code>--save-dev</code> 即可。</p><p><img data-src="pic16.png" alt="dependencies节点"></p><p>如果我们现在有一个 <em>github</em> 上克隆的开源项目，我们需要安装当前项目所需要的插件和各种依赖。</p><p>直接使用命令 <code>npm install</code> ，就会将上述两个节点下的依赖全部加载到 <code>node_modules</code> 下。</p><p>假设我们现在只需要 <em>生产依赖</em> ，则在后面加上节点 <em>production</em> 即可。 <code>npm install --production</code></p><h4 id="同等依赖"><a href="#同等依赖" class="headerlink" title="同等依赖"></a>同等依赖</h4><p>同等依赖，就是节点 <em>peerDependencies</em> 。</p><p>在安装时会提示我们需要用到的 <em>同等依赖包</em> 有哪些，起到一个提示的作用。</p><p><img data-src="pic17.png" alt="peerDependencies节点"></p><h3 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h3><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY24vbWlzYy9zZW12ZXIv">semver | npm中文文档<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>npm采用了 <strong><code>semver</code>规范</strong> 作为依赖版本管理方案，<code>semver</code> 约定一个包的版本号必须包含3个数字。</p><p><code>MAJOR.MINOR.PATCH</code> 意思是 <em>主版本号.小版本号.修订版本号</em> 。</p><ul><li><code>MAJOR</code> 对应大的版本号迭代，做了不兼容旧版的修改时要更新 <code>MAJOR</code> 版本号。</li><li><code>MINOR</code> 对应小版本迭代，发生兼容旧版API的修改或功能更新时，更新 <code>MINOR</code> 版本号。</li><li><code>PATCH</code> 对应修订版本号，一般针对修复 BUG 的版本号。</li></ul><p>当我们每次发布包的时候都需要升级版本号。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm version major  <span class="comment"># 大版本号加 1，其余版本号归 0</span></span><br><span class="line">npm version minor  <span class="comment"># 小版本号加 1，修订号归 0</span></span><br><span class="line">npm version patch  <span class="comment"># 修订号加 1</span></span><br></pre></td></tr></table></figure><p>如果使用 <code>git</code> 管理项目会自动 <code>git tag</code> 标注版本号。</p><h4 id="标识含义"><a href="#标识含义" class="headerlink" title="标识含义"></a><strong>标识含义</strong></h4><table><thead><tr><th>range</th><th>含义</th><th align="left">例</th></tr></thead><tbody><tr><td><code>^2.2.1</code></td><td>指定的 MAJOR 版本号下, 所有更新的版本</td><td align="left">匹配 <code>2.2.3</code>, <code>2.3.0</code>; 不匹配 <code>1.0.3</code>, <code>3.0.1</code></td></tr><tr><td><code>~2.2.1</code></td><td>指定 MAJOR.MINOR 版本号下，所有更新的版本</td><td align="left">匹配 <code>2.2.3</code>, <code>2.2.9</code> ; 不匹配 <code>2.3.0</code>, <code>2.4.5</code></td></tr><tr><td><code>&gt;=2.1</code></td><td>版本号大于或等于 <code>2.1.0</code></td><td align="left">匹配 <code>2.1.2</code>, <code>3.1</code></td></tr><tr><td><code>&lt;=2.2</code></td><td>版本号小于或等于 <code>2.2</code></td><td align="left">匹配 <code>1.0.0</code>, <code>2.2.1</code>, <code>2.2.11</code></td></tr><tr><td><code>1.0.0 - 2.0.0</code></td><td>版本号从 1.0.0 (含) 到 2.0.0 (含)</td><td align="left">匹配 <code>1.0.0</code>, <code>1.3.4</code>, <code>2.0.0</code></td></tr></tbody></table><h4 id="预发版"><a href="#预发版" class="headerlink" title="预发版"></a><strong>预发版</strong></h4><ul><li><strong>alpha</strong> <em>(α)</em>：<strong>预览版</strong>，或者叫 <strong>内部测试版</strong>；一般不向外部发布，会有很多bug；一般只有测试人员使用。</li><li><strong>beta</strong> <em>(β)</em>：<strong>测试版</strong>，或者叫 <strong>公开测试版</strong>；这个阶段的版本会一直加入新的功能；在alpha版之后推出。</li><li><strong>rc</strong> <em>(release candidate)</em>：<strong>最终测试版</strong>；可能成为最终产品的候选版本，如果未出现问题则可发布成为正式版本。</li></ul><p><em>（<code>2.1.0-beta.1</code>这样声明的版本用户不会立马使用，可以用来做测试使用）</em></p><h2 id="npx的用法"><a href="#npx的用法" class="headerlink" title="npx的用法"></a>npx的用法</h2><blockquote><p>参考官网 <span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbnB4">npx - npm<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><code>npx</code> 命令是 <em>npm v5.2</em> 之后引入的新命令，<code>npx</code> 可以帮我们直接执行 <code>node_modules/.bin</code> 文件夹下的文件。</p><p><code>npx</code> 想要解决的主要问题，就是调用项目内部安装的模块。</p><h3 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>这样执行，会直接省略配置 <code>scripts</code> 脚本。</p><h3 id="避免安装全局模块"><a href="#避免安装全局模块" class="headerlink" title="避免安装全局模块"></a>避免安装全局模块</h3><p>全局安装的模块会带来很多问题，如 <em>多个用户全局安装的模块版本不同</em> 。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx create-react-app react-project</span><br></pre></td></tr></table></figure><p>我们可以直接使用 <code>npx</code> 来执行模块。</p><p>它会先进行安装，安装后会将下载过的模块删除。这样可以保证项目是最新版本。</p><h2 id="npm包的发布"><a href="#npm包的发布" class="headerlink" title="npm包的发布"></a>npm包的发布</h2><p>首先我们需要先切换到官方源 <code>nrm</code>，这样更快。（关于 <a href="https://mxshang.github.io/2021/11/23/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/">nrm</a> 可以参考我之前的博客）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install nrm -g</span><br><span class="line">nrm use npm <span class="comment"># 切换到官方源</span></span><br></pre></td></tr></table></figure><p>之后将名字更新一下，这里也可以发布 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm5wbWpzLmNvbS9jcmVhdGluZy1hbmQtcHVibGlzaGluZy1zY29wZWQtcHVibGljLXBhY2thZ2Vz">作用域包<i class="fa fa-external-link-alt"></i></span> 选定版本。</p><p>忽略可以使用 <code>.npmignore</code>，然后可以直接进行发布了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure><p>这样我们自定义的包就被上传到 <span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tLw==">npm官网<i class="fa fa-external-link-alt"></i></span> 上啦。</p><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>Node</tag>
        <tag>JS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—前端基础之ES6(1)</title>
    <url>/2021/05/10/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BES6-1/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><h2 id="let、const和var的区别"><a href="#let、const和var的区别" class="headerlink" title="let、const和var的区别"></a>let、const和var的区别</h2><p><code>let</code>、<code>const</code> 和 <code>var</code>都是用来定义变量的，那它们有什么区别呢？</p><h3 id="var的特点"><a href="#var的特点" class="headerlink" title="var的特点"></a>var的特点</h3><ol><li><p>对<strong>全局变量</strong>造成污染</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">//1</span></span><br></pre></td></tr></table></figure></li><li><p>存在<strong>变量提升</strong>机制</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"a"</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>var</code>可以被<strong>重复声明</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>var</code>的作用域只有<strong>全局作用域</strong>和<strong>函数作用域</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="let的特点"><a href="#let的特点" class="headerlink" title="let的特点"></a>let的特点</h3><ol><li><p>不可以被重复声明</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure></li><li><p>存在块级作用域</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// 0 1 2 ... 8 9</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>如果使用<code>var</code>进行定义，则会全部输出10</em></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// 10</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>暂时性死区</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// Cannot access 'a' before initialization</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>因为ES6在定义变量的时候，会把同名的变量定义为两个变量</em>（如 <strong>下图</strong> 所示）<br><img data-src="pic1.png" alt></p></li><li><p>不会绑定在 <code>window</code> 上</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.info(<span class="built_in">window</span>.a);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="const的特点"><a href="#const的特点" class="headerlink" title="const的特点"></a>const的特点</h3><p><code>const</code>是<strong>不可变的量</strong>，也就是<strong>常量</strong>。</p><ol><li><p><code>const</code>定义的变量不可以对其值进行修改。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line">PI = <span class="number">3.15</span>; <span class="comment">// Assignment to constant variable.</span></span><br></pre></td></tr></table></figure></li><li><p><code>const</code>可以修改同一地址（堆内存）中的值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line">a.b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// &#123;b: 2&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>在解构中，有下面两部分参与：</p><p><strong>解构的源</strong>：解构赋值表达式的右边部分。</p><p><strong>解构的目标</strong>：解构赋值表达式的左边部分。</p><h3 id="数组解构-Array"><a href="#数组解构-Array" class="headerlink" title="数组解构(Array)"></a>数组解构(Array)</h3><ol><li><p>基本使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// c = 3</span></span><br></pre></td></tr></table></figure></li><li><p>嵌套使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, [[b], c]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// c = 3</span></span><br></pre></td></tr></table></figure></li><li><p>可以忽略未定义变量</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, , b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 3</span></span><br></pre></td></tr></table></figure></li><li><p>非完全解构</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b] = []; <span class="comment">// a = 1, b = undefined</span></span><br></pre></td></tr></table></figure></li><li><p>字符串解构等</p><p><em>在数组的解构中，解构的目标若为<strong>可遍历对象</strong>，皆可进行解构赋值。</em></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line"><span class="comment">// a = 'h'</span></span><br><span class="line"><span class="comment">// b = 'e'</span></span><br><span class="line"><span class="comment">// c = 'l'</span></span><br><span class="line"><span class="comment">// d = 'l'</span></span><br><span class="line"><span class="comment">// e = 'o'</span></span><br></pre></td></tr></table></figure></li><li><p>解构默认值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">2</span>] = [<span class="literal">undefined</span>]; <span class="comment">// a = 2</span></span><br></pre></td></tr></table></figure><p><em>当解构模式有匹配结果，且匹配结果是 <code>undefined</code> 时，会触发默认值作为返回结果。</em></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [];     <span class="comment">// a = 3, b = 3</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>];    <span class="comment">// a = 1, b = 1</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// a = 1, b = 2</span></span><br></pre></td></tr></table></figure><ul><li>a 与 b 匹配结果为 <em>undefined</em> ，触发默认值：<strong>a = 3; b = a =3</strong></li><li>a 正常解构赋值，匹配结果为 <em>a = 1*，b 匹配结果 *undefined</em> ，触发默认值：<strong>b = a =1</strong></li><li>a 与 b 正常解构赋值，匹配结果为 <strong>a = 1，b = 2</strong></li></ul></li><li><p>扩展运算符</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = [2, 3]</span></span><br></pre></td></tr></table></figure><p>扩展运算符，又叫 <strong>展开运算符</strong> 或 <strong>剩余运算符</strong>。可以利用扩展运算符，对数组进行合并。（如 <strong>下图</strong> 所示）<img data-src="pic2.png" alt></p></li></ol><h3 id="对象解构-Object"><a href="#对象解构-Object" class="headerlink" title="对象解构(Object)"></a>对象解构(Object)</h3><ol><li><p>基本使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line"><span class="comment">// foo = 'aaa'</span></span><br><span class="line"><span class="comment">// bar = 'bbb'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">baz</span> : foo &#125; = &#123; <span class="attr">baz</span> : <span class="string">'ddd'</span> &#125;;</span><br><span class="line"><span class="comment">// foo = 'ddd'</span></span><br></pre></td></tr></table></figure></li><li><p>可嵌套/可忽略</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [<span class="string">'hello'</span>, &#123;<span class="attr">y</span>: <span class="string">'world'</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line"><span class="comment">// x = 'hello'</span></span><br><span class="line"><span class="comment">// y = 'world'</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [<span class="string">'hello'</span>, &#123;<span class="attr">y</span>: <span class="string">'world'</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123;  &#125;] &#125; = obj;</span><br><span class="line"><span class="comment">// x = 'hello'</span></span><br></pre></td></tr></table></figure></li><li><p>非完全解构</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [&#123;<span class="attr">y</span>: <span class="string">'world'</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [&#123; y &#125;, x ] &#125; = obj;</span><br><span class="line"><span class="comment">// x = undefined</span></span><br><span class="line"><span class="comment">// y = 'world'</span></span><br></pre></td></tr></table></figure></li><li><p>解构默认值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a = <span class="number">10</span>, b = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// a = 3; b = 5;</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span>: aa = <span class="number">10</span>, <span class="attr">b</span>: bb = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// aa = 3; bb = 5;</span></span><br></pre></td></tr></table></figure></li><li><p>扩展运算符</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, b, ...rest&#125; = &#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span>&#125;;</span><br><span class="line"><span class="comment">// a = 10</span></span><br><span class="line"><span class="comment">// b = 20</span></span><br><span class="line"><span class="comment">// rest = &#123;c: 30, d: 40&#125;</span></span><br></pre></td></tr></table></figure><p>在ES6中，我们可以通过 <em>扩展运算符</em> 实现很多应用，例如 <strong>深拷贝和浅拷贝</strong>。</p><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS93M2Nub3RlL2RlY29uc3RydWN0aW9uLWFzc2lnbm1lbnQuaHRtbA==">ES6 解构赋值 | 菜鸟教程<i class="fa fa-external-link-alt"></i></span></p></blockquote></li></ol><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p><strong>深拷贝</strong>：拷贝后与原数组无关，会使 <em>拷贝后的数组</em> 在堆中指向一个新的内存空间。<br><strong>浅拷贝</strong>：拷贝后与原数组有关，<em>新数组</em> 与 <em>原数组</em> 指向同一个堆内存。</p><p><img data-src="pic3.png" alt></p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><p><code>Object.assign()</code> 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 <code>Object.assign()</code> 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: &#123;<span class="attr">name</span>: <span class="string">"mxs"</span>, <span class="attr">age</span>: <span class="number">26</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line">obj2.a.name = <span class="string">"zd"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a.name); <span class="comment">// zd</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat()"></a>Array.prototype.concat()</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, &#123;</span><br><span class="line">  name: <span class="string">'mxs'</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.concat();    </span><br><span class="line">arr2[<span class="number">2</span>].name = <span class="string">'zd'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, &#123;name:'zd'&#125;]</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-slice"><a href="#Array-prototype-slice" class="headerlink" title="Array.prototype.slice()"></a>Array.prototype.slice()</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, &#123;</span><br><span class="line">  name: <span class="string">'mxs'</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.slice();</span><br><span class="line">arr2[<span class="number">2</span>].name = <span class="string">'zd'</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, &#123;name:'zd'&#125;]</span></span><br></pre></td></tr></table></figure><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><p>扩展运算符只能拷贝一层 <strong>对象</strong> / <strong>数组</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">'zd'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">age</span>:&#123;<span class="attr">count</span>:<span class="number">26</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> allObj = &#123;...school,...my&#125;;</span><br><span class="line">obj2.age.count = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(allObj); <span class="comment">// &#123;&#123;name: "zd", age: &#123;count: 100&#125;&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;age: &#123;count: 100&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>可以发现两个对象都改变了，这就是只实现了 <strong>浅拷贝</strong>。</p><p>如果想要实现 <strong>深拷贝</strong>，会十分的麻烦。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">'zd'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">age</span>:&#123;<span class="attr">count</span>:<span class="number">26</span>&#125;,<span class="attr">name</span>:<span class="string">'mxs'</span>&#125;;</span><br><span class="line"><span class="comment">// 把原来的my放到新的对象中，用一个新的对象age将原始的age也拷贝一份</span></span><br><span class="line"><span class="keyword">let</span> newObj2 = &#123;...obj2,<span class="attr">age</span>:&#123;...obj2.age&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> allObj = &#123;...obj1,...newObj2&#125;;</span><br><span class="line">obj2.age.count = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(allObj); <span class="comment">// &#123;&#123;name: "mxs", age: &#123;count: 26&#125;&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;&#123;name: "mxs", age: &#123;count: 100&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><h4 id="JSON-parse-JSON-stringify"><a href="#JSON-parse-JSON-stringify" class="headerlink" title="JSON.parse(JSON.stringify())"></a>JSON.parse(JSON.stringify())</h4><p>用<code>JSON.stringify</code>将对象转成JSON字符串，再用<code>JSON.parse()</code>把字符串解析成对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">'zd'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">age</span>:&#123;<span class="attr">count</span>:<span class="number">26</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> allObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(&#123;...obj1,...obj2&#125;));</span><br><span class="line">obj2.age.count = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(allObj); <span class="comment">// &#123;name: 'zd', age: &#123; count: 26 &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>但是需要注意的是，<code>(JSON.stringify([value]))</code> 这种方法虽然可以实现深拷贝，但是却不能拷贝 <code>Function</code>、<code>undefined</code> 和 <code>Symbol</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">'zd'</span>, <span class="attr">age</span>:&#123;&#125;, <span class="attr">count</span>:<span class="number">26</span>, <span class="attr">a</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="attr">b</span>:<span class="literal">null</span>, <span class="attr">c</span>:<span class="literal">undefined</span>, <span class="attr">d</span>:<span class="built_in">Symbol</span>(<span class="string">'zd'</span>)&#125;</span><br><span class="line"><span class="keyword">let</span> allObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(allObj); <span class="comment">// &#123;name: 'zd', age: &#123;&#125;, count: 26, b: null&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以看到，最终被拷贝下来的，只有 <code>String</code> 、<code>Object</code>、 <code>Number</code> 和 <code>Null</code> 这几种数据类型。</p><h4 id="lodash库"><a href="#lodash库" class="headerlink" title="lodash库"></a>lodash库</h4><p>我们可以通过 <strong>loadash库</strong>中的 <code>cloneDeep</code> 方法来实现深克隆。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">   a: <span class="number">1</span>,</span><br><span class="line">   b: &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">   c: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> cloneObj = _.cloneDeep(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj.a.b === cloneObj.a.b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="手写实现深拷贝"><a href="#手写实现深拷贝" class="headerlink" title="手写实现深拷贝"></a>手写实现深拷贝</h4><p>我们先来看一下完整的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj,hash = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (hash.has(obj)) <span class="keyword">return</span> hash.get(obj);</span><br><span class="line">  <span class="keyword">let</span> cloneObj = <span class="keyword">new</span> obj.constructor;</span><br><span class="line">  hash.set(obj, cloneObj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.hasOwnProperty.call(obj, key)) &#123;</span><br><span class="line">      cloneObj[key] = deepClone(obj[key], hash);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">'zd'</span>, <span class="attr">age</span>:&#123;&#125;, <span class="attr">count</span>:<span class="number">26</span>, <span class="attr">a</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="attr">b</span>:<span class="literal">null</span>, <span class="attr">c</span>:<span class="literal">undefined</span>, <span class="attr">d</span>:<span class="built_in">Symbol</span>(<span class="string">'zd'</span>)&#125;</span><br><span class="line"><span class="keyword">let</span> allObj = deepClone(obj);</span><br><span class="line"><span class="built_in">console</span>.log(allObj); <span class="comment">// &#123;name: 'zd', age: &#123;&#125;, count: 26, a: [Function: a], b: null, c: undefined, d: Symbol(zd)&#125;</span></span><br></pre></td></tr></table></figure><p>如果我们想要手写一套深克隆的函数方法，我们需要先搞懂其实现思路。</p><p>简单来说，其实现思路就是 <em>类型判断</em>，<em>克隆数据类型</em>， <em>遍历循环</em>，最后进行 <em>结果输出</em>。</p><ol><li><p>我们先思考，为什么要进行 <em>类型判断</em> ？</p><p>在此之前，我们需要先要清楚 <strong>数据类型判断方式</strong>。</p><ul><li>typeof</li><li>instanceof / constructor</li><li>Object.prototype.toString.call([value])</li></ul><p>然后我们再来看代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果obj是null或者undefined，则直接将结果返回</span></span><br><span class="line"><span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line"><span class="comment">// 如果obj是基础数据类型或者函数，则直接将结果返回(也就是说，函数不需要进行任何处理)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> obj;</span><br><span class="line"><span class="comment">// 如果obj不是对象或数组，则直接将结果返回</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br></pre></td></tr></table></figure><p>通过上面的代码，我们可以发现，剩下的只有两种数据类型 <strong>数组</strong> 和 <strong>对象</strong>。</p><p>那么我们就清楚了，进行 <em>类型判断</em> ，其目的就是为了将需要进行深克隆数据类型筛选出来。</p></li><li><p>然后再思考，如何 <em>克隆</em> 传入对象的 <em>数据类型</em> 呢？</p><p>最常用的方案如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cloneObj = <span class="built_in">Object</span>.prototype.toString.call(obj) === [<span class="string">'Object Array'</span>] ? [] : &#123;&#125;;</span><br></pre></td></tr></table></figure><p>但是这种写法太麻烦了，我们有更简单的实现方案。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// obj不是数组就是对象，将其进行克隆</span></span><br><span class="line"><span class="keyword">let</span> cloneObj = <span class="keyword">new</span> obj.constructor;</span><br></pre></td></tr></table></figure><p>根据 <strong>原型链</strong> 的指向原则，我们可以利用上述方案来创建一个新的数据类型对象。(如 <strong>下图</strong> 所示)</p><p><img data-src="pic4.png" alt></p><p><em>克隆数据类型</em> 的目的，其实就是为了进行下一步的 <em>遍历循环</em>。</p></li><li><p>接着，我们要进行 <em>遍历循环</em> 。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.hasOwnProperty.call(obj, key)) &#123;</span><br><span class="line">    <span class="comment">// 进行递归，实现深克隆</span></span><br><span class="line">    cloneObj[key] = deepClone(obj[key]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 <code>forin</code> 进行循环，在对象复制前，我们都会将值进行递归，再次执行当前方法，判断是否有深层属性。直到递归至没有深层属性为止。</p><p>然后将结果赋值给<code>cloneObj</code>，最后把结果进行输出。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> cloneObj</span><br></pre></td></tr></table></figure><p>但是这种写法还存在一个问题，就是无法进行 <strong>循环引用</strong> 。</p><p>如果要进行循环引用，就会发生 <strong>栈内存溢出</strong> 的情况。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:&#123;<span class="attr">name</span>:<span class="string">'mxs'</span>&#125;&#125;</span><br><span class="line">obj.b = obj;</span><br><span class="line"><span class="keyword">let</span> allObj = deepClone(obj);</span><br><span class="line">obj.a.name = <span class="string">'zd'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure><p>为了处理这种问题的发生，我们还需要在进行一步操作。</p></li><li><p>最后，我们需要对 <strong>异常情况</strong> 进行处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br></pre></td></tr></table></figure><p>设定一个 <code>WeakMap</code> 数据类型（关于 <code>WeakMap</code> ，可以 参考文献 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvV2Vha01hcA==">WeakMap-JavaScript | MDN<i class="fa fa-external-link-alt"></i></span> ，或查看我的另一篇博客 <a href="https://mxshang.github.io/2021/05/28/学习笔记—前端基础之ES6-2/#weakMap">ES6 | weakMap</a>）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(hash.has(obj)) <span class="keyword">return</span> hash.get(obj);</span><br><span class="line">hash.set(obj, cloneObj);</span><br></pre></td></tr></table></figure><p>如果是 <code>Object</code>，我们就将其放到 <code>weakMap</code> 中。如果在拷贝之前，这个 <code>Object</code> 就已经存在了，我们就直接将其返回。</p><p>至此，我们的 <strong>深拷贝</strong> 就完成了。</p></li></ol><p>我们可以通过这种思路，写出很多种 <strong>深克隆</strong> 的方案。</p><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>JS基础</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—前端基础之ES6(2)</title>
    <url>/2021/05/28/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BES6-2/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><h2 id="Set-Map"><a href="#Set-Map" class="headerlink" title="Set / Map"></a>Set / Map</h2><p><code>Set</code> 和 <code>Map</code> 是两种存储结构。</p><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMTAyMjkxMDgyMTE0OTMxMi8xMDIzMDI0MTgxMTA5NDQw">Map和Set | 廖雪峰的官网<i class="fa fa-external-link-alt"></i></span></p></blockquote><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>首先，<code>Set</code>属于 <em>object</em> 类型（如 <strong>下图</strong> 所示）</p><p><img data-src="pic5.png" alt></p><p><code>new Set([value]) [value]:Array</code></p><p><img data-src="pic6.png" alt></p><p><code>Set</code> 是一组 <strong>key 集合</strong>，但<strong>不存储 value</strong>。由于<strong>key不能重复</strong>，所以，在<code>Set</code>中，<strong>没有重复的key</strong>。</p><p>因此，我们常常利用 <code>Set</code> 来实现 <em>数组去重</em> 。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure><p>通过<code>add(key)</code>方法可以添加元素到<code>Set</code>中，可以重复添加，但不会有效果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// 仍然是 Set &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure><p>通过<code>delete(key)</code>方法可以删除元素</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.delete(<span class="number">3</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 4&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以用以下方法对 <code>Set {1, 2, 3, 4}</code> 进行数组转换处理。</p><ul><li><p>展开运算符</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...s];</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li><li><p>Array.form()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(s);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// // [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li></ul><p>同时，我们可以利用<code>Set</code>实现各种处理，例如实现集合的 <em>并集<em>、</em>交集</em> 和 <em>差集</em> 等。</p><p>假如我们现在有以下两个数组。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr1);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr2);</span><br></pre></td></tr></table></figure><ul><li><p>并集</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...new <span class="built_in">Set</span>([...s1, ...s2])]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(union()); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p>交集</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intersection</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...s1].filter(<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.has(val)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(intersection()); <span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>这里我们用到了 <code>filter</code> 这个高阶函数来进行处理。</p></li><li><p>差集</p><p>差集很好理解，其实就是交集取反，就是 <em>差集</em>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...s1].filter(<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !s2.has(val)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(diff()); <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><code>Map</code> 也属于 <em>Object</em> 类型</p><p><img data-src="pic7.png" alt></p><p><code>Map</code>是一组<strong>键值对</strong>的结构，具有<strong>极快的查找速度</strong>。</p><p>先对 <code>Map</code> 进行初始化</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'a'</span>, <span class="number">1</span>], [<span class="string">'b'</span>, <span class="number">2</span>], [<span class="string">'3'</span>, <span class="number">3</span>]]);</span><br><span class="line">m.get(<span class="string">'b'</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>我们新建一个<code>Map</code> ，需要一个二维数组，或者直接初始化一个空的 <code>Map</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 空Map</span></span><br><span class="line">m.set(<span class="string">'a'</span>, <span class="number">1</span>); <span class="comment">// 添加新的key-value</span></span><br><span class="line">m.set(<span class="string">'b'</span>, <span class="number">2</span>);</span><br><span class="line">m.has(<span class="string">'a'</span>); <span class="comment">// 是否存在key 'a': true</span></span><br><span class="line">m.get(<span class="string">'a'</span>); <span class="comment">// 1</span></span><br><span class="line">m.delete(<span class="string">'a'</span>); <span class="comment">// 删除key 'a'</span></span><br><span class="line">m.get(<span class="string">'a'</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>由于一个 <code>key</code> 只能对应一个 <code>value</code> ，所以，多次对一个key放入value，<strong>后面的值会把前面的值替换掉</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="string">'a'</span>, <span class="number">1</span>);</span><br><span class="line">m.set(<span class="string">'a'</span>, <span class="number">11</span>);</span><br><span class="line">m.get(<span class="string">'a'</span>); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>在这里我们可以思考一个问题，<code>Map</code> 的 <code>key</code> 是否可以是一个对象呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line">m.set(obj, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m);<span class="comment">// &#123;&#123;a: 1&#125; =&gt; 2&#125;</span></span><br></pre></td></tr></table></figure><p>答案显然是可以的。</p><p>这里还有一个小问题，假如我们清空上述的对象类型，那么 <code>key</code> 值是否还存在呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line">m.set(obj, <span class="number">2</span>);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(m); <span class="comment">// &#123;&#123;a: 1&#125; =&gt; 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>这里我们可以理解为，我们定义的 <em>变量obj</em> 指向 <em>内存空间obj</em> ，然后我们定义了一个<code>Set</code>类型，其<code>key</code>值指向 <em>内存空间obj</em> 。</p><p><img data-src="pic8.png" alt></p><p>而后我们又将 <em>变量obj</em> 清空，其原来的 <em>内存空间obj</em> 并没有被销毁，只是改变了其指向。所以 <em>变量obj</em> 的指向并不影响 <code>Set</code> 中 <code>key</code> 的指向，所以才有了上述问题的产生和结果。</p><p><img data-src="pic9.png" alt></p><p>针对于上述问题，我们可以提出来另外一个存储结构类型 <code>weakMap</code>，其key值是会被清空的。</p><h4 id="weakMap"><a href="#weakMap" class="headerlink" title="weakMap"></a>weakMap</h4><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvV2Vha01hcA==">WeakMap-JavaScript | MDN<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><code>WeakMap</code> 对象是一组 <code>key/value</code> (键值对)的集合，其中的键是 <strong>弱引用</strong> 的。其 <code>key</code> 必须是对象，而 <code>value</code> 可以是任意的。</p><p><code>WeakMap</code> 的 key 只能是 <code>Object</code> 类型。 <strong>原始数据类型</strong> 是不能作为 key 的（比如 <code>Symbol</code>）。</p><p>所以我们就可以得出来一个结论了。</p><p><code>Map</code> 的 <code>key</code> 值是强引用类型，在堆内存中存在指向关系，所以不会被垃圾回收机制给清除掉。</p><p>而 <code>weakMap</code> 的 <code>key</code> 值是弱引用类型，会被垃圾回收机制清除掉。</p><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2RlZmluZVByb3BlcnR5">Object.defineProperty() | MDN Web<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p><p>同时，<code>Object.defineProperty()</code> 也是 Vue2.0 中双向绑定的核心实现原理。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;<span class="attr">value</span>: <span class="string">'hello'</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><h3 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h3><p>当该属性的 <code>enumerable</code> 键值为 <code>true</code> 时，该属性才会出现在对象的枚举属性中，<strong>默认为 <code>false</code></strong>。</p><p>在这里我们可以引出来一个问题，假如我们直接打印 <code>obj</code> 变量，会输出变量的属性和值吗？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;<span class="attr">value</span>: <span class="string">'hello'</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以发现，控制台中并未输出 <code>obj</code> 的任何属性。</p><p>原因是通过 <code>Object.defineProperty()</code> 定义的属性，都是<strong>不可枚举</strong>的（<strong><code>enumerable: false</code></strong>）。</p><p>我们可以通过修改 <code>enumerable</code> 来达到枚举的效果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'hello'</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123;name: 'hello'&#125;</span></span><br></pre></td></tr></table></figure><p>这样我们就可以打印出我们定义的属性了。</p><h3 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h3><p>当该属性的 <code>configurable</code> 键值为 <code>true</code> 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除，<strong>默认为 <code>false</code></strong>。</p><p>同样我们可以先思考一个问题，可以通过描述符 <code>delete</code> 删除我们自定义的属性吗？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">    value: <span class="string">'hello'</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">delete</span> obj.name</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123;name: 'hello'&#125;</span></span><br></pre></td></tr></table></figure><p>答案是不可以。</p><p>原因是通过 <code>Object.defineProperty()</code> 定义的属性，都是<strong>不可配置</strong>的（<strong><code>configurable: false</code></strong>）。</p><p>我们可以通过修改 <code>configurable</code> 来达到想要的结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'hello'</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>这样我们定义的属性就被删除了。</p><h3 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h3><p>当该属性的 <code>writable</code> 键值为 <code>true</code> 时，属性的值，也就是上面的 <code>value</code>，才能被<strong>赋值运算符</strong>改变。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'hello'</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">obj.name = <span class="string">'world'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// 'world'</span></span><br></pre></td></tr></table></figure><h3 id="getter-setter"><a href="#getter-setter" class="headerlink" title="getter/setter"></a>getter/setter</h3><p><strong><code>getter</code></strong> ：属性的 getter 函数，如果没有 getter，则为 <code>undefined</code>。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 <code>this</code> 对象（由于继承关系，这里的<code>this</code>并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。</p><p><strong><code>setter</code></strong> ：属性的 setter 函数，如果没有 setter，则为 <code>undefined</code>。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 <code>this</code> 对象。</p><p><strong>（注：如果我们定义了 <code>getter</code>，则不能再定义 <code>writable</code>）</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> other = <span class="string">''</span> <span class="comment">// 额外设置一个变量，用来设置setter</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  <span class="keyword">get</span>()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'--------'</span>);</span><br><span class="line">    <span class="keyword">return</span> other;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(val)&#123;</span><br><span class="line">    other = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">obj.name = <span class="string">'world'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// -------- 'world'</span></span><br></pre></td></tr></table></figure><p><strong>（注：我们需要额外定义一个变量 <em>other</em>）</strong></p><p>Vue的 <strong>数据劫持</strong> ，就是利用的<code>setter/getter</code></p><h4 id="Vue数据劫持"><a href="#Vue数据劫持" class="headerlink" title="Vue数据劫持"></a>Vue数据劫持</h4><p>我们先定义一个需要进行劫持的对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  name: <span class="string">'moxiaoshang'</span>,</span><br><span class="line">  age: <span class="number">26</span>,</span><br><span class="line">  address: &#123;</span><br><span class="line">    location: <span class="string">'昌平'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后我们去观察Vue的源码，一步一步的分析 <strong>数据劫持</strong> 的实现原理。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updata</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'更新视图'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    defineReactive(obj, key, obj[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, value</span>) </span>&#123;</span><br><span class="line">  observer(value)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(val) &#123;</span><br><span class="line">      <span class="keyword">if</span> (val !== value) &#123;</span><br><span class="line">        observer(val)</span><br><span class="line">        updata()</span><br><span class="line">        value = val</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">observer(data);</span><br></pre></td></tr></table></figure><ol><li><p>模拟更新方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updata</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'更新视图'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手写一个模拟更新的方法，使我们在调用 <em>get/set</em> 的时候更直观。</p></li><li><p>使用 <code>observer</code> 函数观察 <em>data</em> 的变化</p><p>将我们需要监听的对象传入函数中。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">oberver(data);</span><br></pre></td></tr></table></figure><p>将 <code>Object.defineProperty</code> 封装成一个可递归调用的函数。</p><p><strong>（注：<code>Object.defineProperty</code> 只能用在 <code>Object</code> 上，数组不识别）</strong></p><p>所以我们第一步需要进行类型判断，将不是 <code>Object</code> 的数据类型返回。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> obj; <span class="comment">// 类型判断</span></span><br></pre></td></tr></table></figure><p>随后，我们需要循环 <em>obj</em> 的每一个属性，并利用 <code>Object.defineProperty</code> 进行 <em>getter</em> 的遍历输出。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      <span class="keyword">get</span>()&#123; <span class="comment">// ... &#125;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样写会有一个问题，那就是整个代码的灵活性不高，所以在Vue源码中，我们会用一个新的函数 <code>defineReactive</code> 将内层代码进行封装。</p><p>这样我们的代码就变成了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  defineReactive(obj, key, obj[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义响应式函数 <code>defineReactive</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续将 <code>Object.defineProperty</code> 封装成一个函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(val) &#123;</span><br><span class="line">    update() <span class="comment">// 在此设置更新视图触发的函数，使其更直观</span></span><br><span class="line">    value = val <span class="comment">// 不需要额外定义全局变量 other</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里我们用到了 <strong>闭包</strong> 的思想，形参 <em>value</em> 被调用，所以不会被销毁。</p><p>所以我们在 <em>set</em> 的时候，不需要额外定义一个全局变量，直接使用 <em>value</em> 即可。</p><p>到这一步，我们就可以直接将 <em>set/get</em> 绑定在对象上了。</p><p><img data-src="pic10.png" alt="chrome控制台"></p><p>通过在控制台中的输出，我们又可以发现一个问题</p><p><img data-src="pic11.png" alt></p><p>内部属性并没有被绑定 <em>get/set</em> ，所以我们需要进行递归处理。</p></li><li><p>处理 <code>Object</code> 内部属性</p><p>非常简单，只需要在处理属性前，也就是响应式函数中进行递归处理即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, value</span>) </span>&#123;</span><br><span class="line">  observer(value) <span class="comment">// 将传入的值进行递归</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，内部属性就被绑定了 get/set 了。</p><p><img data-src="pic12.png" alt></p></li><li><p>直接赋值 <code>Object</code></p><p>接下来，我们再来处理另外一个特殊情况。</p><p>假如我们在属性中，直接赋值一个新的 <code>Object</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data.address = &#123;</span><br><span class="line">  location:<span class="string">'北京'</span></span><br><span class="line">&#125; <span class="comment">// 更新视图</span></span><br><span class="line">data.address.location = <span class="string">'昌平'</span> <span class="comment">// 没有任何输出</span></span><br></pre></td></tr></table></figure><p>这里我们原本应该会触发两次 <em>update函数</em> ，但是最终却只触发了一次。</p><p>因为我们在 <em>address</em> 属性中绑定了一个新的 <code>Object</code> ，而这个对象我们并未进行监听。</p><p>所以我们只需要在 <em>setter</em> 中，添加一个监听函数即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val !== value) &#123; <span class="comment">// 假如值相同，则不需要进行处理</span></span><br><span class="line">      observer(val) <span class="comment">// 进行属性监听</span></span><br><span class="line">      update()</span><br><span class="line">      value = val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>这种方法我们只能劫持 <code>Object</code> 对象类型，如果我们想要劫持 <code>Array</code> 数组，需要使用 <code>Proxy</code> 。</p><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJveHk=">Proxy - JavaScript | MDN<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><code>Proxy</code> 用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如 <em>属性查找</em> 、<em>赋值</em> 、<em>枚举</em> 、 <em>函数调用</em>等）。</p><p>我们来实例化一个 <code>Proxy</code> 对象，看一下实例中包含哪些属性。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(arr, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123; <span class="built_in">console</span>.log(<span class="built_in">arguments</span>) &#125;,</span><br><span class="line">  <span class="keyword">set</span>() &#123; <span class="built_in">console</span>.log(<span class="built_in">arguments</span>) &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(proxy[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>先来看一下 <code>setter</code> 上包含的属性。</p><p><img data-src="pic13.png" alt></p><ul><li>目标源</li><li>传入的key值</li><li>取到的value值</li><li><code>Proxy</code> 类</li></ul><p>再看一下 <code>getter</code></p><p><img data-src="pic14.png" alt></p><ul><li>目标源</li><li>传入的key值</li><li><code>Proxy</code> 类</li></ul><p>这样，我们可以清楚的看到，<code>setter</code> 比 <code>getter</code> 多了一个value值。</p><p>在Vue中，我们希望数组中的数据一变化，视图就会更新。但是 <code>Object.defindProperty</code> 并不支持数组的更新，所以我们通常会用 <code>Proxy</code> 将数组的方法进行重写。（<code>push()</code>,<code>shift()</code>,<code>unshift()</code>,<code>pop()</code> 等等…）</p><h3 id="Vue中的数组"><a href="#Vue中的数组" class="headerlink" title="Vue中的数组"></a>Vue中的数组</h3><p><strong>（注：在Vue3中，已经用 <code>Proxy</code> 代替 <code>Object.defindProperty</code> 来做数据劫持）</strong></p><p>先来看一下完全写法，随后我们一点一点来分析代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'更新视图'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(arr, &#123;</span><br><span class="line">    <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key === <span class="string">'length'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        update();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.push(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol><li><p>模拟更新方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updata</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'更新视图'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手写一个模拟更新的方法，使我们在调用 <em>get/set</em> 的时候更直观。</p></li><li><p><code>Proxy</code> 中的 <code>getter/setter</code> 的返回值</p><p>我们可以将 <code>Proxy</code> 中的属性进行操作，然后在<code>getter/setter</code>中，增加我们自定义的方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(arr, &#123;</span><br><span class="line">  <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">    update();</span><br><span class="line">    <span class="keyword">return</span> target[key] = value;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.push(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>但是这种写法是不推荐的。我们尽量不要去操作原数组，因为数组变化时，可能会调用 <code>push()</code> 、 <code>pop()</code> 等方法，这个时候 <code>key</code> 值可能会出现问题。所以我们需要使用 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVmbGVjdA==">Reflect<i class="fa fa-external-link-alt"></i></span> 进行一下优化。</p><p>优化后的代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(arr, &#123;</span><br><span class="line">  <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">    update();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.push(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>解决 <strong>自定义函数</strong> 错误触发次数的问题</p><p>这个时候我们会发现一个问题，我们自定义的函数被<strong>触发了两次</strong>，但是我们<strong>只使用了一次</strong>方法。</p><p><img data-src="pic15.png" alt></p><p>关于这个问题，原因也很简单。我们打印一下 <code>key</code> 值，就可以轻松发现，我们在修改数组时，不仅添加了值，还触发了一次 <code>length</code>。</p><p>因为数组的长度发生了改变，所以 <code>length</code> 也被传递到了 <code>Proxy</code> 的 <code>setter</code> 中。</p><p>我们可以通过判断 <em>length</em> 属性，来完成这个问题的修复。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (key === <span class="string">'length'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>在 <em>update()</em> 前，加上此判断即可。</p></li></ol><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMTAyMjkxMDgyMTE0OTMxMi8xMDMxNTQ5NTc4NDYyMDgw">箭头函数 | 廖雪峰的官网<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>首先，箭头函数简单来说，就是<strong>函数的缩写</strong>。</p><p><code>x =&gt; x * x</code> 等同于 <code>function (x) { return x * x }</code></p><p>箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连<code>{ ... }</code>和<code>return</code>都省略掉了。还有一种可以包含多条语句，这时候就不能省略<code>{ ... }</code>和<code>return</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">x =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> - x * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果参数不是一个，就需要用括号<code>()</code>括起来：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个参数:</span></span><br><span class="line">(x, y) =&gt; x * x + y * y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数:</span></span><br><span class="line">() =&gt; <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数:</span></span><br><span class="line">(x, y, ...rest) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> i, sum = x + y;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;rest.length; i++) &#123;</span><br><span class="line">        sum += rest[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SyntaxError:</span></span><br><span class="line">x =&gt; &#123; <span class="attr">foo</span>: x &#125;</span><br></pre></td></tr></table></figure><p>因为和函数体的<code>{ ... }</code>有语法冲突，所以要改为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ok:</span></span><br><span class="line">x =&gt; (&#123; <span class="attr">foo</span>: x &#125;)</span><br></pre></td></tr></table></figure><p>这里我们先要明确箭头函数的几个特点</p><ul><li>箭头函数内部的 <code>this</code> 是词法作用域，由上下文确定。</li><li>箭头函数不存在 <code>arguments</code> 属性</li></ul><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><ol><li><p><strong>普通函数</strong>执行，<strong><code>.</code> 前面</strong>是哪个对象，<strong><code>this</code> 就指向</strong>哪个对象。如果 <code>.</code> 前面<strong>没有调用</strong>的对象，那么就<strong>指向<code>window</code></strong> <em>（严格模式下指向<code>undefined</code>）</em></p></li><li><p><strong>构造函数</strong>执行，<code>this</code>是当前类的<strong>实例</strong>。</p></li><li><p><strong>箭头函数</strong>内部的 <code>this</code> 是词法作用域，由<strong>上下文确定</strong>。</p></li><li><p>给元素的某个<strong>事件绑定</strong>函数，函数触发，<strong>this指向当前元素</strong>。</p></li><li><p><code>call/apply/bind</code> 可以改变this的指向。</p></li></ol><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>JS基础</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—前端基础之ES6的数组</title>
    <url>/2021/06/18/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BES6%E7%9A%84%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> r = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function">(<span class="params">total, num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> total + num</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(r);</span><br></pre></td></tr></table></figure><p><code>reduce()</code> 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</p><p><code>reduce()</code> 可以作为一个高阶函数，用于函数的 <em>compose</em>。</p><p><strong>（注：<code>reduce()</code> 对于空数组是不会执行回调函数的。）</strong></p><p>简单来说，<code>reduce</code> 中会接受一个函数，函数的第一次循环，会将数组的前两项传入，并执行相应的计算，并将结果返回。往后的每一次循环，都会将上一次循环的结果传递到第一个参数中。</p><h3 id="initialValue"><a href="#initialValue" class="headerlink" title="initialValue"></a>initialValue</h3><p><em>initialValue</em> ， <code>reduce()</code>的第二个参数，表示传递给函数的 <strong>初始值</strong> 。</p><p>我们可以用它来计算购物车的总价格</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> r = [&#123;<span class="attr">price</span>: <span class="number">100</span>, <span class="attr">count</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">price</span>: <span class="number">200</span>, <span class="attr">count</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">price</span>: <span class="number">300</span>, <span class="attr">count</span>: <span class="number">3</span>&#125;].reduce(<span class="function">(<span class="params">total, num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> total + num.price * num.count</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// 1400</span></span><br></pre></td></tr></table></figure><p>这样我们整个数组默认的第一项就变成了 <em>0</em>，对于处理这种非数字数组非常好用。</p><h3 id="currentIndex"><a href="#currentIndex" class="headerlink" title="currentIndex"></a>currentIndex</h3><p><em>currentIndex</em> , <code>reduce()</code>函数的第三个参数，表示当前 <strong>元素的索引</strong>。</p><p>我们可以用它来将多个数据合并成一个数据。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> keys = [<span class="string">'name'</span>, <span class="string">'age'</span>];</span><br><span class="line"><span class="keyword">let</span> values = [<span class="string">'mxs'</span>, <span class="number">18</span>];</span><br><span class="line"><span class="keyword">let</span> obj = keys.reduce(<span class="function">(<span class="params">memo, cur, index</span>) =&gt;</span> &#123;</span><br><span class="line">  memo[cur] = values[index]</span><br><span class="line">  <span class="keyword">return</span> memo</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;name: 'mxs', age: 18&#125;</span></span><br></pre></td></tr></table></figure><h3 id="模拟compose函数逻辑"><a href="#模拟compose函数逻辑" class="headerlink" title="模拟compose函数逻辑"></a>模拟compose函数逻辑</h3><p><code>compose</code> 函数，函数<strong>调用扁平化</strong>。一个函数的运行结果当作实参传给下一个函数的这种操作，使复杂函数调用看起来更清晰。</p><p>假设我们目前需要实现这样一个功能</p><p>有两个 <code>String</code> 字符串，将其 <em>拼接</em> 并 <em>转换成大写</em> ，最后再 <em>添加特殊字符并展示</em>。</p><p>我们可能会这样解决这个问题。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">'mxs'</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">'nb'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toUpper</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.toUpperCase()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'***'</span> + str + <span class="string">'***'</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(add(toUpper(sum(str1, str2)))) <span class="comment">// ***MXSNB***</span></span><br></pre></td></tr></table></figure><p>我们只模拟了三种功能，整个代码就已经很繁琐了。</p><p>我们为了简化这种繁琐的代码，可以利用 <strong><em>compose函数</em></strong> 对其进行处理。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...fns</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fn = fns.shift();</span><br><span class="line">    <span class="keyword">return</span> fns.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> b(a)</span><br><span class="line">    &#125;, fn(...args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> r = compose(sum, toUpper, add)(str1, str2)</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// ***MXSNB***</span></span><br></pre></td></tr></table></figure><p>我们用一个名为 <strong><em>compose函数</em></strong> 的方法进行 <strong>闭包封装</strong> ，这样会使输出代码看起来更整洁，逻辑更清晰。</p><p>可以利用箭头函数简化 <strong><em>compose函数</em></strong> 代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> fn = fns.shift();</span><br><span class="line">    <span class="keyword">return</span> fns.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b(a), fn(...args))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，我们还可以在实现思路上进行简化。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...fns</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fns.reduceRight(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a(b(...args))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现方式非常难理解，但是也很好解释通，私下可以花点时间看一下。</p><p>然后我们再对其写法进行简化，最终就会变成如下代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> fns.reduceRight(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> a(b(...args)))</span><br></pre></td></tr></table></figure><p>最终就成了一行代码。</p><p>这行代码也被应用在 <strong>redux源码</strong> 中。</p><h3 id="手写实现reduce"><a href="#手写实现reduce" class="headerlink" title="手写实现reduce"></a>手写实现reduce</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduce = <span class="function"><span class="keyword">function</span> (<span class="params">callBack, prev</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">undefined</span>) &#123;</span><br><span class="line">      prev = callBack(<span class="keyword">this</span>[i], <span class="keyword">this</span>[i + <span class="number">1</span>], i + <span class="number">1</span>, <span class="keyword">this</span>);</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prev = callBack(prev, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> r = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function">(<span class="params">a, b, index, current</span>) =&gt;</span> a + b)</span><br><span class="line"><span class="keyword">let</span> r2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function">(<span class="params">a, b, index, current</span>) =&gt;</span> a + b, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(r2); <span class="comment">// 106</span></span><br></pre></td></tr></table></figure><p>实现思路大体就是，利用将传入数组进行循环，执行函数并输出其结果。 假如有第二个参数，就对第二个参数进行处理。 若没有，则直接进行输出处理即可。</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>循环每一项，并对数组中的每一项进行处理，随后将处理后的结果以新数组的方式返回，不会改变原数组。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.map(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newArr, arr) <span class="comment">// [ 2, 4, 6 ] [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>过滤数组，将结果为 <code>false</code> 的项过滤掉，并将结果返回。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item != <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newArr, arr) <span class="comment">// [ 1, 3 ] [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure><h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><p>查看当前数组中是否存在与输出条件一致的结果，如果有则输出 <code>true</code>，反之为 <code>false</code>。 此方法与 <em>every</em> 方法相反</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.some(<span class="function"><span class="params">item</span> =&gt;</span> item == <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="every"><a href="#every" class="headerlink" title="every"></a>every</h2><p>查看当前数组中是否存在与输出条件不一致的结果，如果有则输出 <code>true</code>，反之为 <code>false</code>。 此方法与 <em>some</em> 方法相反</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.every(<span class="function"><span class="params">item</span> =&gt;</span> item == <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>查找数组中与函数条件一致的那一项结果，并将其返回。如果没找到，则返回 <code>undefined</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.find(<span class="function"><span class="params">item</span> =&gt;</span> item == <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h2><p>查找数组中是否包含函数条件的那一项结果，有则输出 <code>true</code>，没有输出 <code>false</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> r = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>JS基础</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—Promise的静态方法(原型方法)</title>
    <url>/2021/08/05/Promise/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Promise%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue 全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><h2 id="Promise静态方法"><a href="#Promise静态方法" class="headerlink" title="Promise静态方法"></a>Promise静态方法</h2><blockquote><p>这篇文章只记录实现，不记录用法。</p></blockquote><p>之前我们封装了一个符合 promise/A+ 规范的类库 <a href="https://mxshang.github.io/2021/06/18/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B1%BB/">Promise</a>，那现在我们来实现一下类库中包含的静态方法。</p><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><p><code>Promise.resolve(100)</code> 等价于 <code>new Promise((resolve,reject)=&gt;{resolve(100)})</code></p><p>实现此方法非常简单，在我们实现好的类库中添加静态方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> resolve(val) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(val)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><p><code>Promise.reject(100)</code> 等价于 <code>new Promise((resolve,reject)=&gt;{reject(100)})</code></p><p>实现此方法也非常简单，在我们实现好的类库中添加静态方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> reject(val) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(val)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-catch"><a href="#Promise-catch" class="headerlink" title="Promise.catch()"></a>Promise.catch()</h3><p><code>Promise.catch()</code> 等价于 <code>.then(null, () =&gt; {})</code></p><p>所以我们可以直接在类库中实现此方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (errorFn) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, errorFn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p>现有如下代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;resolve(<span class="number">100</span>)&#125;)</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;reject(<span class="number">200</span>)&#125;)</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;resolve(<span class="number">300</span>)&#125;)</span><br><span class="line"><span class="keyword">let</span> promise4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;resolve(<span class="number">400</span>)&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.all([promise1, promise2, promise3, promise4]).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason); <span class="comment">// 200</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>有多个<em>Promise实例</em>，当<strong>所有的实例都执行完毕后</strong>，才会执行其<strong>成功结果</strong>。当其中<strong>有一个实例失败</strong>了，<strong>整个Promise.all</strong>的结果都会变成<strong>失败</strong>。</p><p>根据上述结论，我们可以试着实现<code>Promise.all()</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> all(promises) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> results = []</span><br><span class="line">    <span class="keyword">let</span> times = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> processSuccess = <span class="function">(<span class="params">index, val</span>) =&gt;</span> &#123;</span><br><span class="line">      results[index] = val;</span><br><span class="line">      <span class="keyword">if</span> (++times === promises.length) &#123;</span><br><span class="line">        resolve(results)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> p = promises[i];</span><br><span class="line">      <span class="keyword">if</span> (p &amp;&amp; <span class="keyword">typeof</span> p.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        p.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">          processSuccess(i, result)</span><br><span class="line">        &#125;, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        processSuccess(i, p)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p>有多个<em>Promise实例</em>，最先执行完成的实例返回结果后，<strong>整个Promise.race</strong> 就执行完毕了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> race(promises) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> p = promises[i]</span><br><span class="line">      <span class="keyword">if</span> (p &amp;&amp; <span class="keyword">typeof</span> p.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        p.then(resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(p)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h4><p>实际工作中，<code>Promise.race()</code> 可以用来处理 图片加载失败 或者 脚本加载超时 等问题。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrap</span>(<span class="params">p1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> abort;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    abort = reject;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.race([p, p1]); <span class="comment">// 将自定义的错误Promise和自己设定的Promise组合</span></span><br><span class="line">  p2.abort = abort;</span><br><span class="line">  <span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>( ... ) <span class="comment">// 需要处理的Promise异步操作</span></span><br><span class="line"><span class="keyword">let</span> promise = wrap(p1);</span><br><span class="line">promise.then(<span class="function"><span class="params">result</span>=&gt;</span>&#123; ... &#125;,reason=&gt;&#123; ... &#125;) <span class="comment">// 成功或失败的回调</span></span><br><span class="line"><span class="comment">// 超时处理</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  promise.abort(); <span class="comment">// 设定超时时间为60s</span></span><br><span class="line">&#125;, <span class="number">60000</span>);</span><br></pre></td></tr></table></figure><p>封装一个<code>wrap()</code> 函数，接受参数是 Promise 数组。在函数内设定一个属性值 <em>abort<em>，</em>abort</em> 获取值一个新的Promise中的reject方法。</p><p>这样wrap函数中的abort就相当于一个中断按钮。</p><h3 id="Promise-finally"><a href="#Promise-finally" class="headerlink" title="Promise.finally()"></a>Promise.finally()</h3><p>无论Promise成功还是失败，都会执行此方法，他不会接受上一层 <code>.then</code> 方法传递的参数。</p><p>执行过后，代码会继续执行（<em>后续的 <code>.then</code> 方法会继续执行</em>），如果在<code>.finally()</code> 中返回一个新的 Promise，Promise除了<em>失败结果</em>，任何结果都不会被传递下去。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">finally</span>(onFinally) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    <span class="comment">// Promise.resolve 可以等待回调中的Promise执行完毕</span></span><br><span class="line">    value =&gt; <span class="built_in">Promise</span>.resolve(onFinally()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">    reason =&gt; <span class="built_in">Promise</span>.resolve(onFinally()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> reason</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p>有多个<em>Promise实例</em>，当<strong>所有的实例都执行完毕后</strong>，会将<strong>所有结果全部返回</strong>，无论结果是正确还是错误的。所以他不会走<code>.catch</code>方法。</p><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h3><p>有多个<em>Promise实例</em>，如果其中<strong>有一个成功</strong>了，就会走其<strong>成功结果</strong>（<em>取出第一个成功的值</em>），只有<strong>全部失败</strong>了，才会走<strong>失败结果</strong>。</p><h2 id="promisify"><a href="#promisify" class="headerlink" title="promisify"></a>promisify</h2><p>我在上一篇文章中，曾经封装过一个 Promise 的异步函数 <a href="https://mxshang.github.io/2021/07/28/Promise/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Promise%E7%9A%84%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0/">readFile</a> ，当时用了一种很麻烦的封装方式。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">path, encoding</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(path, encoding, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) reject(err)</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">readFile(<span class="string">'./a.txt'</span>, <span class="string">'utf8'</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(result) &#125;)</span><br></pre></td></tr></table></figure><p>那我们有没有什么简单的方法可以使用呢？答案是 有的。</p><p>Node中内置模块 <code>util</code> 中有一个 <code>promisify</code> 方法，可以神奇的将 异步函数 转换成 Promise。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">let</span> readFile = util.promisify(fs.readFile) <span class="comment">// 省略了自己的封装过程</span></span><br><span class="line">readFile(<span class="string">'./a.txt'</span>, <span class="string">'utf8'</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(result) &#125;)</span><br></pre></td></tr></table></figure><p>现在我们可以尝试自己手写一下其 实现原理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">readFile</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      readFile(...args, (err, data) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> reject(err)</span><br><span class="line">        resolve(data)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就手写了一个 <code>promisify</code> 方法。</p><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>Promise</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—前端基础之构造函数与类</title>
    <url>/2021/06/18/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B1%BB/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>用 <code>new</code> 关键字来调用的函数，称为 <strong>构造函数</strong>。</p><p>构造函数中一般有两个属性，一个是 <strong>原型上的属性</strong>，一个是 <strong>实例上的属性</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Animal(<span class="string">'小狗'</span>);</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Animal(<span class="string">'小猫'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a1.arr === a2.arr); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>实例的属性指向不同的存储空间（堆内存），所以输出结果是 <code>false</code>，也就是实例本身的属性。</p><p>通过定义原型上的属性，可以使实例拥有 <strong>原型上的属性</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Animal.prototype.address = &#123;<span class="attr">location</span>:<span class="string">'家里'</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a1.address === a2.address) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h3><p>首先我们要清楚 <strong>类（构造函数）</strong> 、<strong>原型</strong> 和 <strong>constructor</strong> 之间的关系。</p><ul><li>每一个类（函数）都具有 <code>prototype</code>，并且属性值是一个 <code>Object</code></li><li>对象上天生具有一个属性 <code>constructor</code>，指向类本身</li><li>每一个对象（<em>普通对象</em> 、 <em>prototype</em> 、<em>实例</em> 、<em>函数</em> 等 ）都具备 <code>__proto__</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">let</span> f1 = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure><p><code>__proto__</code>：当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<code>__proto__</code> 属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的<code>__proto__</code>属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null，真正的空值。</p><p><code>prototype</code>：包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。任何函数在创建的时候，其实会默认同时创建该函数的 <code>prototype</code> 对象。</p><p><code>constructor</code>：指向该对象的构造函数，每个对象都有构造函数。若对象本身不具备<code>constructor</code>属性，则会通过<code>__proto__</code>向原型链进行查找，找到原型链中constructor后，确定其指向，并进行继承。</p><p><img data-src="pic1.png" alt="原型"></p><p>关于 <strong>原型链查找机制</strong>，我个人是这么理解的。</p><p>首先实例的<code>__proto__</code>会始终指向其构造函数的<code>prototype</code>属性（<code>f.__proto__ === Fn.prototype</code>），构造函数和其所有父类（<code>Fn</code>、<code>Function</code>、<code>Object</code>）均指向<code>Function.prototype</code>，<code>Fn.prototype.__proto__</code>指向的是<code>Object.prototype</code>，而<code>Function.prototype.__proto__</code>指向<code>Object.prototype</code>。<code>Object.prototype.__proto__</code>指向<code>null</code>，就是此原型链的终点。</p><p><img data-src="pic2.png" alt="原型链"></p><p>关于原型链，可以将上图好好理解一下，这张图更直观的表述了<code>prototype</code>、<code>__proto__</code> 和 <code>constructor</code> 之间的关系。没事的时候也可以将他们画一下。</p><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p><strong>构造函数</strong> 其实 <strong>就是类</strong> 的一种。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.eat = <span class="string">'吃肉'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.address = &#123;<span class="attr">location</span>: <span class="string">'山里'</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tiger</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">Tiger.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'说话'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们模拟一个 <em>父类 <code>Animal</code></em> 和一个<em>子类 <code>Tiger</code></em></p><ol><li><p>继承父类实例上的属性</p><p>我们只需要子类上加一个 <code>.call</code> 改变一下 <em>this</em> 的指向即可</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tiger</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">10</span>;</span><br><span class="line">  Animal.call(<span class="keyword">this</span>); <span class="comment">//将父类的this指向子类，使子类继承父类中的属性。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tiger = <span class="keyword">new</span> Tiger();</span><br><span class="line"><span class="built_in">console</span>.log(tiger.eat); <span class="comment">// 吃肉</span></span><br></pre></td></tr></table></figure></li><li><p>继承父类原型上的方法</p><p>上述做法我们只继承了父类实例上的属性，并没有继承其原型上的属性。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(tiger.address); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>这里我们有这么几种解决方案</p><ul><li><p><code>父类.prototype.__proto__ = 子类.prototype</code></p><p>我们的子类和父类的 <code>prototype</code> 分别指向不同的方法和对象。所以我们为了使子类的原型继承父类原型上的方法，可以让子类的 <code>prototype.__proto__</code> 指向父类的 <code>prototype</code> 。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Tiger.prototype.__proto__ = Animal.prototype;</span><br><span class="line"><span class="built_in">console</span>.log(tiger.address); <span class="comment">// &#123;location: '山里'&#125;</span></span><br></pre></td></tr></table></figure><p>这样我们就实现了其中一种继承方法。</p></li><li><p><code>Object.create</code></p><p><code>Object.create()</code>方法创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Tiger.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(tiger.address); <span class="comment">// &#123;location: '山里'&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Object.setPrototypeOf</code></p><p>使用 <code>Object.setPrototypeOf()</code> 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或 <code>null</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(Tiger.prototype, Animal.prototype);</span><br></pre></td></tr></table></figure></li></ul><p>（<em>注：以上方法需要在子类的原型方法绑定前添加。</em>）</p><p>这种方法我们无法向父类传参，只能给子类传参。</p></li></ol><h3 id="ES6中的类（class）"><a href="#ES6中的类（class）" class="headerlink" title="ES6中的类（class）"></a>ES6中的类（class）</h3><p>首先，ES6与ES5类的实现思路相同，同样是利用 <em>原型链</em> 来进行实现的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.eat = <span class="string">'吃肉'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  say() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'say'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是最简单的一种类的实现方式。</p><p>但是 <strong>ES6的类</strong> 和ES5有几点不同</p><ul><li><p>类不可以被当做函数调用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Animal() <span class="comment">// Class constructor Animal cannot be invoked without 'new'</span></span><br></pre></td></tr></table></figure><p>ES6的类需要使用new作为关键字来进行实例化</p><p>同理，如果我们调用原型上的方法，可以将类实例化出来后，直接进行调用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal();</span><br><span class="line">a.__proto__.say(); <span class="comment">// say</span></span><br></pre></td></tr></table></figure><p>（<em>注：ES6规范中，若单独调用原型上的方法，this是不存在的</em>）</p><p>比如我们直接将原型上的方法实例化出来</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暂时修改一下Animal类上的say()方法，测试完后再将此方法改回</span></span><br><span class="line">say() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> say = a.__proto__.say;</span><br><span class="line">say(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>返回的结果就是 <code>undefined</code></p></li><li><p>包含静态方法（ES7中的静态属性）</p><p>ES6中允许类存在 <strong>私有方法（ES7中的私有属性）</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ES6</span></span><br><span class="line">  <span class="keyword">static</span> flag() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'test'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ES7</span></span><br><span class="line">  <span class="keyword">static</span> flag = <span class="string">'test'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Animal.flag()) <span class="comment">// test</span></span><br></pre></td></tr></table></figure><p>（<em>注：在ES6的环境中，不能使用ES7的写法</em>）</p><p>调用时，需要直接用类来进行调用，实例不能进行调用。</p></li><li><p>使用 <code>extends</code> 关键字实现继承</p><p><code>extends</code> 可以直接实现继承。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> Tiger(<span class="string">'老虎'</span>)</span><br><span class="line">t.say(); <span class="comment">// say</span></span><br><span class="line"><span class="built_in">console</span>.log(t.eat); <span class="comment">// 吃肉</span></span><br><span class="line"><span class="built_in">console</span>.log(t.name); <span class="comment">// 老虎</span></span><br></pre></td></tr></table></figure><p>首先，父类的方法与原型 直接继承给了子类。</p><p>随后，传递的值 <em>老虎</em> ，被直接传递给了父类的 <code>constructor</code> ，直接输出了结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123; &#125; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们还有一个需要注意的，父类存在自己的 <code>constructor</code> ，子类不能再定义 <code>constructor</code></p><p>如果想要实现此功能，需要使用关键字 <code>super</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name)&#123; <span class="comment">// Animal.call(this, name) </span></span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（<strong>提示：我们可以去 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFiZWxqcy5jbi8=">babel<i class="fa fa-external-link-alt"></i></span> 上查看ES6中class的实现方式，加深对class的理解</strong>）</p></li></ul><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>JS基础</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
</search>
