<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>学习笔记—Node的基本概念</title>
    <url>/2021/11/02/Node/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="Node的基本概念"><a href="#Node的基本概念" class="headerlink" title="Node的基本概念"></a>Node的基本概念</h2><h3 id="什么是Node？"><a href="#什么是Node？" class="headerlink" title="什么是Node？"></a>什么是Node？</h3><p>Node.js是一个基于 Chrome V8 引擎的JavaScript运行环境(runtime)，Node不是一门语言是让js运行在后端的运行时，并且不包括javascript全集，因为在服务端中不包含DOM和BOM，Node也提供了一些新的模块例如http、fs模块等。Node.js 使用了事件驱动、非阻塞式 I/O 的模型，使其轻量又高效并且Node.js 的包管理器 npm，是全球最大的开源库生态系统。到此我们已经对node有了简单的概念。</p><h3 id="Node的高并发"><a href="#Node的高并发" class="headerlink" title="Node的高并发"></a>Node的高并发</h3><p>Node在处理高并发，I/O密集场景有明显的性能优势。</p><ul><li>高并发，是指在同一时间并发访问服务器。</li><li>I/O密集指的是文件操作、网络操作、数据库,相对的有CPU密集，CPU密集指的是逻辑处理运算、压缩、解压、加密、解密。</li></ul><p>Web主要场景就是接收客户端的请求读取静态资源和渲染界面，所以Node非常适合Web应用的开发。</p><p>说到高并发，肯定就会想起多线程。那么多线程和高并发之间的关系和区别又是什么呢？</p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>首先我们先来了解一下什么是<strong>多线程</strong></p><p><img data-src="pic1.png" alt="多线程示意图"></p><p>后端语言（包括Java、C++等）存在一个<strong>线程池</strong>，每发送一次请求，线程池都会分配一个线程给服务器，用来处理请求，以此类推。因为多线程语言的特点是<strong>同步请求</strong>，所以在多线程发送请求时，可能会存在单个线程阻塞的情况，需要等待当前这个线程的任务处理完毕后，才会释放线程并放回到线程池，方便下一批任务的使用。当前线程数超过线程池最大可分配数量时，可能就会出现等待的情况。</p><ul><li><p><strong>多线程优点</strong>：可以<em>高效高速的处理多个api请求</em>（<em>图片压缩、大量计算 等…</em>），属于<strong>cpu密集型</strong>。</p></li><li><p><strong>多线程缺点</strong>：<em>不安全性</em>，假设我们有多个线程需要对数据库同一个资源进行操作（例如对同一个数据进行修改），就会出现数据安全性的问题 [<em>需要对资源进行加锁操作</em>]。</p></li></ul><p>多线程并非一起做某一件事，靠的是切换上下文（分时），所以<strong>多线程会浪费一些资源</strong>。</p><blockquote><p>关于多线程的具体概念，可以去查阅相关的资料。</p></blockquote><h4 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h4><p><strong>高并发</strong>是单线程的一个概念。</p><ul><li><strong>高并发优点</strong>：不需要开启多个线程，<strong>节省资源</strong>。</li><li><strong>高并发缺点</strong>：<strong>不适合做复杂操作</strong>，如果需要做复杂操作，可以开启子进程。</li></ul><p><em>Node是多线程的，但是其主线程是单线程。所以我们一直都说，Node其实是单线程语言。</em></p><h3 id="同步异步和阻塞非阻塞"><a href="#同步异步和阻塞非阻塞" class="headerlink" title="同步异步和阻塞非阻塞"></a>同步异步和阻塞非阻塞</h3><ul><li><strong>同步</strong>就是在执行某段代码时，代码没有得到返回之前，其他代码无法执行，当得到了返回值后可以继续执行其他代码。</li><li><strong>异步</strong>就是在执行某段代码时，代码不会立即得到返回结果，可以继续执行其他代码，返回值通过回调来获取。</li></ul><blockquote><p>关于<a href="https://mxshang.github.io/2021/10/26/Promise/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Generator%E5%92%8Casync-await/">同步阻塞与异步非阻塞</a>，可以参考我之前的文章。</p></blockquote><h3 id="Node中的EventLoop"><a href="#Node中的EventLoop" class="headerlink" title="Node中的EventLoop"></a>Node中的EventLoop</h3><p><img data-src="pic2.png" alt="Node中EventLoop原理"></p><ul><li>1.我们写的js代码会交给v8引擎进行处理。</li><li>2.代码中可能会调用nodeApi，node会交给libuv库处理</li><li>3.libuv通过阻塞i/o和多线程实现了异步io。</li><li>4.通过事件驱动的方式，将结果放到事件队列中，最终交给我们的应用。</li></ul><hr><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>Node</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—EventLoop事件循环</title>
    <url>/2021/10/30/Promise/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94EventLoop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p><code>EventLoop</code>即事件循环，是指浏览器或 <code>Node</code> 的一种解决 <code>JavaScript</code> 单线程运行时不会阻塞的一种机制，也就是我们经常使用<strong>异步</strong>的原理。</p><p>JavaScript是单线程语言。在当前页面进程中，<em>JS是主线程</em>，而我们常说的异步操作，属于<em>异步线程</em>。</p><p>在这里我们就要先清楚两个名词，<strong>进程</strong> 和 <strong>线程</strong>。</p><ul><li><strong>进程</strong>：是计算机分配任务的最小单位。计算机分配任务时，会按照 <em>进程</em> 进行任务分配。</li><li><strong>线程</strong>：一个进程中包含多个线程。</li></ul><p>对于前端来说，我们接触最多的浏览器，就是由多个进程组成的。</p><h3 id="浏览器进程"><a href="#浏览器进程" class="headerlink" title="浏览器进程"></a>浏览器进程</h3><p>关于浏览器的进程，包含以下几点</p><ul><li><p><strong>每个标签页是一个进程</strong>，他们互不影响。<em>假设我们当前某个页面出现问题卡住了（如死循环等），其他页面不会被当前页面影响。</em></p></li><li><p>每个<strong>浏览器有一个主进程</strong>，也就是我们的用户界面。</p></li><li><p><strong>渲染进程</strong>，每个标签页里，都有一个渲染进程，而 <em>渲染进程中又包含多个进程</em>。</p></li><li><p><strong>网络进程</strong>，发送网络请求以及处理网络请求等。</p></li><li><p><strong>GPU进程</strong> 与 <strong>3D绘制进程</strong>，用来提高页面的加载速度，以及加载复杂的页面特效。</p></li><li><p><strong>第三方插件</strong> 等等…</p></li></ul><h3 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h3><p>渲染进程中包括多个线程</p><ul><li><strong>GUI渲染线程</strong> ，用来对页面进行渲染，也可以叫做 <em>UI渲染线程</em> 。</li><li><strong>JS引擎线程</strong> ，用来加载页面中的JS语法，<em>他和 GUI渲染线程 互斥，也就是说他们两个只能同时加载一个线程</em>。</li><li><strong>事件循环线程</strong> ，也就是 <strong><em>EventLoop</em></strong>。他也是一个独立的线程。<em>JS执行时可能会调用异步方法，而这些方法就是 <strong>EventLoop</strong> 调度执行的。</em></li><li><code>click</code>、<code>setTimeout</code>、<code>ajax</code> 等也是一个独立线程。</li></ul><blockquote><p>搞懂 <strong>EventLoop</strong> ，需要先明白 <strong>堆栈队列</strong> 等概念，后续有时间的话我会更新一篇文章专门对此概念进行详述，感谢大家的关注。</p></blockquote><h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><ul><li><strong>宏任务</strong>：<code>script</code>、<code>ajax请求</code>、<code>ui 渲染</code>、<code>setTimeout</code>、<code>setInterval</code>、<code>postMessage</code>、<code>MessageChannel</code>、<code>SetImmediate</code>、<code>event事件</code></li><li><strong>微任务</strong>：<code>promise</code>、<code>mutationObserver</code>、<code>process.nextTick</code></li></ul><p><img data-src="pic5.png" alt></p><p>JS在执行时，会 <em>自上向下执行</em>，也就是一个 <strong>执行栈</strong>，其中包括 <strong>同步代码 *<em>和 *</em>异步代码</strong>。</p><p>遇到同步代码时，如果是函数会创建一个 <strong>执行上下文</strong>，并放入执行栈中，<em>执行完毕后再出栈</em>。</p><p>遇到异步代码时，我们需要将异步任务放入到一个 <strong>事件队列（或消息队列）</strong>[ <em>队列的特点是先进先出</em> ] 中（内部会调用浏览器提供的Api来将任务放入队列）。</p><p>当我们执行上下文 <em>全部执行完毕</em> 后。<strong>事件队列</strong> 会不停的 <em>对队列进行扫描*，并将队列里 *符合规则（执行完毕或到达时间）</em> 的任务放到执行上下文中并执行。而进行扫描的队列就是 <strong>事件循环线程</strong>，他会对 <em>执行栈</em> 进行<em>循环检测</em> ，当 <em>执行栈为空</em> 的情况下，才会将 <em>符合规则的一个任务放到执行上下文中并执行（注：每次只放入一个）</em>。</p><p>上述的这些异步任务，我们还可以称其为 <strong>宏任务</strong> 。其中包括一些特殊的异步任务，我们可以称为 <strong>微任务</strong>。</p><p>每一次循环检测的时候，都会创建一个 <strong>宏任务队列</strong>（可能会有异步任务，也可能会没有）。而每一个宏任务队列中，都包含一个<strong>微任务队列</strong>。这个微任务队列会在每一次循环检测时，将结果进行清空。</p><p>换言之就是，<strong>每次循环检测会创建一个宏任务队列，这个队列中包含一个微任务队列。宏任务队列清空并输出结果之前，会先对微任务队列进行任务扫描，并清空。然后才会扫描符合规则的宏任务，并将任务放到执行栈中。</strong></p><p>如果存在<strong>UI渲染</strong>等情况，则会在<strong>每次循环的微任务队列清空完毕</strong>后，对页面<strong>进行渲染</strong>。</p><h3 id="代码题"><a href="#代码题" class="headerlink" title="代码题"></a>代码题</h3><p>通过以下几道代码题可以更好的帮我们理解上述概念。</p><ol><li><p><strong>微任务和UI渲染</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.style.background = <span class="string">'red'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">	<span class="built_in">document</span>.body.style.background = <span class="string">'yellow'</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>结果是 <code>1、3、2、yellow</code>，且屏幕不会出现闪烁的情况。</p><p>因为页面的ui渲染会在每次微任务队列清空之后执行，所以不会出现闪烁的情况。</p><p>要验证此结论，可以通过添加一个宏任务事件来进行测试。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.style.background = <span class="string">'red'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">	<span class="built_in">document</span>.body.style.background = <span class="string">'yellow'</span>;</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">document</span>.body.style.background = <span class="string">'green'</span>;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>在多次刷新页面后，可以看到有一个小小的闪烁的情况。</p><p>通过这个测试，我们也可以得到一个更严谨的言论。<strong>UI渲染（GUI渲染）会在达到渲染时机时，才会出现闪烁的情况。</strong></p></li><li><p><strong>事件任务</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">button.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'listener1'</span>);</span><br><span class="line">	<span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'micro task1'</span>))</span><br><span class="line">&#125;)</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'listener2'</span>);</span><br><span class="line">	<span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'micro task2'</span>))</span><br><span class="line">&#125;)</span><br><span class="line">button.click(); <span class="comment">// click1() click2()</span></span><br></pre></td></tr></table></figure><p>结果是 <code>listener1、listener2、micro task1、micro task2</code>。</p><p>首先我们先明确一个概念，那就是 <code>button.click()</code> 相当于将两个事件当成普通函数来执行，也就等价于以下代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'listener1'</span>);</span><br><span class="line">	<span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'micro task1'</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'listener2'</span>);</span><br><span class="line">	<span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'micro task2'</span>))</span><br><span class="line">&#125;</span><br><span class="line">fn1(); fn2()</span><br></pre></td></tr></table></figure><p>所以就可以理解成，先执行 执行上下文 中的函数，再执行事件循环队列中的异步事件。</p><p>但是如果我们不使用<code>button.click()</code>，而是直接使用点击事件呢？</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">button.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(<span class="string">'listener1'</span>);</span></span><br><span class="line"><span class="javascript">	<span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'micro task1'</span>))</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="actionscript">button.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(<span class="string">'listener2'</span>);</span></span><br><span class="line"><span class="javascript">	<span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'micro task2'</span>))</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果是 <code>listener1、micro task1、listener2、micro task2</code> 。</p><p>上述代码中的点击事件属于<strong>宏任务</strong>，所以我们相当于向<strong>宏任务队列</strong>中添加了两个宏任务，根据宏任务队列的执行原则，会先<strong>清空微任务队列</strong>。所以会输出上面的结果。</p></li><li><p><strong>定时器任务</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)</span><br><span class="line">	setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)</span><br><span class="line">	&#125;, <span class="number">0</span>);</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>);</span><br><span class="line">	<span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'Promise2'</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>结果是 <code>Promise1、setTimeout1、Promise2、setTimeout2</code>。</p><p>上述代码在执行时，会先执行最外层的 script脚本（宏任务），会先将外层的<em>微任务Promise1放入微任务队列<em>，</em>宏任务setTimeout1放入宏任务队列*。在 *执行script宏任务</em> 时，会 <em>清空微任务队列</em>，也就是会先将 <strong><em>Promise1</em>输出</strong> 。然后将里面的 <em>宏任务setTimeout2再次放入宏任务队列</em>。这时根据宏任务队列顺序，需要 <em>执行宏任务setTimeout1</em>，将 <strong><em>setTimeout1</em>输出</strong>，然后再将<em>微任务Promise2放入微任务队列</em>。这时 <em>执行宏任务setTimeout2</em>，先 清空微任务队列，<strong>输出Promise2</strong>，随后再将 <strong>setTimeout2输出</strong>。</p></li><li><p><strong>常见面试题</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">    resolve(<span class="number">7</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">async</span> (); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>结果是 <code>1、6、2、3、8、7、4、5</code>。</p><p>思路依旧是根据事件循环线程的输出思路，将宏任务放入宏任务队列，微任务放入微任务队列。宏任务队列执行时，会先清空并输出现有微任务队列中的结果，然后再将宏任务中的结果输出。所以最终结果就是上述结果。</p></li></ol><hr><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>JS基础</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—Generator和async/await</title>
    <url>/2021/10/26/Promise/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Generator%E5%92%8Casync-await/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="同步阻塞与异步非阻塞"><a href="#同步阻塞与异步非阻塞" class="headerlink" title="同步阻塞与异步非阻塞"></a>同步阻塞与异步非阻塞</h2><p>在了解异步的发展之前，我们要先清楚一个概念。那就是 <strong>同步异步与阻塞</strong>。</p><p>在执行代码的过程中，我们可能调用了某个方法。在调用方法时，如果方法没有执行完毕的话，后续的其他代码就无法向下执行，那么我当前的状态就是 <em>阻塞态</em>。 反之，便是 <em>非阻塞态</em>。</p><p>通过上述描述我们清楚了一个道理，那就是 <strong>阻塞与非阻塞指的是调用方的状态</strong>。</p><p>而针对于<em>被调用方</em> ，延迟发送结果我们就可以称为 <em>异步</em> ，而实时发送结果我们就可以称为 <em>同步</em> 。<strong>同步与异步指的是被调用方的状态</strong>。</p><p>所以在实际概念中，<strong>同步非阻塞是可能存在的，<em>但异步阻塞是一定不存在的</em></strong>。</p><p><code>Promise</code> 最早是为了解决异步的回调地狱问题，但是却并没有从根本上解决这个问题，所以我们可以考虑使用 <code>Generator</code>。</p><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTUvMDQvZ2VuZXJhdG9yLmh0bWw=">Generator函数的含义与用法<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><code>Generator</code> 是协程在 ES6 的实现，最大特点就是可以<strong>交出函数的执行权</strong>（即暂停执行）。</p><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>在普通函数中，我们可以利用 <em>return</em> 将函数的控制权交还给被调用的代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n + n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> it = read(<span class="number">1</span>); <span class="comment">// 调用foo函数</span></span><br></pre></td></tr></table></figure><p>函数在执行过程中，如果没有遇到<code>return</code>语句（函数末尾如果没有<code>return</code>，就是隐含的<code>return undefined;</code>），控制权无法交回被调用的代码。</p><p>而我们的 <code>Generator</code> 的语法与函数相似，却又有一些不同。</p><p><code>Generator</code>由<code>function*</code>定义（注意多出的<code>*</code>号），并且，除了<code>return</code>语句，还可以用<code>yield</code>返回多次。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">read</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 生成器，他的执行结果叫做迭代器</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = read();  <span class="comment">// 默认没有执行</span></span><br><span class="line"><span class="comment">// next方法触发回调</span></span><br><span class="line">it.next();</span><br></pre></td></tr></table></figure><p>定义的函数我们可以叫他 <em>生成器</em>，其执行结果我们可以叫做 <em>迭代器</em>。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>关于 <code>Generator</code> 的实现原理，我们可以从 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFiZWxqcy5jbi8=">babel官网<i class="fa fa-external-link-alt"></i></span> 上进行查看。</p><p><img data-src="pic4.png" alt></p><p>通过打印，我们可以很清楚的发现一件事情。 那就是 <code>Genetator</code> 实现原理的核心方法就是 <code>switch...case</code>。</p><p>我们每次在执行代码时，会在遇到 <code>yield</code> 时，将控制权交还给被调用的代码。等待下一次 <code>.next()</code> 方法，再执行后续的代码。</p><h3 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h3><blockquote><p>假设我们现在有一个文件 <em>a.txt<em>，里面有 *b.txt的路径（如 ./b.txt）</em>， 再将此内容作为参数，继续请求路径为 *b.txt</em> 的文件，得到结果 b。</p></blockquote><p>实现上述需求，利用 <code>Generator</code> 可以<strong>解决</strong>我们在请求过程中的<strong>回调地狱问题</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> readFile = util.promisify(fs.readFile);</span><br><span class="line"><span class="comment">// 解决了回调地狱</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">yield</span> readFile(<span class="string">'./a.txt'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    data = <span class="keyword">yield</span> readFile(data, <span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依旧存在回调地狱的问题</span></span><br><span class="line"><span class="keyword">let</span> it = read()</span><br><span class="line"><span class="keyword">let</span> &#123; value &#125; = it.next()</span><br><span class="line">value.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; value &#125; = it.next(data)</span><br><span class="line">    value.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> &#123; value &#125; = it.next(data)</span><br><span class="line">        <span class="built_in">console</span>.log(value) <span class="comment">// b</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们可以发现，发送请求时，我们利用 <code>Generator</code> 对异步请求进行了封装，使代码看起来更整洁了。</p><p>但是在调用的时候，依旧存在回调地狱的问题。</p><p>调用的回调地狱问题，我们可以使用 <a href="https://github.com/tj/co" target="_blank" rel="noopener"><em>tj/co</em></a> 库来进行处理。</p><p>这个库的实现原理，就是实现 <code>async/await</code> 的核心思路。</p><h3 id="co插件"><a href="#co插件" class="headerlink" title="co插件"></a>co插件</h3><p>使用co库，可以直接将 <code>Generator</code> 函数的<strong>最终结果返回</strong>，而且会使代码看起来更简洁优雅。</p><p><code>npm install co</code> 先安装插件库。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"></span><br><span class="line">co(read()).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data) <span class="comment">// b</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>直接会将结果返回。</p><h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">it</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 异步迭代，我们只能使用递归的方式</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> &#123;</span><br><span class="line">                value,</span><br><span class="line">                done</span><br><span class="line">            &#125; = it.next(data);</span><br><span class="line">            <span class="comment">// 如果执行完毕，则将最终结果返回</span></span><br><span class="line">            <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                resolve(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">Promise</span>.resolve(value).then(next, reject)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        next();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>还是参考上面那个例子。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"><span class="keyword">let</span> readFile = util.promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">yield</span> readFile(<span class="string">'./a.txt'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    data = <span class="keyword">yield</span> readFile(data, <span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co(read()).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data) <span class="comment">// b</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>async/await</code> 的实现思路就是 <code>Generator</code>，将 <code>Generator</code> 中的 <em>function</em> * 替换成 <em>async function</em> ，把 <em>yield</em> 替换成 <em>await</em> 。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> readFile(<span class="string">'./a.txt'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    data = <span class="keyword">await</span> readFile(data, <span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data) <span class="comment">// b</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样我们就可以直接输出最终结果。</p><p>可以说 <code>async/await</code> 是目前解决回调地狱问题的最优方案。</p><hr><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>JS基础</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—Promise的静态方法(原型方法)</title>
    <url>/2021/08/05/Promise/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Promise%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue 全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><h2 id="Promise静态方法"><a href="#Promise静态方法" class="headerlink" title="Promise静态方法"></a>Promise静态方法</h2><blockquote><p>这篇文章只记录实现，不记录用法。</p></blockquote><p>之前我们封装了一个符合 promise/A+ 规范的类库 <a href="https://mxshang.github.io/2021/06/18/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B1%BB/">Promise</a>，那现在我们来实现一下类库中包含的静态方法。</p><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><p><code>Promise.resolve(100)</code> 等价于 <code>new Promise((resolve,reject)=&gt;{resolve(100)})</code></p><p>实现此方法非常简单，在我们实现好的类库中添加静态方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> resolve(val) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(val)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><p><code>Promise.reject(100)</code> 等价于 <code>new Promise((resolve,reject)=&gt;{reject(100)})</code></p><p>实现此方法也非常简单，在我们实现好的类库中添加静态方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> reject(val) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(val)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-catch"><a href="#Promise-catch" class="headerlink" title="Promise.catch()"></a>Promise.catch()</h3><p><code>Promise.catch()</code> 等价于 <code>.then(null, () =&gt; {})</code></p><p>所以我们可以直接在类库中实现此方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (errorFn) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, errorFn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p>现有如下代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;resolve(<span class="number">100</span>)&#125;)</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;reject(<span class="number">200</span>)&#125;)</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;resolve(<span class="number">300</span>)&#125;)</span><br><span class="line"><span class="keyword">let</span> promise4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;resolve(<span class="number">400</span>)&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.all([promise1, promise2, promise3, promise4]).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason); <span class="comment">// 200</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>有多个<em>Promise实例</em>，当<strong>所有的实例都执行完毕后</strong>，才会执行其<strong>成功结果</strong>。当其中<strong>有一个实例失败</strong>了，<strong>整个Promise.all</strong>的结果都会变成<strong>失败</strong>。</p><p>根据上述结论，我们可以试着实现<code>Promise.all()</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> all(promises) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> results = []</span><br><span class="line">    <span class="keyword">let</span> times = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> processSuccess = <span class="function">(<span class="params">index, val</span>) =&gt;</span> &#123;</span><br><span class="line">      results[index] = val;</span><br><span class="line">      <span class="keyword">if</span> (++times === promises.length) &#123;</span><br><span class="line">        resolve(results)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> p = promises[i];</span><br><span class="line">      <span class="keyword">if</span> (p &amp;&amp; <span class="keyword">typeof</span> p.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        p.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">          processSuccess(i, result)</span><br><span class="line">        &#125;, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        processSuccess(i, p)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p>有多个<em>Promise实例</em>，最先执行完成的实例返回结果后，<strong>整个Promise.race</strong> 就执行完毕了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> race(promises) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> p = promises[i]</span><br><span class="line">      <span class="keyword">if</span> (p &amp;&amp; <span class="keyword">typeof</span> p.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        p.then(resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(p)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h4><p>实际工作中，<code>Promise.race()</code> 可以用来处理 图片加载失败 或者 脚本加载超时 等问题。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrap</span>(<span class="params">p1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> abort;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    abort = reject;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.race([p, p1]); <span class="comment">// 将自定义的错误Promise和自己设定的Promise组合</span></span><br><span class="line">  p2.abort = abort;</span><br><span class="line">  <span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>( ... ) <span class="comment">// 需要处理的Promise异步操作</span></span><br><span class="line"><span class="keyword">let</span> promise = wrap(p1);</span><br><span class="line">promise.then(<span class="function"><span class="params">result</span>=&gt;</span>&#123; ... &#125;,reason=&gt;&#123; ... &#125;) <span class="comment">// 成功或失败的回调</span></span><br><span class="line"><span class="comment">// 超时处理</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  promise.abort(); <span class="comment">// 设定超时时间为60s</span></span><br><span class="line">&#125;, <span class="number">60000</span>);</span><br></pre></td></tr></table></figure><p>封装一个<code>wrap()</code> 函数，接受参数是 Promise 数组。在函数内设定一个属性值 <em>abort<em>，</em>abort</em> 获取值一个新的Promise中的reject方法。</p><p>这样wrap函数中的abort就相当于一个中断按钮。</p><h3 id="Promise-finally"><a href="#Promise-finally" class="headerlink" title="Promise.finally()"></a>Promise.finally()</h3><p>无论Promise成功还是失败，都会执行此方法，他不会接受上一层 <code>.then</code> 方法传递的参数。</p><p>执行过后，代码会继续执行（<em>后续的 <code>.then</code> 方法会继续执行</em>），如果在<code>.finally()</code> 中返回一个新的 Promise，Promise除了<em>失败结果</em>，任何结果都不会被传递下去。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">finally</span>(onFinally) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    <span class="comment">// Promise.resolve 可以等待回调中的Promise执行完毕</span></span><br><span class="line">    value =&gt; <span class="built_in">Promise</span>.resolve(onFinally()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">    reason =&gt; <span class="built_in">Promise</span>.resolve(onFinally()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> reason</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p>有多个<em>Promise实例</em>，当<strong>所有的实例都执行完毕后</strong>，会将<strong>所有结果全部返回</strong>，无论结果是正确还是错误的。所以他不会走<code>.catch</code>方法。</p><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h3><p>有多个<em>Promise实例</em>，如果其中<strong>有一个成功</strong>了，就会走其<strong>成功结果</strong>（<em>取出第一个成功的值</em>），只有<strong>全部失败</strong>了，才会走<strong>失败结果</strong>。</p><h2 id="promisify"><a href="#promisify" class="headerlink" title="promisify"></a>promisify</h2><p>我在上一篇文章中，曾经封装过一个 Promise 的异步函数 <a href="https://mxshang.github.io/2021/07/28/Promise/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Promise%E7%9A%84%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0/">readFile</a> ，当时用了一种很麻烦的封装方式。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">path, encoding</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(path, encoding, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) reject(err)</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">readFile(<span class="string">'./a.txt'</span>, <span class="string">'utf8'</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(result) &#125;)</span><br></pre></td></tr></table></figure><p>那我们有没有什么简单的方法可以使用呢？答案是 有的。</p><p>Node中内置模块 <code>util</code> 中有一个 <code>promisify</code> 方法，可以神奇的将 异步函数 转换成 Promise。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">let</span> readFile = util.promisify(fs.readFile) <span class="comment">// 省略了自己的封装过程</span></span><br><span class="line">readFile(<span class="string">'./a.txt'</span>, <span class="string">'utf8'</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(result) &#125;)</span><br></pre></td></tr></table></figure><p>现在我们可以尝试自己手写一下其 实现原理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">readFile</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      readFile(...args, (err, data) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> reject(err)</span><br><span class="line">        resolve(data)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就手写了一个 <code>promisify</code> 方法。</p><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>JS基础</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—Promise的介绍与实现</title>
    <url>/2021/07/28/Promise/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Promise%E7%9A%84%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue 全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9vcnBoYW5lZC9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZQ==">Promise|MDN<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><em>Promise 出现的原因</em>：处理多个并发请求，利用 <strong>链式调用</strong> 解决了 <strong>回调地狱</strong> 的问题。</p><p>Promise 存在三种状态，<em>成功（resolve）</em>、<em>失败（reject）</em>和 <em>等待（pending）</em>。</p><p>首先， <em>Promise是一个类</em> ，需要通过关键字 <code>new</code> 来进行实例化。</p><p>Promise接受一个 <code>executor</code> 函数作为执行器，执行器是立即执行的。同时又会接受两个参数作为 <em>成功</em> 和 <em>失败</em> 的回调。</p><p><img data-src="pic2.png" alt></p><p>当我们不去执行 <em>成功</em> 或 <em>失败</em> 的回调，当前这个Promise的状态就会维持在 <em>等待</em> 状态。Promise类会返回一个Promise类，方便下一次调用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(promise) <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>Promise 实例的返回值会根据调用的函数，来判断当前返回的是 <em>成功状态</em> 或 <em>失败状态</em>，并且会将传入参数返回。在调用函数时，若不传入参数，则会返回 <em>undefined</em>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 什么都不传</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(promise); <span class="comment">// Promise &#123; undefined &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功状态</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(promise); <span class="comment">// Promise &#123; 'success' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 失败状态</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'failed'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(promise); <span class="comment">// Promise &#123; &lt;rejected&gt; 'failed' &#125;</span></span><br></pre></td></tr></table></figure><p>每一个Promise的实例上，都有一个 <code>.then</code> 方法输出上一个实例传入的结果。当前实例状态被改变后，将无法再进行改变。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// success</span></span><br><span class="line">&#125;, (error) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样的话，我们就可以总结出来 Promise 的几个特点。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><em>Promise</em> 是一个类，无需考虑兼容性等问题。</li><li><em>Promise</em> 会传入一个函数（<code>executor</code>）作为执行器，此执行器是立即执行的。</li><li><code>executor</code> 提供了两个函数（<code>resolve</code> 和 <code>reject</code>）用来描述当前 <em>Promise</em> 的状态，而当前实例存在三种状态，<em>成功状态</em> 、 <em>失败状态</em> 和 <em>等待状态</em> ，当前实例默认为 <em>等待状态*。如果调用 <code>resolve</code> 则状态变为 *成功状态</em> ，调用 <code>reject</code> 或 发生异常 则状态变为 <em>失败状态</em> 。</li><li><em>Promise</em> 一旦状态变化后，则不能再更改。</li><li>每个 <em>Promise</em> 实例都有一个 <code>.then</code> 方法。</li></ol><p>我们可以根据 <em>Promise</em> 的几个特点，手写一套属于自己的 <em>Promise</em>。</p><h2 id="手写实现-Promises-A-规范"><a href="#手写实现-Promises-A-规范" class="headerlink" title="手写实现 Promises/A+ 规范"></a>手写实现 Promises/A+ 规范</h2><blockquote><p>文档规范 <span class="exturl" data-url="aHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8=">Promises/A+<i class="fa fa-external-link-alt"></i></span></p><p>注：代码内容为连续内容，请依序观看。谢谢</p></blockquote><h3 id="Promise的基础功能"><a href="#Promise的基础功能" class="headerlink" title="Promise的基础功能"></a>Promise的基础功能</h3><p>根据上述特点，我们就可以简单实现出 <em>Promise</em> 的效果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PEDDING = <span class="string">'PEDDING'</span>; <span class="comment">// 等待状态</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'FULFILLED'</span>; <span class="comment">// 成功状态</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'REJECTED'</span>; <span class="comment">// 失败状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123; </span><br><span class="line">    <span class="keyword">this</span>.status = PEDDING; <span class="comment">// 默认状态</span></span><br><span class="line">    <span class="keyword">this</span>.result = <span class="literal">undefined</span>; <span class="comment">// 成功的回调</span></span><br><span class="line">    <span class="keyword">this</span>.reason = <span class="literal">undefined</span>; <span class="comment">// 失败的回调</span></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function">(<span class="params">result</span>) =&gt;</span> &#123; <span class="comment">// 成功 resolve 函数</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === PEDDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = FULFILLED; <span class="comment">// 修改状态</span></span><br><span class="line">        <span class="keyword">this</span>.result = result; <span class="comment">// 添加回调</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123; <span class="comment">// 失败 reject 函数</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === PEDDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = REJECTED; <span class="comment">// 修改状态</span></span><br><span class="line">        <span class="keyword">this</span>.reason = reason; <span class="comment">// 添加回调</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">this</span>.reason = error;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123; <span class="comment">// 成功时调用的方法</span></span><br><span class="line">      onFulfilled(<span class="keyword">this</span>.result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123; <span class="comment">// 失败时调用的方法</span></span><br><span class="line">      onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span></span><br></pre></td></tr></table></figure><p>参考 <span class="exturl" data-url="aHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8=">Promise A+规范<i class="fa fa-external-link-alt"></i></span>，我们可以简单实现出来一版 <em>Promise</em> 类的简易实现版。</p><h3 id="实现Promise的异步功能"><a href="#实现Promise的异步功能" class="headerlink" title="实现Promise的异步功能"></a>实现Promise的异步功能</h3><p>实现 <em>Promise</em> 的异步，我们需要先明确，Promise中只有在触发 <code>.then</code> 方法时（<em>也就是</em><code>resolve</code> 和 <code>reject</code> ），才是异步的。所以我们利用这样一个思路。</p><p>当用户调用 <code>.then</code> 方法时，<em>Promise</em> 此时可能是 <em>等待状态</em>，我们需要先将其暂存起来。后续调用 <code>resolve</code> 和 <code>reject</code> 时，再去触发对应的 <code>onFulfilled</code> 和 <code>onRejected</code></p><p>根据上面的描述，我们可以捕捉到 <em>暂存</em> 和 <em>触发</em> 这两个关键词，那么我们就可以使用 <a href="https://mxshang.github.io/2021/07/12/Promise/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Promise%E4%B9%8B%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/">发布订阅</a> 的设计模式来实现此功能。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.onResolveCallbacks = []; <span class="comment">// 用来存储 成功的回调</span></span><br><span class="line">    <span class="keyword">this</span>.onRejectCallbacks = []; <span class="comment">// 用来存储 失败的回调</span></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === PEDDING) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">this</span>.onResolveCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === PEDDING) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">this</span>.onRejectCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === PEDDING) &#123;</span><br><span class="line">      <span class="keyword">this</span>.onResolveCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        onFulfilled(<span class="keyword">this</span>.result)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">this</span>.onRejectCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span></span><br></pre></td></tr></table></figure><p>建立<em>两个</em> 用来存储回调函数的<em>数组<em>，先将需要执行的函数</em>存储进数组</em> 中。当异步执行完后，再依次 <em>执行数组内存储的函数</em>。</p><h3 id="Promise链式调用"><a href="#Promise链式调用" class="headerlink" title="Promise链式调用"></a>Promise链式调用</h3><p>首先我们先要清楚，Promise的出现解决了哪些问题？</p><ul><li>处理多个并发请求</li><li><strong>链式调用</strong>解决了回调地狱的问题</li></ul><p>回调地狱是什么？ 回调地狱就是我们平时在处理业务代码时，下一个接口的api参数需要用到上一个接口的参数。代码上可能就会出现多级嵌套的情况，导致代码阅读起来十分困难。</p><p>这里我们就需要用到Promise的链式调用，也就是 <code>.then</code> 方法的循环调用，当调用 <code>.then</code> 方法后，会返回一个新的Promise。</p><p>我们先封装一个Promise的异步函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">path, encoding</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(path, encoding, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) reject(err)</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们需要清楚链式调用出现的几种情况。</p><ol><li><p><code>.then</code> 方法返回的是一个 <em>普通值（不是 Promise）</em> 的情况下，会作为外层下一次<code>.then</code> 方法的 <strong>成功结果</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">readFile(<span class="string">'./a.txt'</span>, <span class="string">'utf8'</span>).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">// 1</span></span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>.then</code> 方法执行出错，会走到外层下一次<code>.then</code> 方法的 <strong>失败结果</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">readFile(<span class="string">'./a.txt'</span>, <span class="string">'utf8'</span>).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err); <span class="comment">// Error: error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><em>(注：执行错误需要 <code>throw new Error()</code>，如果直接使用 <code>return new Error()</code>，属于返回一个<strong>Error对象</strong>，会执行下一次的成功结果)</em></p></li><li><p>无论上一次 <code>.then</code> 方法执行结果是 <em>成功</em> 还是 <em>失败</em>，只要返回的是普通值，都会执行下一次<code>.then</code> 方法的 <em>成功结果</em>。</p><p>如<strong>路径</strong>填写错误，Promise会默认执行第一层<code>.then</code>方法的<strong>错误结果</strong>，并<strong>返回undefined</strong>。则下一层的执行结果是<strong>成功结果</strong>，<strong>值为undefined</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路径填写错误</span></span><br><span class="line">readFile(<span class="string">'./a.txt1'</span>, <span class="string">'utf8'</span>).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 相当于在此处 return undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(err); <span class="comment">// 错误原因</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">// undefined</span></span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>如果 <code>.then</code> 方法返回的是一个 Promise 对象，此时会根据 Promise 的结果来处理是成功结果还是失败结果<em>（传入的是成功或失败的内容）</em>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">readFile(<span class="string">`<span class="subst">$&#123;bathPath&#125;</span>a.txt`</span>, <span class="string">'utf8'</span>).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readFile(<span class="string">`<span class="subst">$&#123;bathPath&#125;</span><span class="subst">$&#123;result&#125;</span>`</span>, <span class="string">'utf8'</span>)</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err1'</span>, err);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success2'</span>, result); <span class="comment">// success2 b</span></span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err2'</span>, err); <span class="comment">// error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p><strong>（总结：如果返回的是一个普通值（不是 Promise），就会传递给下一次 <code>.then</code> 方法的成功。如果返回的是一个失败的Promise 或者 抛出异常，就会传递给下一次 <code>.then</code> 方法的失败。）</strong></p><h3 id="手写实现promise链式调用"><a href="#手写实现promise链式调用" class="headerlink" title="手写实现promise链式调用"></a>手写实现promise链式调用</h3><p>根据上述特点和情况，我们每次在 <code>.then</code> 方法调用后都要返回一个新的 Promise 实例。所以我们可以对之前写好的 <code>.then</code> 方法进行相应的修改。</p><p>我们首先来处理 <strong>普通值（不是 Promise）</strong> 的情况。</p><p>（<em>注：在这里我们单独提出来了一个 <code>x</code>，用来进行后续处理</em>）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对 .then() 方法进行改写</span></span><br><span class="line">then(onFulfilled, onRejected) &#123;</span><br><span class="line">	<span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="comment">// 返回一个 promise 实例</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.result)</span><br><span class="line">				resolve(x);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">				reject(e)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">				resolve(x)</span><br><span class="line">			&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">				reject(e)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.status === PEDDING) &#123;</span><br><span class="line">			<span class="keyword">this</span>.onResolveCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.result)</span><br><span class="line">					resolve(x);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">					reject(e)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">this</span>.onRejectCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">					resolve(x)</span><br><span class="line">				&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">					reject(e)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用上述思路对之前的方法进行改造，这样我们就可以对 <strong>普通值</strong> 进行处理。</p><p>上述处理 <strong>普通值</strong> 的情况，我们可以稍加改动，使其可以处理更多的情况。为此我们需要封装一个 <code>resolvePromise()</code> 函数来进行处理。</p><p><code>resolvePromise()</code>需要接受四个参数，分别是 <em>当前实例promise</em> 、 <em>结果x</em> 、<em>成功回调resolve</em> 、 <em>失败回调reject</em>。</p><p>为了可以将当前实力promise作为参数传递，我们需要先用异步方法 <code>setTimeout</code> （其他方法也可以） 将其进行封装。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">then(onFulfilled, onRejected) &#123;</span><br><span class="line">	<span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="comment">// 返回一个 promise 实例</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.result)</span><br><span class="line">          <span class="comment">// 在此处进行封装处理</span></span><br><span class="line">          resolvePromise(promise, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// ... 后面代码进行同样的修改</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以读取到 <em>promise实例</em> 了，下面我们来实现 <code>resolvePromise()</code> 函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (promise === x) &#123;</span><br><span class="line">		<span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'错误'</span>))</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// promise 兼容性</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> x === <span class="string">'object'</span> &amp;&amp; x !== <span class="literal">null</span>) || <span class="keyword">typeof</span> x === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.then <span class="comment">// 通过defineProperty实现时，取值时可能会有异常</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        then.call(x, y =&gt; &#123;</span><br><span class="line">        	resolve(y)</span><br><span class="line">      	&#125;, r =&gt; &#123;</span><br><span class="line">      		reject(r)</span><br><span class="line">      	&#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    	reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 普通值</span></span><br><span class="line">  	resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（<em>注：在工作中，我们可能会调用别人封装的Promise，里面可能会有问题。所以我们还需要进行一步处理，也就是在代码里面加个*</em>锁*<em>，确保代码的严谨性。</em>）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> x === <span class="string">'object'</span> &amp;&amp; x !== <span class="literal">null</span>) || <span class="keyword">typeof</span> x === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> called = <span class="literal">false</span>; <span class="comment">// 定义一个参数</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.then <span class="comment">// 通过defineProperty实现时，取值时可能会有异常</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        then.call(x, y =&gt; &#123;</span><br><span class="line">          <span class="comment">// 在这里进行异常判断</span></span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">					called = <span class="literal">true</span></span><br><span class="line">        	resolve(y)</span><br><span class="line">      	&#125;, r =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">					called = <span class="literal">true</span></span><br><span class="line">      		reject(r)</span><br><span class="line">      	&#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">    	reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就实现了 Promise 的链式调用。</p><h3 id="特殊情况处理"><a href="#特殊情况处理" class="headerlink" title="特殊情况处理"></a>特殊情况处理</h3><h4 id="嵌套Promise"><a href="#嵌套Promise" class="headerlink" title="嵌套Promise"></a>嵌套Promise</h4><p>可能还会出现这种情况，我们在 <code>.then</code> 方法的 <code>resolve</code> 中传入一个 <em>Promise实例</em> ，这种情况我们要如何处理呢？</p><p>如下情况</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	resolve(<span class="number">1</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    	resolve(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        	resolve(<span class="number">200</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>针对上述特殊情况，我们需要继续对之前的<code>resolvePromise()</code> 函数 进行改造。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> x === <span class="string">'object'</span> &amp;&amp; x !== <span class="literal">null</span>) || <span class="keyword">typeof</span> x === <span class="string">'function'</span>) &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        then.call(x, y =&gt; &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        	<span class="comment">// 一直解析，直到不是 Promise 为止</span></span><br><span class="line">					resolvePromise(promise, y, resolve, reject)</span><br><span class="line">      	&#125;, r =&gt; &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">      	&#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键点就是在于<strong>递归调用</strong>，直到其值为<strong>普通值</strong>为止。</p><h4 id="参数穿透"><a href="#参数穿透" class="headerlink" title="参数穿透"></a>参数穿透</h4><p>我们在调用 <code>.then</code>方法 时，还会出现下面这种情况</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	resolve(<span class="number">100</span>)</span><br><span class="line">  <span class="comment">// reject('err')</span></span><br><span class="line">&#125;).then().then().then().then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(result); <span class="comment">// 100</span></span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(err); <span class="comment">// 如果传入，则输出 err</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不传入参数的情况下，结果会一直进行传递，直到输出为止。</p><p>这种参数穿透的情况，我们也需要在代码上进行改造。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">then(onFulfilled, onRejected) &#123;</span><br><span class="line">  <span class="comment">// 对 onFulfilled 进行处理</span></span><br><span class="line">	onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">err</span> =&gt;</span> &#123;<span class="keyword">throw</span> err&#125;; <span class="comment">// 抛出的情况下才会输出错误结果，所以要用 throw</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise测试"><a href="#Promise测试" class="headerlink" title="Promise测试"></a>Promise测试</h2><p>我们可以对自己封装的Promise进行测试，需要用到测试包 <code>promises-aplus-tests</code> 。</p><p>在Promise实例目录下执行如下代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install promises-aplus-tests -g</span><br><span class="line">promises-aplus-tests .&#x2F;promise.js</span><br></pre></td></tr></table></figure><p>他会自动检测我们封装的Promise是否符合 Promise A+ 规范。</p><p>在我们封装的 Promise 文件下添加 <strong>延迟对象</strong> 。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ... 自己封装的 Promise</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要进行测试用的代码</span></span><br><span class="line"><span class="built_in">Promise</span>.deferred = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> dfd = &#123;&#125;;</span><br><span class="line">	dfd.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		dfd.resolve = resolve</span><br><span class="line">		dfd.reject = reject</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> dfd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span></span><br></pre></td></tr></table></figure><p>（<em>注：<code>catch</code> 和 <code>all</code> 等都不属于Promise规范中包含的方法</em>）</p><p>检测完后，我们可以看到其输出结果，根据结果我们可以清楚自己封装的 Promise 是否可以正常运行。</p><p><img data-src="pic3.png" alt></p><p>至此，我们就封装好了一个<em>Promise</em>。</p><h3 id="延迟对象"><a href="#延迟对象" class="headerlink" title="延迟对象"></a>延迟对象</h3><p>用来帮我们减少一次套用，应用并不算广泛。有点类似于代理。</p><p>我们可以对最一开始我们自己的 <em>readFile读取操作</em> 进行封装。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">path, encoding</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dfd = <span class="built_in">Promise</span>.deferred();</span><br><span class="line">	fs.readFile(path, encoding, (err, data) =&gt; &#123;</span><br><span class="line">		<span class="keyword">if</span> (err) <span class="keyword">return</span> dfd.reject(err)</span><br><span class="line">		dfd.resolve(data)</span><br><span class="line">	&#125;)</span><br><span class="line">  <span class="keyword">return</span> dfd.promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>JS基础</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—Promise之高阶函数与设计模式</title>
    <url>/2021/07/12/Promise/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Promise%E4%B9%8B%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue 全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p><strong>高阶函数的特点</strong></p><ul><li>一个函数的参数是一个函数（回调函数就是一种高阶函数）</li><li>一个函数返回一个函数</li></ul><p>我们平时会用到的 <code>reduce</code> 、 <code>map</code> 等方法就是高阶函数。</p><h3 id="before-方法"><a href="#before-方法" class="headerlink" title="before 方法"></a>before 方法</h3><p>假设我们现在有这样一个场景，我们写了一个业务代码，而现在我们需要扩展当前的业务代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// todo something...</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"say"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要在业务代码之前对其进行相应的处理，但是我们如果对业务代码的封装方法进行处理，会使整个代码变得很难处理和复用。</p><p>所以我们需要在 <code>Function.prototype</code> 原型链上绑定一个 <em>before 方法</em> ，使业务代码调用前，先调用一下这个方法。实现对扩展代码进行统一的管理。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    callback();</span><br><span class="line">    <span class="keyword">this</span>(); <span class="comment">// 箭头函数会查找其上级作用域的this指向</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>（注：我们这里的回调函数需要使用箭头函数，原因是箭头函数不存在 this 指向，他会查找上级作用域的 <a href="https://mxshang.github.io/2021/05/28/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BES6-2/">this 指向</a>）</em></p><p>这样我们在使用业务代码前，就可以直接调用其 <strong>回调函数</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> beforeSay = say.before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"before say"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">beforeSay(); <span class="comment">// before say  say</span></span><br></pre></td></tr></table></figure><p>这里符合高阶函数的两个特点，所以其也是一种 <strong>高阶函数</strong>。</p><p>最终达到了我们想要的效果，业务代码 与 扩展代码 实现了分离。</p><p>同时，我们也可以进行传参。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// todo something...</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"say"</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 箭头函数不存在arguments属性，所以我们使用剩余运算符来进行参数传递</span></span><br><span class="line">    callback();</span><br><span class="line">    <span class="keyword">this</span>(...args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> beforeSay = say.before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"before say"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">beforeSay(<span class="string">"hello"</span>, <span class="string">"world"</span>); <span class="comment">// before say  say</span></span><br></pre></td></tr></table></figure><h3 id="after-方法"><a href="#after-方法" class="headerlink" title="after 方法"></a>after 方法</h3><p>假设现在有这样一串代码，我们需要根据传递的参数来判断何时执行函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newFn = after(<span class="number">3</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"after"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">newFn(); <span class="comment">// ...</span></span><br><span class="line">newFn(); <span class="comment">// ...</span></span><br><span class="line">newFn(); <span class="comment">// after</span></span><br></pre></td></tr></table></figure><p>上面我们传入了一个 <em>3</em>，并传入了一个自定义函数。在第三次时，执行了我们的自定义函数。</p><p>接下来我们来完成 <code>after</code> 函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">after</span>(<span class="params">times, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义内容</span></span><br><span class="line">    <span class="keyword">if</span> (--times === <span class="number">0</span>) &#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是利用 <em>闭包</em> 的思想，完成了函数的封装。</p><p>上述代码同样符合 高阶函数 的特点，所以这也是一种<strong>高阶函数</strong>。</p><h3 id="函数柯理化"><a href="#函数柯理化" class="headerlink" title="函数柯理化"></a>函数柯理化</h3><p>首先，我们可以先看一个这样的需求案例。</p><p>假设我们现在需要对几个数进行求和运算，可能平时我们会直接用下面这个函数进行封装。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c + d + e;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>如果我们对传递的参数进行分别传递呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>这个时候，我们就无法再用上面的函数进行运算了。</p><p>我们需要用到一个全新的高阶函数，<strong>函数柯理化</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> curring = <span class="function">(<span class="params">fn, arr = []</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = fn.length;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> concatVal = [...arr, ...args];</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; len) &#123;</span><br><span class="line">      <span class="keyword">return</span> curring(fn, arr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn(...concatVal);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(curring(sum)(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>, <span class="number">5</span>)); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>整体思路其实就是将后续传入的所有参数，拼接成一组完整的参数，最终实现 <strong>函数柯理化</strong>。</p><h3 id="异步并发问题"><a href="#异步并发问题" class="headerlink" title="异步并发问题"></a>异步并发问题</h3><p>假设现在有多个异步并发请求，我们该如何同时获得最终结果呢？</p><p>这里我们会用到 <code>Node</code> 中的 <code>fs</code> 模块。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>); <span class="comment">// file System</span></span><br></pre></td></tr></table></figure><p>这是一个用来 <em>操作文件</em> 的模块。</p><p>随后我们可以在其子目录下创建两个 .txt 文件，随便往里面写一些内容用来测试。</p><p><img data-src="pic1.png" alt></p><p>然后我们来使用 <code>readFile</code> 直接操作文件。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">"./name.txt"</span>, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// zhangsan</span></span><br><span class="line">&#125;);</span><br><span class="line">fs.readFile(<span class="string">"./test.txt"</span>, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// test</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样我们就模拟了两个异步操作。</p><p>现在我们想将这两个结果直接放到一个变量中。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> allVal = &#123;&#125;;</span><br><span class="line">fs.readFile(<span class="string">"./name.txt"</span>, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  allVal.name = data;</span><br><span class="line">&#125;);</span><br><span class="line">fs.readFile(<span class="string">"./test.txt"</span>, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  allVal.test = data;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(allVal); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以看到输出结果是空的，原因是这两个读取操作是异步的。</p><p>那么我们该如何获取这个结果呢？</p><p>我们有如下几个解决方法</p><ol><li>模拟一个 <em>cb</em> 方法并创建一个计数变量 <em>index_，每次执行完一个异步方法后，都在 _index</em> 上加 1。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> cb = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (++index === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(allVal);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">fs.readFile(<span class="string">"./name.txt"</span>, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  allVal.name = data;</span><br><span class="line">  cb();</span><br><span class="line">&#125;);</span><br><span class="line">fs.readFile(<span class="string">"./test.txt"</span>, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  allVal.test = data;</span><br><span class="line">  cb();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样写会有一个问题，就是当我们需要调用的异步方法过多时，会十分难以操作，同时我们还需要创建一个额外的全局变量。</p><ol start="2"><li><p>利用上面的 <em>after 方法</em> 的思路</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">after</span>(<span class="params">times, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (--times === <span class="number">0</span>) &#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cb = after(<span class="number">2</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(allVal);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>利用闭包的思想，将回调函数存储到堆内存里。直到触发时，再输出结果。</p></li></ol><p>这样我们就完成了异步并发问题的处理，最优的选择就是利用闭包的方式，也就是上面的 _第二种_。</p><h2 id="两种设计模式"><a href="#两种设计模式" class="headerlink" title="两种设计模式"></a>两种设计模式</h2><h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>首先，发布订阅模式分为两个部分，分别是 <code>on</code> 和 <code>emit</code>，同时我们还包含一个存储属性 <code>arr</code>。</p><ul><li><strong>on</strong> 就是把一些需要用到的函数维护到一个数组中</li><li><strong>emit</strong> 就是将数组中的函数依次执行</li><li><strong>arr</strong> 用来对函数进行存储</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> event = &#123;</span><br><span class="line">  arr: [], <span class="comment">// 作为一个存储属性</span></span><br><span class="line">  on(fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.arr.push(fn);</span><br><span class="line">  &#125;,</span><br><span class="line">  emit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.arr.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn());</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，我们可以用这种设计模式来进行异步操作了。</p><p>我们还是用上述异步操作的例子。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>); <span class="comment">// file System</span></span><br><span class="line"><span class="keyword">let</span> allVal = &#123;&#125;;</span><br><span class="line">fs.readFile(<span class="string">"./name.txt"</span>, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  allVal.name = data;</span><br><span class="line">&#125;);</span><br><span class="line">fs.readFile(<span class="string">"./test.txt"</span>, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  allVal.test = data;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(allVal);</span><br></pre></td></tr></table></figure><p>下面我们来进行一下异步存储操作，依次输出我们想要的结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绑定输出函数到 on 上，以便我们对结果进行观察</span></span><br><span class="line">event.on(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"读取了一个"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">event.on(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 自定义异步操作全部执行完后，需要输出的结果</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(allVal).length === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(allVal);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 在每个异步函数下绑定 emit</span></span><br><span class="line">fs.readFile(<span class="string">"./name.txt"</span>, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  allVal.name = data;</span><br><span class="line">  event.emit();</span><br><span class="line">&#125;);</span><br><span class="line">fs.readFile(<span class="string">"./test.txt"</span>, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  allVal.test = data;</span><br><span class="line">  event.emit();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 最终输出结果： 读取了一个  读取了一个  &#123; name: 'zhangsan', test: 'test' &#125;</span></span><br></pre></td></tr></table></figure><p>我们可以用这种设计模式的开发思想，完成多种需求的开发。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>首先，这种设计模式既然被称为观察者模式，那么肯定就存在一个 <em>观察者</em> 和一个 <em>被观察者<em>。</em>观察者</em> 需要放到 <em>被观察者</em> 中，<em>被观察者</em> 的状态发生变化，会通知 _观察者_。<strong>（注：Vue 的双向绑定的实现原理使用的就是 _观察者模式_）</strong></p><p>其内部也是基于 <em>发布订阅模式</em> 实现的，所以我们平时会将 <em>观察者模式</em> 和 <em>发布订阅模式</em> 放到一起理解。</p><p>我们可以通过模拟一个宠物与主人之间的状态关系的例子，来进一步理解一下这个设计模式。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 观察者模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 被观察者</span></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.observers = [];</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">"开心"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  attach(o) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.push(o);</span><br><span class="line">  &#125;</span><br><span class="line">  setState(newState) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = newState;</span><br><span class="line">    <span class="keyword">this</span>.observers.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn.update(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 观察者</span></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  update(pets) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"知道了"</span> + pets.name + <span class="string">"的心情十分的"</span> + pets.state);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Subject(<span class="string">"花花"</span>);</span><br><span class="line"><span class="keyword">let</span> master1 = <span class="keyword">new</span> Observer(<span class="string">"大白"</span>);</span><br><span class="line"><span class="keyword">let</span> master2 = <span class="keyword">new</span> Observer(<span class="string">"小白"</span>);</span><br><span class="line">cat.attach(master1);</span><br><span class="line">cat.attach(master2);</span><br><span class="line">cat.setState(<span class="string">"伤心"</span>);</span><br><span class="line"><span class="comment">// 大白知道了花花的心情十分的伤心</span></span><br><span class="line"><span class="comment">// 小白知道了花花的心情十分的伤心</span></span><br></pre></td></tr></table></figure><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>JS基础</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—前端基础之构造函数与类</title>
    <url>/2021/06/18/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B1%BB/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>用 <code>new</code> 关键字来调用的函数，称为 <strong>构造函数</strong>。</p><p>构造函数中一般有两个属性，一个是 <strong>原型上的属性</strong>，一个是 <strong>实例上的属性</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Animal(<span class="string">'小狗'</span>);</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Animal(<span class="string">'小猫'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a1.arr === a2.arr); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>实例的属性指向不同的存储空间（堆内存），所以输出结果是 <code>false</code>，也就是实例本身的属性。</p><p>通过定义原型上的属性，可以使实例拥有 <strong>原型上的属性</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Animal.prototype.address = &#123;<span class="attr">location</span>:<span class="string">'家里'</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a1.address === a2.address) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h3><p>首先我们要清楚 <strong>类（构造函数）</strong> 、<strong>原型</strong> 和 <strong>constructor</strong> 之间的关系。</p><ul><li>每一个类（函数）都具有 <code>prototype</code>，并且属性值是一个 <code>Object</code></li><li>对象上天生具有一个属性 <code>constructor</code>，指向类本身</li><li>每一个对象（<em>普通对象</em> 、 <em>prototype</em> 、<em>实例</em> 、<em>函数</em> 等 ）都具备 <code>__proto__</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">let</span> f1 = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure><p><code>__proto__</code>：当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<code>__proto__</code> 属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的<code>__proto__</code>属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null，真正的空值。</p><p><code>prototype</code>：包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。任何函数在创建的时候，其实会默认同时创建该函数的 <code>prototype</code> 对象。</p><p><code>constructor</code>：指向该对象的构造函数，每个对象都有构造函数。若对象本身不具备<code>constructor</code>属性，则会通过<code>__proto__</code>向原型链进行查找，找到原型链中constructor后，确定其指向，并进行继承。</p><p><img data-src="pic1.png" alt="原型"></p><p>关于 <strong>原型链查找机制</strong>，我个人是这么理解的。</p><p>首先实例的<code>__proto__</code>会始终指向其构造函数的<code>prototype</code>属性（<code>f.__proto__ === Fn.prototype</code>），构造函数和其所有父类（<code>Fn</code>、<code>Function</code>、<code>Object</code>）均指向<code>Function.prototype</code>，<code>Fn.prototype.__proto__</code>指向的是<code>Object.prototype</code>，而<code>Function.prototype.__proto__</code>指向<code>Object.prototype</code>。<code>Object.prototype.__proto__</code>指向<code>null</code>，就是此原型链的终点。</p><p><img data-src="pic2.png" alt="原型链"></p><p>关于原型链，可以将上图好好理解一下，这张图更直观的表述了<code>prototype</code>、<code>__proto__</code> 和 <code>constructor</code> 之间的关系。没事的时候也可以将他们画一下。</p><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p><strong>构造函数</strong> 其实 <strong>就是类</strong> 的一种。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.eat = <span class="string">'吃肉'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.address = &#123;<span class="attr">location</span>: <span class="string">'山里'</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tiger</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">Tiger.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'说话'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们模拟一个 <em>父类 <code>Animal</code></em> 和一个<em>子类 <code>Tiger</code></em></p><ol><li><p>继承父类实例上的属性</p><p>我们只需要子类上加一个 <code>.call</code> 改变一下 <em>this</em> 的指向即可</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tiger</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">10</span>;</span><br><span class="line">  Animal.call(<span class="keyword">this</span>); <span class="comment">//将父类的this指向子类，使子类继承父类中的属性。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tiger = <span class="keyword">new</span> Tiger();</span><br><span class="line"><span class="built_in">console</span>.log(tiger.eat); <span class="comment">// 吃肉</span></span><br></pre></td></tr></table></figure></li><li><p>继承父类原型上的方法</p><p>上述做法我们只继承了父类实例上的属性，并没有继承其原型上的属性。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(tiger.address); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>这里我们有这么几种解决方案</p><ul><li><p><code>父类.prototype.__proto__ = 子类.prototype</code></p><p>我们的子类和父类的 <code>prototype</code> 分别指向不同的方法和对象。所以我们为了使子类的原型继承父类原型上的方法，可以让子类的 <code>prototype.__proto__</code> 指向父类的 <code>prototype</code> 。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Tiger.prototype.__proto__ = Animal.prototype;</span><br><span class="line"><span class="built_in">console</span>.log(tiger.address); <span class="comment">// &#123;location: '山里'&#125;</span></span><br></pre></td></tr></table></figure><p>这样我们就实现了其中一种继承方法。</p></li><li><p><code>Object.create</code></p><p><code>Object.create()</code>方法创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Tiger.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(tiger.address); <span class="comment">// &#123;location: '山里'&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Object.setPrototypeOf</code></p><p>使用 <code>Object.setPrototypeOf()</code> 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或 <code>null</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(Tiger.prototype, Animal.prototype);</span><br></pre></td></tr></table></figure></li></ul><p>（<em>注：以上方法需要在子类的原型方法绑定前添加。</em>）</p><p>这种方法我们无法向父类传参，只能给子类传参。</p></li></ol><h3 id="ES6中的类（class）"><a href="#ES6中的类（class）" class="headerlink" title="ES6中的类（class）"></a>ES6中的类（class）</h3><p>首先，ES6与ES5类的实现思路相同，同样是利用 <em>原型链</em> 来进行实现的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.eat = <span class="string">'吃肉'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  say() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'say'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是最简单的一种类的实现方式。</p><p>但是 <strong>ES6的类</strong> 和ES5有几点不同</p><ul><li><p>类不可以被当做函数调用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Animal() <span class="comment">// Class constructor Animal cannot be invoked without 'new'</span></span><br></pre></td></tr></table></figure><p>ES6的类需要使用new作为关键字来进行实例化</p><p>同理，如果我们调用原型上的方法，可以将类实例化出来后，直接进行调用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal();</span><br><span class="line">a.__proto__.say(); <span class="comment">// say</span></span><br></pre></td></tr></table></figure><p>（<em>注：ES6规范中，若单独调用原型上的方法，this是不存在的</em>）</p><p>比如我们直接将原型上的方法实例化出来</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暂时修改一下Animal类上的say()方法，测试完后再将此方法改回</span></span><br><span class="line">say() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> say = a.__proto__.say;</span><br><span class="line">say(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>返回的结果就是 <code>undefined</code></p></li><li><p>包含静态方法（ES7中的静态属性）</p><p>ES6中允许类存在 <strong>私有方法（ES7中的私有属性）</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ES6</span></span><br><span class="line">  <span class="keyword">static</span> flag() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'test'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ES7</span></span><br><span class="line">  <span class="keyword">static</span> flag = <span class="string">'test'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Animal.flag()) <span class="comment">// test</span></span><br></pre></td></tr></table></figure><p>（<em>注：在ES6的环境中，不能使用ES7的写法</em>）</p><p>调用时，需要直接用类来进行调用，实例不能进行调用。</p></li><li><p>使用 <code>extends</code> 关键字实现继承</p><p><code>extends</code> 可以直接实现继承。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> Tiger(<span class="string">'老虎'</span>)</span><br><span class="line">t.say(); <span class="comment">// say</span></span><br><span class="line"><span class="built_in">console</span>.log(t.eat); <span class="comment">// 吃肉</span></span><br><span class="line"><span class="built_in">console</span>.log(t.name); <span class="comment">// 老虎</span></span><br></pre></td></tr></table></figure><p>首先，父类的方法与原型 直接继承给了子类。</p><p>随后，传递的值 <em>老虎</em> ，被直接传递给了父类的 <code>constructor</code> ，直接输出了结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123; &#125; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们还有一个需要注意的，父类存在自己的 <code>constructor</code> ，子类不能再定义 <code>constructor</code></p><p>如果想要实现此功能，需要使用关键字 <code>super</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name)&#123; <span class="comment">// Animal.call(this, name) </span></span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（<strong>提示：我们可以去 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFiZWxqcy5jbi8=">babel<i class="fa fa-external-link-alt"></i></span> 上查看ES6中class的实现方式，加深对class的理解</strong>）</p></li></ul><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>JS基础</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—前端基础之ES6的数组</title>
    <url>/2021/06/18/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BES6%E7%9A%84%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> r = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function">(<span class="params">total, num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> total + num</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(r);</span><br></pre></td></tr></table></figure><p><code>reduce()</code> 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</p><p><code>reduce()</code> 可以作为一个高阶函数，用于函数的 <em>compose</em>。</p><p><strong>（注：<code>reduce()</code> 对于空数组是不会执行回调函数的。）</strong></p><p>简单来说，<code>reduce</code> 中会接受一个函数，函数的第一次循环，会将数组的前两项传入，并执行相应的计算，并将结果返回。往后的每一次循环，都会将上一次循环的结果传递到第一个参数中。</p><h3 id="initialValue"><a href="#initialValue" class="headerlink" title="initialValue"></a>initialValue</h3><p><em>initialValue</em> ， <code>reduce()</code>的第二个参数，表示传递给函数的 <strong>初始值</strong> 。</p><p>我们可以用它来计算购物车的总价格</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> r = [&#123;<span class="attr">price</span>: <span class="number">100</span>, <span class="attr">count</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">price</span>: <span class="number">200</span>, <span class="attr">count</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">price</span>: <span class="number">300</span>, <span class="attr">count</span>: <span class="number">3</span>&#125;].reduce(<span class="function">(<span class="params">total, num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> total + num.price * num.count</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// 1400</span></span><br></pre></td></tr></table></figure><p>这样我们整个数组默认的第一项就变成了 <em>0</em>，对于处理这种非数字数组非常好用。</p><h3 id="currentIndex"><a href="#currentIndex" class="headerlink" title="currentIndex"></a>currentIndex</h3><p><em>currentIndex</em> , <code>reduce()</code>函数的第三个参数，表示当前 <strong>元素的索引</strong>。</p><p>我们可以用它来将多个数据合并成一个数据。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> keys = [<span class="string">'name'</span>, <span class="string">'age'</span>];</span><br><span class="line"><span class="keyword">let</span> values = [<span class="string">'mxs'</span>, <span class="number">18</span>];</span><br><span class="line"><span class="keyword">let</span> obj = keys.reduce(<span class="function">(<span class="params">memo, cur, index</span>) =&gt;</span> &#123;</span><br><span class="line">  memo[cur] = values[index]</span><br><span class="line">  <span class="keyword">return</span> memo</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;name: 'mxs', age: 18&#125;</span></span><br></pre></td></tr></table></figure><h3 id="模拟compose函数逻辑"><a href="#模拟compose函数逻辑" class="headerlink" title="模拟compose函数逻辑"></a>模拟compose函数逻辑</h3><p><code>compose</code> 函数，函数<strong>调用扁平化</strong>。一个函数的运行结果当作实参传给下一个函数的这种操作，使复杂函数调用看起来更清晰。</p><p>假设我们目前需要实现这样一个功能</p><p>有两个 <code>String</code> 字符串，将其 <em>拼接</em> 并 <em>转换成大写</em> ，最后再 <em>添加特殊字符并展示</em>。</p><p>我们可能会这样解决这个问题。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">'mxs'</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">'nb'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toUpper</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.toUpperCase()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'***'</span> + str + <span class="string">'***'</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(add(toUpper(sum(str1, str2)))) <span class="comment">// ***MXSNB***</span></span><br></pre></td></tr></table></figure><p>我们只模拟了三种功能，整个代码就已经很繁琐了。</p><p>我们为了简化这种繁琐的代码，可以利用 <strong><em>compose函数</em></strong> 对其进行处理。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...fns</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fn = fns.shift();</span><br><span class="line">    <span class="keyword">return</span> fns.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> b(a)</span><br><span class="line">    &#125;, fn(...args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> r = compose(sum, toUpper, add)(str1, str2)</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// ***MXSNB***</span></span><br></pre></td></tr></table></figure><p>我们用一个名为 <strong><em>compose函数</em></strong> 的方法进行 <strong>闭包封装</strong> ，这样会使输出代码看起来更整洁，逻辑更清晰。</p><p>可以利用箭头函数简化 <strong><em>compose函数</em></strong> 代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> fn = fns.shift();</span><br><span class="line">    <span class="keyword">return</span> fns.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b(a), fn(...args))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，我们还可以在实现思路上进行简化。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...fns</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fns.reduceRight(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a(b(...args))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现方式非常难理解，但是也很好解释通，私下可以花点时间看一下。</p><p>然后我们再对其写法进行简化，最终就会变成如下代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> fns.reduceRight(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> a(b(...args)))</span><br></pre></td></tr></table></figure><p>最终就成了一行代码。</p><p>这行代码也被应用在 <strong>redux源码</strong> 中。</p><h3 id="手写实现reduce"><a href="#手写实现reduce" class="headerlink" title="手写实现reduce"></a>手写实现reduce</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduce = <span class="function"><span class="keyword">function</span> (<span class="params">callBack, prev</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">undefined</span>) &#123;</span><br><span class="line">      prev = callBack(<span class="keyword">this</span>[i], <span class="keyword">this</span>[i + <span class="number">1</span>], i + <span class="number">1</span>, <span class="keyword">this</span>);</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prev = callBack(prev, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> r = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function">(<span class="params">a, b, index, current</span>) =&gt;</span> a + b)</span><br><span class="line"><span class="keyword">let</span> r2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function">(<span class="params">a, b, index, current</span>) =&gt;</span> a + b, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(r2); <span class="comment">// 106</span></span><br></pre></td></tr></table></figure><p>实现思路大体就是，利用将传入数组进行循环，执行函数并输出其结果。 假如有第二个参数，就对第二个参数进行处理。 若没有，则直接进行输出处理即可。</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>循环每一项，并对数组中的每一项进行处理，随后将处理后的结果以新数组的方式返回，不会改变原数组。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.map(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newArr, arr) <span class="comment">// [ 2, 4, 6 ] [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>过滤数组，将结果为 <code>false</code> 的项过滤掉，并将结果返回。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item != <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newArr, arr) <span class="comment">// [ 1, 3 ] [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure><h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><p>查看当前数组中是否存在与输出条件一致的结果，如果有则输出 <code>true</code>，反之为 <code>false</code>。 此方法与 <em>every</em> 方法相反</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.some(<span class="function"><span class="params">item</span> =&gt;</span> item == <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="every"><a href="#every" class="headerlink" title="every"></a>every</h2><p>查看当前数组中是否存在与输出条件不一致的结果，如果有则输出 <code>true</code>，反之为 <code>false</code>。 此方法与 <em>some</em> 方法相反</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.every(<span class="function"><span class="params">item</span> =&gt;</span> item == <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>查找数组中与函数条件一致的那一项结果，并将其返回。如果没找到，则返回 <code>undefined</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.find(<span class="function"><span class="params">item</span> =&gt;</span> item == <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h2><p>查找数组中是否包含函数条件的那一项结果，有则输出 <code>true</code>，没有输出 <code>false</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> r = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>JS基础</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—前端基础之ES6(2)</title>
    <url>/2021/05/28/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BES6-2/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><h2 id="Set-Map"><a href="#Set-Map" class="headerlink" title="Set / Map"></a>Set / Map</h2><p><code>Set</code> 和 <code>Map</code> 是两种存储结构。</p><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMTAyMjkxMDgyMTE0OTMxMi8xMDIzMDI0MTgxMTA5NDQw">Map和Set | 廖雪峰的官网<i class="fa fa-external-link-alt"></i></span></p></blockquote><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>首先，<code>Set</code>属于 <em>object</em> 类型（如 <strong>下图</strong> 所示）</p><p><img data-src="pic5.png" alt></p><p><code>new Set([value]) [value]:Array</code></p><p><img data-src="pic6.png" alt></p><p><code>Set</code> 是一组 <strong>key 集合</strong>，但<strong>不存储 value</strong>。由于<strong>key不能重复</strong>，所以，在<code>Set</code>中，<strong>没有重复的key</strong>。</p><p>因此，我们常常利用 <code>Set</code> 来实现 <em>数组去重</em> 。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure><p>通过<code>add(key)</code>方法可以添加元素到<code>Set</code>中，可以重复添加，但不会有效果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// 仍然是 Set &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure><p>通过<code>delete(key)</code>方法可以删除元素</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.delete(<span class="number">3</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 4&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以用以下方法对 <code>Set {1, 2, 3, 4}</code> 进行数组转换处理。</p><ul><li><p>展开运算符</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...s];</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li><li><p>Array.form()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(s);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// // [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li></ul><p>同时，我们可以利用<code>Set</code>实现各种处理，例如实现集合的 <em>并集<em>、</em>交集</em> 和 <em>差集</em> 等。</p><p>假如我们现在有以下两个数组。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr1);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr2);</span><br></pre></td></tr></table></figure><ul><li><p>并集</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...new <span class="built_in">Set</span>([...s1, ...s2])]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(union()); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p>交集</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intersection</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...s1].filter(<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.has(val)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(intersection()); <span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>这里我们用到了 <code>filter</code> 这个高阶函数来进行处理。</p></li><li><p>差集</p><p>差集很好理解，其实就是交集取反，就是 <em>差集</em>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...s1].filter(<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !s2.has(val)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(diff()); <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><code>Map</code> 也属于 <em>Object</em> 类型</p><p><img data-src="pic7.png" alt></p><p><code>Map</code>是一组<strong>键值对</strong>的结构，具有<strong>极快的查找速度</strong>。</p><p>先对 <code>Map</code> 进行初始化</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'a'</span>, <span class="number">1</span>], [<span class="string">'b'</span>, <span class="number">2</span>], [<span class="string">'3'</span>, <span class="number">3</span>]]);</span><br><span class="line">m.get(<span class="string">'b'</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>我们新建一个<code>Map</code> ，需要一个二维数组，或者直接初始化一个空的 <code>Map</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 空Map</span></span><br><span class="line">m.set(<span class="string">'a'</span>, <span class="number">1</span>); <span class="comment">// 添加新的key-value</span></span><br><span class="line">m.set(<span class="string">'b'</span>, <span class="number">2</span>);</span><br><span class="line">m.has(<span class="string">'a'</span>); <span class="comment">// 是否存在key 'a': true</span></span><br><span class="line">m.get(<span class="string">'a'</span>); <span class="comment">// 1</span></span><br><span class="line">m.delete(<span class="string">'a'</span>); <span class="comment">// 删除key 'a'</span></span><br><span class="line">m.get(<span class="string">'a'</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>由于一个 <code>key</code> 只能对应一个 <code>value</code> ，所以，多次对一个key放入value，<strong>后面的值会把前面的值替换掉</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="string">'a'</span>, <span class="number">1</span>);</span><br><span class="line">m.set(<span class="string">'a'</span>, <span class="number">11</span>);</span><br><span class="line">m.get(<span class="string">'a'</span>); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>在这里我们可以思考一个问题，<code>Map</code> 的 <code>key</code> 是否可以是一个对象呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line">m.set(obj, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m);<span class="comment">// &#123;&#123;a: 1&#125; =&gt; 2&#125;</span></span><br></pre></td></tr></table></figure><p>答案显然是可以的。</p><p>这里还有一个小问题，假如我们清空上述的对象类型，那么 <code>key</code> 值是否还存在呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line">m.set(obj, <span class="number">2</span>);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(m); <span class="comment">// &#123;&#123;a: 1&#125; =&gt; 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>这里我们可以理解为，我们定义的 <em>变量obj</em> 指向 <em>内存空间obj</em> ，然后我们定义了一个<code>Set</code>类型，其<code>key</code>值指向 <em>内存空间obj</em> 。</p><p><img data-src="pic8.png" alt></p><p>而后我们又将 <em>变量obj</em> 清空，其原来的 <em>内存空间obj</em> 并没有被销毁，只是改变了其指向。所以 <em>变量obj</em> 的指向并不影响 <code>Set</code> 中 <code>key</code> 的指向，所以才有了上述问题的产生和结果。</p><p><img data-src="pic9.png" alt></p><p>针对于上述问题，我们可以提出来另外一个存储结构类型 <code>weakMap</code>，其key值是会被清空的。</p><h4 id="weakMap"><a href="#weakMap" class="headerlink" title="weakMap"></a>weakMap</h4><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvV2Vha01hcA==">WeakMap-JavaScript | MDN<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><code>WeakMap</code> 对象是一组 <code>key/value</code> (键值对)的集合，其中的键是 <strong>弱引用</strong> 的。其 <code>key</code> 必须是对象，而 <code>value</code> 可以是任意的。</p><p><code>WeakMap</code> 的 key 只能是 <code>Object</code> 类型。 <strong>原始数据类型</strong> 是不能作为 key 的（比如 <code>Symbol</code>）。</p><p>所以我们就可以得出来一个结论了。</p><p><code>Map</code> 的 <code>key</code> 值是强引用类型，在堆内存中存在指向关系，所以不会被垃圾回收机制给清除掉。</p><p>而 <code>weakMap</code> 的 <code>key</code> 值是弱引用类型，会被垃圾回收机制清除掉。</p><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2RlZmluZVByb3BlcnR5">Object.defineProperty() | MDN Web<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p><p>同时，<code>Object.defineProperty()</code> 也是 Vue2.0 中双向绑定的核心实现原理。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;<span class="attr">value</span>: <span class="string">'hello'</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><h3 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h3><p>当该属性的 <code>enumerable</code> 键值为 <code>true</code> 时，该属性才会出现在对象的枚举属性中，<strong>默认为 <code>false</code></strong>。</p><p>在这里我们可以引出来一个问题，假如我们直接打印 <code>obj</code> 变量，会输出变量的属性和值吗？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;<span class="attr">value</span>: <span class="string">'hello'</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以发现，控制台中并未输出 <code>obj</code> 的任何属性。</p><p>原因是通过 <code>Object.defineProperty()</code> 定义的属性，都是<strong>不可枚举</strong>的（<strong><code>enumerable: false</code></strong>）。</p><p>我们可以通过修改 <code>enumerable</code> 来达到枚举的效果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'hello'</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123;name: 'hello'&#125;</span></span><br></pre></td></tr></table></figure><p>这样我们就可以打印出我们定义的属性了。</p><h3 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h3><p>当该属性的 <code>configurable</code> 键值为 <code>true</code> 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除，<strong>默认为 <code>false</code></strong>。</p><p>同样我们可以先思考一个问题，可以通过描述符 <code>delete</code> 删除我们自定义的属性吗？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">    value: <span class="string">'hello'</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">delete</span> obj.name</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123;name: 'hello'&#125;</span></span><br></pre></td></tr></table></figure><p>答案是不可以。</p><p>原因是通过 <code>Object.defineProperty()</code> 定义的属性，都是<strong>不可配置</strong>的（<strong><code>configurable: false</code></strong>）。</p><p>我们可以通过修改 <code>configurable</code> 来达到想要的结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'hello'</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>这样我们定义的属性就被删除了。</p><h3 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h3><p>当该属性的 <code>writable</code> 键值为 <code>true</code> 时，属性的值，也就是上面的 <code>value</code>，才能被<strong>赋值运算符</strong>改变。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'hello'</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">obj.name = <span class="string">'world'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// 'world'</span></span><br></pre></td></tr></table></figure><h3 id="getter-setter"><a href="#getter-setter" class="headerlink" title="getter/setter"></a>getter/setter</h3><p><strong><code>getter</code></strong> ：属性的 getter 函数，如果没有 getter，则为 <code>undefined</code>。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 <code>this</code> 对象（由于继承关系，这里的<code>this</code>并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。</p><p><strong><code>setter</code></strong> ：属性的 setter 函数，如果没有 setter，则为 <code>undefined</code>。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 <code>this</code> 对象。</p><p><strong>（注：如果我们定义了 <code>getter</code>，则不能再定义 <code>writable</code>）</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> other = <span class="string">''</span> <span class="comment">// 额外设置一个变量，用来设置setter</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  <span class="keyword">get</span>()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'--------'</span>);</span><br><span class="line">    <span class="keyword">return</span> other;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(val)&#123;</span><br><span class="line">    other = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">obj.name = <span class="string">'world'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// -------- 'world'</span></span><br></pre></td></tr></table></figure><p><strong>（注：我们需要额外定义一个变量 <em>other</em>）</strong></p><p>Vue的 <strong>数据劫持</strong> ，就是利用的<code>setter/getter</code></p><h4 id="Vue数据劫持"><a href="#Vue数据劫持" class="headerlink" title="Vue数据劫持"></a>Vue数据劫持</h4><p>我们先定义一个需要进行劫持的对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  name: <span class="string">'moxiaoshang'</span>,</span><br><span class="line">  age: <span class="number">26</span>,</span><br><span class="line">  address: &#123;</span><br><span class="line">    location: <span class="string">'昌平'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后我们去观察Vue的源码，一步一步的分析 <strong>数据劫持</strong> 的实现原理。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updata</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'更新视图'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    defineReactive(obj, key, obj[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, value</span>) </span>&#123;</span><br><span class="line">  observer(value)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(val) &#123;</span><br><span class="line">      <span class="keyword">if</span> (val !== value) &#123;</span><br><span class="line">        observer(val)</span><br><span class="line">        updata()</span><br><span class="line">        value = val</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">observer(data);</span><br></pre></td></tr></table></figure><ol><li><p>模拟更新方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updata</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'更新视图'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手写一个模拟更新的方法，使我们在调用 <em>get/set</em> 的时候更直观。</p></li><li><p>使用 <code>observer</code> 函数观察 <em>data</em> 的变化</p><p>将我们需要监听的对象传入函数中。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">oberver(data);</span><br></pre></td></tr></table></figure><p>将 <code>Object.defineProperty</code> 封装成一个可递归调用的函数。</p><p><strong>（注：<code>Object.defineProperty</code> 只能用在 <code>Object</code> 上，数组不识别）</strong></p><p>所以我们第一步需要进行类型判断，将不是 <code>Object</code> 的数据类型返回。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> obj; <span class="comment">// 类型判断</span></span><br></pre></td></tr></table></figure><p>随后，我们需要循环 <em>obj</em> 的每一个属性，并利用 <code>Object.defineProperty</code> 进行 <em>getter</em> 的遍历输出。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      <span class="keyword">get</span>()&#123; <span class="comment">// ... &#125;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样写会有一个问题，那就是整个代码的灵活性不高，所以在Vue源码中，我们会用一个新的函数 <code>defineReactive</code> 将内层代码进行封装。</p><p>这样我们的代码就变成了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  defineReactive(obj, key, obj[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义响应式函数 <code>defineReactive</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续将 <code>Object.defineProperty</code> 封装成一个函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(val) &#123;</span><br><span class="line">    update() <span class="comment">// 在此设置更新视图触发的函数，使其更直观</span></span><br><span class="line">    value = val <span class="comment">// 不需要额外定义全局变量 other</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里我们用到了 <strong>闭包</strong> 的思想，形参 <em>value</em> 被调用，所以不会被销毁。</p><p>所以我们在 <em>set</em> 的时候，不需要额外定义一个全局变量，直接使用 <em>value</em> 即可。</p><p>到这一步，我们就可以直接将 <em>set/get</em> 绑定在对象上了。</p><p><img data-src="pic10.png" alt="chrome控制台"></p><p>通过在控制台中的输出，我们又可以发现一个问题</p><p><img data-src="pic11.png" alt></p><p>内部属性并没有被绑定 <em>get/set</em> ，所以我们需要进行递归处理。</p></li><li><p>处理 <code>Object</code> 内部属性</p><p>非常简单，只需要在处理属性前，也就是响应式函数中进行递归处理即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, value</span>) </span>&#123;</span><br><span class="line">  observer(value) <span class="comment">// 将传入的值进行递归</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，内部属性就被绑定了 get/set 了。</p><p><img data-src="pic12.png" alt></p></li><li><p>直接赋值 <code>Object</code></p><p>接下来，我们再来处理另外一个特殊情况。</p><p>假如我们在属性中，直接赋值一个新的 <code>Object</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data.address = &#123;</span><br><span class="line">  location:<span class="string">'北京'</span></span><br><span class="line">&#125; <span class="comment">// 更新视图</span></span><br><span class="line">data.address.location = <span class="string">'昌平'</span> <span class="comment">// 没有任何输出</span></span><br></pre></td></tr></table></figure><p>这里我们原本应该会触发两次 <em>update函数</em> ，但是最终却只触发了一次。</p><p>因为我们在 <em>address</em> 属性中绑定了一个新的 <code>Object</code> ，而这个对象我们并未进行监听。</p><p>所以我们只需要在 <em>setter</em> 中，添加一个监听函数即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val !== value) &#123; <span class="comment">// 假如值相同，则不需要进行处理</span></span><br><span class="line">      observer(val) <span class="comment">// 进行属性监听</span></span><br><span class="line">      update()</span><br><span class="line">      value = val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>这种方法我们只能劫持 <code>Object</code> 对象类型，如果我们想要劫持 <code>Array</code> 数组，需要使用 <code>Proxy</code> 。</p><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJveHk=">Proxy - JavaScript | MDN<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><code>Proxy</code> 用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如 <em>属性查找</em> 、<em>赋值</em> 、<em>枚举</em> 、 <em>函数调用</em>等）。</p><p>我们来实例化一个 <code>Proxy</code> 对象，看一下实例中包含哪些属性。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(arr, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123; <span class="built_in">console</span>.log(<span class="built_in">arguments</span>) &#125;,</span><br><span class="line">  <span class="keyword">set</span>() &#123; <span class="built_in">console</span>.log(<span class="built_in">arguments</span>) &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(proxy[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>先来看一下 <code>setter</code> 上包含的属性。</p><p><img data-src="pic13.png" alt></p><ul><li>目标源</li><li>传入的key值</li><li>取到的value值</li><li><code>Proxy</code> 类</li></ul><p>再看一下 <code>getter</code></p><p><img data-src="pic14.png" alt></p><ul><li>目标源</li><li>传入的key值</li><li><code>Proxy</code> 类</li></ul><p>这样，我们可以清楚的看到，<code>setter</code> 比 <code>getter</code> 多了一个value值。</p><p>在Vue中，我们希望数组中的数据一变化，视图就会更新。但是 <code>Object.defindProperty</code> 并不支持数组的更新，所以我们通常会用 <code>Proxy</code> 将数组的方法进行重写。（<code>push()</code>,<code>shift()</code>,<code>unshift()</code>,<code>pop()</code> 等等…）</p><h3 id="Vue中的数组"><a href="#Vue中的数组" class="headerlink" title="Vue中的数组"></a>Vue中的数组</h3><p><strong>（注：在Vue3中，已经用 <code>Proxy</code> 代替 <code>Object.defindProperty</code> 来做数据劫持）</strong></p><p>先来看一下完全写法，随后我们一点一点来分析代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'更新视图'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(arr, &#123;</span><br><span class="line">    <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key === <span class="string">'length'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        update();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.push(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol><li><p>模拟更新方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updata</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'更新视图'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手写一个模拟更新的方法，使我们在调用 <em>get/set</em> 的时候更直观。</p></li><li><p><code>Proxy</code> 中的 <code>getter/setter</code> 的返回值</p><p>我们可以将 <code>Proxy</code> 中的属性进行操作，然后在<code>getter/setter</code>中，增加我们自定义的方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(arr, &#123;</span><br><span class="line">  <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">    update();</span><br><span class="line">    <span class="keyword">return</span> target[key] = value;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.push(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>但是这种写法是不推荐的。我们尽量不要去操作原数组，因为数组变化时，可能会调用 <code>push()</code> 、 <code>pop()</code> 等方法，这个时候 <code>key</code> 值可能会出现问题。所以我们需要使用 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVmbGVjdA==">Reflect<i class="fa fa-external-link-alt"></i></span> 进行一下优化。</p><p>优化后的代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(arr, &#123;</span><br><span class="line">  <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">    update();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.push(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>解决 <strong>自定义函数</strong> 错误触发次数的问题</p><p>这个时候我们会发现一个问题，我们自定义的函数被<strong>触发了两次</strong>，但是我们<strong>只使用了一次</strong>方法。</p><p><img data-src="pic15.png" alt></p><p>关于这个问题，原因也很简单。我们打印一下 <code>key</code> 值，就可以轻松发现，我们在修改数组时，不仅添加了值，还触发了一次 <code>length</code>。</p><p>因为数组的长度发生了改变，所以 <code>length</code> 也被传递到了 <code>Proxy</code> 的 <code>setter</code> 中。</p><p>我们可以通过判断 <em>length</em> 属性，来完成这个问题的修复。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (key === <span class="string">'length'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>在 <em>update()</em> 前，加上此判断即可。</p></li></ol><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMTAyMjkxMDgyMTE0OTMxMi8xMDMxNTQ5NTc4NDYyMDgw">箭头函数 | 廖雪峰的官网<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>首先，箭头函数简单来说，就是<strong>函数的缩写</strong>。</p><p><code>x =&gt; x * x</code> 等同于 <code>function (x) { return x * x }</code></p><p>箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连<code>{ ... }</code>和<code>return</code>都省略掉了。还有一种可以包含多条语句，这时候就不能省略<code>{ ... }</code>和<code>return</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">x =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> - x * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果参数不是一个，就需要用括号<code>()</code>括起来：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个参数:</span></span><br><span class="line">(x, y) =&gt; x * x + y * y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数:</span></span><br><span class="line">() =&gt; <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数:</span></span><br><span class="line">(x, y, ...rest) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> i, sum = x + y;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;rest.length; i++) &#123;</span><br><span class="line">        sum += rest[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SyntaxError:</span></span><br><span class="line">x =&gt; &#123; <span class="attr">foo</span>: x &#125;</span><br></pre></td></tr></table></figure><p>因为和函数体的<code>{ ... }</code>有语法冲突，所以要改为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ok:</span></span><br><span class="line">x =&gt; (&#123; <span class="attr">foo</span>: x &#125;)</span><br></pre></td></tr></table></figure><p>这里我们先要明确箭头函数的几个特点</p><ul><li>箭头函数内部的 <code>this</code> 是词法作用域，由上下文确定。</li><li>箭头函数不存在 <code>arguments</code> 属性</li></ul><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><ol><li><p><strong>普通函数</strong>执行，<strong><code>.</code> 前面</strong>是哪个对象，<strong><code>this</code> 就指向</strong>哪个对象。如果 <code>.</code> 前面<strong>没有调用</strong>的对象，那么就<strong>指向<code>window</code></strong> <em>（严格模式下指向<code>undefined</code>）</em></p></li><li><p><strong>构造函数</strong>执行，<code>this</code>是当前类的<strong>实例</strong>。</p></li><li><p><strong>箭头函数</strong>内部的 <code>this</code> 是词法作用域，由<strong>上下文确定</strong>。</p></li><li><p>给元素的某个<strong>事件绑定</strong>函数，函数触发，<strong>this指向当前元素</strong>。</p></li><li><p><code>call/apply/bind</code> 可以改变this的指向。</p></li></ol><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>JS基础</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记—前端基础之ES6(1)</title>
    <url>/2021/05/10/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BES6-1/</url>
    <content><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><h2 id="let、const和var的区别"><a href="#let、const和var的区别" class="headerlink" title="let、const和var的区别"></a>let、const和var的区别</h2><p><code>let</code>、<code>const</code> 和 <code>var</code>都是用来定义变量的，那它们有什么区别呢？</p><h3 id="var的特点"><a href="#var的特点" class="headerlink" title="var的特点"></a>var的特点</h3><ol><li><p>对<strong>全局变量</strong>造成污染</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">//1</span></span><br></pre></td></tr></table></figure></li><li><p>存在<strong>变量提升</strong>机制</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"a"</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>var</code>可以被<strong>重复声明</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>var</code>的作用域只有<strong>全局作用域</strong>和<strong>函数作用域</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="let的特点"><a href="#let的特点" class="headerlink" title="let的特点"></a>let的特点</h3><ol><li><p>不可以被重复声明</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure></li><li><p>存在块级作用域</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// 0 1 2 ... 8 9</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>如果使用<code>var</code>进行定义，则会全部输出10</em></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// 10</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>暂时性死区</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// Cannot access 'a' before initialization</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>因为ES6在定义变量的时候，会把同名的变量定义为两个变量</em>（如 <strong>下图</strong> 所示）<br><img data-src="pic1.png" alt></p></li><li><p>不会绑定在 <code>window</code> 上</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.info(<span class="built_in">window</span>.a);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="const的特点"><a href="#const的特点" class="headerlink" title="const的特点"></a>const的特点</h3><p><code>const</code>是<strong>不可变的量</strong>，也就是<strong>常量</strong>。</p><ol><li><p><code>const</code>定义的变量不可以对其值进行修改。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line">PI = <span class="number">3.15</span>; <span class="comment">// Assignment to constant variable.</span></span><br></pre></td></tr></table></figure></li><li><p><code>const</code>可以修改同一地址（堆内存）中的值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line">a.b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// &#123;b: 2&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>在解构中，有下面两部分参与：</p><p><strong>解构的源</strong>：解构赋值表达式的右边部分。</p><p><strong>解构的目标</strong>：解构赋值表达式的左边部分。</p><h3 id="数组解构-Array"><a href="#数组解构-Array" class="headerlink" title="数组解构(Array)"></a>数组解构(Array)</h3><ol><li><p>基本使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// c = 3</span></span><br></pre></td></tr></table></figure></li><li><p>嵌套使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, [[b], c]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// c = 3</span></span><br></pre></td></tr></table></figure></li><li><p>可以忽略未定义变量</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, , b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 3</span></span><br></pre></td></tr></table></figure></li><li><p>非完全解构</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b] = []; <span class="comment">// a = 1, b = undefined</span></span><br></pre></td></tr></table></figure></li><li><p>字符串解构等</p><p><em>在数组的解构中，解构的目标若为<strong>可遍历对象</strong>，皆可进行解构赋值。</em></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line"><span class="comment">// a = 'h'</span></span><br><span class="line"><span class="comment">// b = 'e'</span></span><br><span class="line"><span class="comment">// c = 'l'</span></span><br><span class="line"><span class="comment">// d = 'l'</span></span><br><span class="line"><span class="comment">// e = 'o'</span></span><br></pre></td></tr></table></figure></li><li><p>解构默认值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">2</span>] = [<span class="literal">undefined</span>]; <span class="comment">// a = 2</span></span><br></pre></td></tr></table></figure><p><em>当解构模式有匹配结果，且匹配结果是 <code>undefined</code> 时，会触发默认值作为返回结果。</em></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [];     <span class="comment">// a = 3, b = 3</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>];    <span class="comment">// a = 1, b = 1</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// a = 1, b = 2</span></span><br></pre></td></tr></table></figure><ul><li>a 与 b 匹配结果为 <em>undefined</em> ，触发默认值：<strong>a = 3; b = a =3</strong></li><li>a 正常解构赋值，匹配结果为 <em>a = 1*，b 匹配结果 *undefined</em> ，触发默认值：<strong>b = a =1</strong></li><li>a 与 b 正常解构赋值，匹配结果为 <strong>a = 1，b = 2</strong></li></ul></li><li><p>扩展运算符</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = [2, 3]</span></span><br></pre></td></tr></table></figure><p>扩展运算符，又叫 <strong>展开运算符</strong> 或 <strong>剩余运算符</strong>。可以利用扩展运算符，对数组进行合并。（如 <strong>下图</strong> 所示）![(pic2.png)</p></li></ol><h3 id="对象解构-Object"><a href="#对象解构-Object" class="headerlink" title="对象解构(Object)"></a>对象解构(Object)</h3><ol><li><p>基本使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line"><span class="comment">// foo = 'aaa'</span></span><br><span class="line"><span class="comment">// bar = 'bbb'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">baz</span> : foo &#125; = &#123; <span class="attr">baz</span> : <span class="string">'ddd'</span> &#125;;</span><br><span class="line"><span class="comment">// foo = 'ddd'</span></span><br></pre></td></tr></table></figure></li><li><p>可嵌套/可忽略</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [<span class="string">'hello'</span>, &#123;<span class="attr">y</span>: <span class="string">'world'</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line"><span class="comment">// x = 'hello'</span></span><br><span class="line"><span class="comment">// y = 'world'</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [<span class="string">'hello'</span>, &#123;<span class="attr">y</span>: <span class="string">'world'</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123;  &#125;] &#125; = obj;</span><br><span class="line"><span class="comment">// x = 'hello'</span></span><br></pre></td></tr></table></figure></li><li><p>非完全解构</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [&#123;<span class="attr">y</span>: <span class="string">'world'</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [&#123; y &#125;, x ] &#125; = obj;</span><br><span class="line"><span class="comment">// x = undefined</span></span><br><span class="line"><span class="comment">// y = 'world'</span></span><br></pre></td></tr></table></figure></li><li><p>解构默认值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a = <span class="number">10</span>, b = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// a = 3; b = 5;</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span>: aa = <span class="number">10</span>, <span class="attr">b</span>: bb = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// aa = 3; bb = 5;</span></span><br></pre></td></tr></table></figure></li><li><p>扩展运算符</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, b, ...rest&#125; = &#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span>&#125;;</span><br><span class="line"><span class="comment">// a = 10</span></span><br><span class="line"><span class="comment">// b = 20</span></span><br><span class="line"><span class="comment">// rest = &#123;c: 30, d: 40&#125;</span></span><br></pre></td></tr></table></figure><p>在ES6中，我们可以通过 <em>扩展运算符</em> 实现很多应用，例如 <strong>深拷贝和浅拷贝</strong>。</p><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS93M2Nub3RlL2RlY29uc3RydWN0aW9uLWFzc2lnbm1lbnQuaHRtbA==">ES6 解构赋值 | 菜鸟教程<i class="fa fa-external-link-alt"></i></span></p></blockquote></li></ol><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p><strong>深拷贝</strong>：拷贝后与原数组无关，会使 <em>拷贝后的数组</em> 在堆中指向一个新的内存空间。<br><strong>浅拷贝</strong>：拷贝后与原数组有关，<em>新数组</em> 与 <em>原数组</em> 指向同一个堆内存。</p><p><img data-src="pic3.png" alt></p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><p><code>Object.assign()</code> 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 <code>Object.assign()</code> 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: &#123;<span class="attr">name</span>: <span class="string">"mxs"</span>, <span class="attr">age</span>: <span class="number">26</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line">obj2.a.name = <span class="string">"zd"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a.name); <span class="comment">// zd</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat()"></a>Array.prototype.concat()</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, &#123;</span><br><span class="line">  name: <span class="string">'mxs'</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.concat();    </span><br><span class="line">arr2[<span class="number">2</span>].name = <span class="string">'zd'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, &#123;name:'zd'&#125;]</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-slice"><a href="#Array-prototype-slice" class="headerlink" title="Array.prototype.slice()"></a>Array.prototype.slice()</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, &#123;</span><br><span class="line">  name: <span class="string">'mxs'</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.slice();</span><br><span class="line">arr2[<span class="number">2</span>].name = <span class="string">'zd'</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, &#123;name:'zd'&#125;]</span></span><br></pre></td></tr></table></figure><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><p>扩展运算符只能拷贝一层 <strong>对象</strong> / <strong>数组</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">'zd'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">age</span>:&#123;<span class="attr">count</span>:<span class="number">26</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> allObj = &#123;...school,...my&#125;;</span><br><span class="line">obj2.age.count = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(allObj); <span class="comment">// &#123;&#123;name: "zd", age: &#123;count: 100&#125;&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;age: &#123;count: 100&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>可以发现两个对象都改变了，这就是只实现了 <strong>浅拷贝</strong>。</p><p>如果想要实现 <strong>深拷贝</strong>，会十分的麻烦。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">'zd'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">age</span>:&#123;<span class="attr">count</span>:<span class="number">26</span>&#125;,<span class="attr">name</span>:<span class="string">'mxs'</span>&#125;;</span><br><span class="line"><span class="comment">// 把原来的my放到新的对象中，用一个新的对象age将原始的age也拷贝一份</span></span><br><span class="line"><span class="keyword">let</span> newObj2 = &#123;...obj2,<span class="attr">age</span>:&#123;...obj2.age&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> allObj = &#123;...obj1,...newObj2&#125;;</span><br><span class="line">obj2.age.count = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(allObj); <span class="comment">// &#123;&#123;name: "mxs", age: &#123;count: 26&#125;&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;&#123;name: "mxs", age: &#123;count: 100&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><h4 id="JSON-parse-JSON-stringify"><a href="#JSON-parse-JSON-stringify" class="headerlink" title="JSON.parse(JSON.stringify())"></a>JSON.parse(JSON.stringify())</h4><p>用<code>JSON.stringify</code>将对象转成JSON字符串，再用<code>JSON.parse()</code>把字符串解析成对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">'zd'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">age</span>:&#123;<span class="attr">count</span>:<span class="number">26</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> allObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(&#123;...obj1,...obj2&#125;));</span><br><span class="line">obj2.age.count = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(allObj); <span class="comment">// &#123;name: 'zd', age: &#123; count: 26 &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>但是需要注意的是，<code>(JSON.stringify([value]))</code> 这种方法虽然可以实现深拷贝，但是却不能拷贝 <code>Function</code>、<code>undefined</code> 和 <code>Symbol</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">'zd'</span>, <span class="attr">age</span>:&#123;&#125;, <span class="attr">count</span>:<span class="number">26</span>, <span class="attr">a</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="attr">b</span>:<span class="literal">null</span>, <span class="attr">c</span>:<span class="literal">undefined</span>, <span class="attr">d</span>:<span class="built_in">Symbol</span>(<span class="string">'zd'</span>)&#125;</span><br><span class="line"><span class="keyword">let</span> allObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(allObj); <span class="comment">// &#123;name: 'zd', age: &#123;&#125;, count: 26, b: null&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以看到，最终被拷贝下来的，只有 <code>String</code> 、<code>Object</code>、 <code>Number</code> 和 <code>Null</code> 这几种数据类型。</p><h4 id="lodash库"><a href="#lodash库" class="headerlink" title="lodash库"></a>lodash库</h4><p>我们可以通过 <strong>loadash库</strong>中的 <code>cloneDeep</code> 方法来实现深克隆。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">   a: <span class="number">1</span>,</span><br><span class="line">   b: &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">   c: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> cloneObj = _.cloneDeep(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj.a.b === cloneObj.a.b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="手写实现深拷贝"><a href="#手写实现深拷贝" class="headerlink" title="手写实现深拷贝"></a>手写实现深拷贝</h4><p>我们先来看一下完整的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj,hash = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (hash.has(obj)) <span class="keyword">return</span> hash.get(obj);</span><br><span class="line">  <span class="keyword">let</span> cloneObj = <span class="keyword">new</span> obj.constructor;</span><br><span class="line">  hash.set(obj, cloneObj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.hasOwnProperty.call(obj, key)) &#123;</span><br><span class="line">      cloneObj[key] = deepClone(obj[key], hash);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">'zd'</span>, <span class="attr">age</span>:&#123;&#125;, <span class="attr">count</span>:<span class="number">26</span>, <span class="attr">a</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="attr">b</span>:<span class="literal">null</span>, <span class="attr">c</span>:<span class="literal">undefined</span>, <span class="attr">d</span>:<span class="built_in">Symbol</span>(<span class="string">'zd'</span>)&#125;</span><br><span class="line"><span class="keyword">let</span> allObj = deepClone(obj);</span><br><span class="line"><span class="built_in">console</span>.log(allObj); <span class="comment">// &#123;name: 'zd', age: &#123;&#125;, count: 26, a: [Function: a], b: null, c: undefined, d: Symbol(zd)&#125;</span></span><br></pre></td></tr></table></figure><p>如果我们想要手写一套深克隆的函数方法，我们需要先搞懂其实现思路。</p><p>简单来说，其实现思路就是 <em>类型判断</em>，<em>克隆数据类型</em>， <em>遍历循环</em>，最后进行 <em>结果输出</em>。</p><ol><li><p>我们先思考，为什么要进行 <em>类型判断</em> ？</p><p>在此之前，我们需要先要清楚 <strong>数据类型判断方式</strong>。</p><ul><li>typeof</li><li>instanceof / constructor</li><li>Object.prototype.toString.call([value])</li></ul><p>然后我们再来看代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果obj是null或者undefined，则直接将结果返回</span></span><br><span class="line"><span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line"><span class="comment">// 如果obj是基础数据类型或者函数，则直接将结果返回(也就是说，函数不需要进行任何处理)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> obj;</span><br><span class="line"><span class="comment">// 如果obj不是对象或数组，则直接将结果返回</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br></pre></td></tr></table></figure><p>通过上面的代码，我们可以发现，剩下的只有两种数据类型 <strong>数组</strong> 和 <strong>对象</strong>。</p><p>那么我们就清楚了，进行 <em>类型判断</em> ，其目的就是为了将需要进行深克隆数据类型筛选出来。</p></li><li><p>然后再思考，如何 <em>克隆</em> 传入对象的 <em>数据类型</em> 呢？</p><p>最常用的方案如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cloneObj = <span class="built_in">Object</span>.prototype.toString.call(obj) === [<span class="string">'Object Array'</span>] ? [] : &#123;&#125;;</span><br></pre></td></tr></table></figure><p>但是这种写法太麻烦了，我们有更简单的实现方案。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// obj不是数组就是对象，将其进行克隆</span></span><br><span class="line"><span class="keyword">let</span> cloneObj = <span class="keyword">new</span> obj.constructor;</span><br></pre></td></tr></table></figure><p>根据 <strong>原型链</strong> 的指向原则，我们可以利用上述方案来创建一个新的数据类型对象。(如 <strong>下图</strong> 所示)</p><p><img data-src="pic4.png" alt></p><p><em>克隆数据类型</em> 的目的，其实就是为了进行下一步的 <em>遍历循环</em>。</p></li><li><p>接着，我们要进行 <em>遍历循环</em> 。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.hasOwnProperty.call(obj, key)) &#123;</span><br><span class="line">    <span class="comment">// 进行递归，实现深克隆</span></span><br><span class="line">    cloneObj[key] = deepClone(obj[key]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 <code>forin</code> 进行循环，在对象复制前，我们都会将值进行递归，再次执行当前方法，判断是否有深层属性。直到递归至没有深层属性为止。</p><p>然后将结果赋值给<code>cloneObj</code>，最后把结果进行输出。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> cloneObj</span><br></pre></td></tr></table></figure><p>但是这种写法还存在一个问题，就是无法进行 <strong>循环引用</strong> 。</p><p>如果要进行循环引用，就会发生 <strong>栈内存溢出</strong> 的情况。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:&#123;<span class="attr">name</span>:<span class="string">'mxs'</span>&#125;&#125;</span><br><span class="line">obj.b = obj;</span><br><span class="line"><span class="keyword">let</span> allObj = deepClone(obj);</span><br><span class="line">obj.a.name = <span class="string">'zd'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure><p>为了处理这种问题的发生，我们还需要在进行一步操作。</p></li><li><p>最后，我们需要对 <strong>异常情况</strong> 进行处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br></pre></td></tr></table></figure><p>设定一个 <code>WeakMap</code> 数据类型（关于 <code>WeakMap</code> ，可以 参考文献 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvV2Vha01hcA==">WeakMap-JavaScript | MDN<i class="fa fa-external-link-alt"></i></span> ，或查看我的另一篇博客 <a href="https://mxshang.github.io/2021/05/28/学习笔记—前端基础之ES6-2/#weakMap">ES6 | weakMap</a>）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(hash.has(obj)) <span class="keyword">return</span> hash.get(obj);</span><br><span class="line">hash.set(obj, cloneObj);</span><br></pre></td></tr></table></figure><p>如果是 <code>Object</code>，我们就将其放到 <code>weakMap</code> 中。如果在拷贝之前，这个 <code>Object</code> 就已经存在了，我们就直接将其返回。</p><p>至此，我们的 <strong>深拷贝</strong> 就完成了。</p></li></ol><p>我们可以通过这种思路，写出很多种 <strong>深克隆</strong> 的方案。</p><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
        <tag>JS基础</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
</search>
