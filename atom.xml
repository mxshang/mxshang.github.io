<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>莫小尚</title>
  
  <subtitle>摸鱼上尉大白酱</subtitle>
  <link href="https://mxshang.github.io/atom.xml" rel="self"/>
  
  <link href="https://mxshang.github.io/"/>
  <updated>2022-03-03T07:32:48.697Z</updated>
  <id>https://mxshang.github.io/</id>
  
  <author>
    <name>MXShang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Vue2源码】Vue核心应用之响应式原理</title>
    <link href="https://mxshang.github.io/2022/02/27/Vue%E6%A0%B8%E5%BF%83%E5%BA%94%E7%94%A8/Vue2%E6%BA%90%E7%A0%81-Vue%E6%A0%B8%E5%BF%83%E5%BA%94%E7%94%A8%E4%B9%8B%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <id>https://mxshang.github.io/2022/02/27/Vue%E6%A0%B8%E5%BF%83%E5%BA%94%E7%94%A8/Vue2%E6%BA%90%E7%A0%81-Vue%E6%A0%B8%E5%BF%83%E5%BA%94%E7%94%A8%E4%B9%8B%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</id>
    <published>2022-02-27T02:29:22.000Z</published>
    <updated>2022-03-03T07:32:48.697Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Vue2.0全家桶的系统学习，其中包括<strong>Vue源码分析</strong>、<strong>Vue-Router的使用和原理</strong>、<strong>Vuex的用法和原理</strong>、<strong>Vue-ssr</strong>、如何进行<strong>单元测试</strong> 和 一些常见的<strong>Vue面试题</strong>。</p></blockquote><hr><blockquote><p>参考官网 <span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcvaW5kZXguaHRtbA==">vue.js官网<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>Vue2全家桶的使用，已经是一个老生常谈的话题了。</p><p>具体的使用可以去参考Vue的官网，上面有很详细的用法介绍。</p><p>这篇文章中，我们会详细介绍一下<strong>Vue的响应式原理</strong>。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们先要进行前期的准备工作。</p><p>首先我们要先创建一个默认的 <code>package.json</code> 文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>配置文件创建好后，我们就需要使用 <span class="exturl" data-url="aHR0cHM6Ly93d3cucm9sbHVwanMuY29tLw==">rollup<i class="fa fa-external-link-alt"></i></span> 来进行代码编译了。</p><h3 id="Rollup环境配置"><a href="#Rollup环境配置" class="headerlink" title="Rollup环境配置"></a>Rollup环境配置</h3><p>因为 <em>webpack</em> 太大了，不方便做测试，所以我们会使用 <span class="exturl" data-url="aHR0cHM6Ly93d3cucm9sbHVwanMuY29tLw==">rollup<i class="fa fa-external-link-alt"></i></span> 作为打包工具。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucm9sbHVwanMuY29tLw==">rollup<i class="fa fa-external-link-alt"></i></span> 简单的来说，就是一个 <em>JavaScript 模块打包器</em>，可以将小块代码编译成大块复杂的代码。<span class="exturl" data-url="aHR0cHM6Ly93d3cucm9sbHVwanMuY29tLw==">rollup.js<i class="fa fa-external-link-alt"></i></span> 更专注于Javascript类库打包 <em>（开发应用时使用 Webpack，开发库时使用 Rollup）</em>。</p><p>随后我们来安装 <code>rollup</code> 及其相应的插件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @babel/preset-env @babel/core rollup rollup-plugin-babel rollup-plugin-serve cross-env -d</span><br></pre></td></tr></table></figure><ul><li><strong>rollup</strong>：我们需要用到的模块打包工具。</li><li><strong>rollup-plugin-babel</strong>：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFiZWxqcy5jbi8=">babel<i class="fa fa-external-link-alt"></i></span> 与 <code>rollup</code> 之间互通的插件，用来对ES6代码进行转义与编译。</li><li><strong>@babel/preset-env</strong> / <strong>@babel/core</strong>：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFiZWxqcy5jbi8=">babel<i class="fa fa-external-link-alt"></i></span> 需要用到的关联插件。</li><li><strong>rollup-plugin-serve</strong>：可以用来启动本地服务。</li><li><strong>cross-env</strong>：运行<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFpZHUuY29tL3M/d2Q96Leo5bmz5Y+wJnRuPTI0MDA0NDY5X29lbV9kZyZyc3ZfZGw9Z2hfcGxfc2xfY3Nk">跨平台<i class="fa fa-external-link-alt"></i></span>设置和使用环境变量的脚本。</li></ul><p>随后我们来创建一个 <code>rollup.config.js</code> 文件作为它的配置文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">"rollup-plugin-babel"</span>;</span><br><span class="line"><span class="keyword">import</span> serve <span class="keyword">from</span> <span class="string">"rollup-plugin-serve"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  input: <span class="string">"./src/index.js"</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    format: <span class="string">"umd"</span>, <span class="comment">// 模块化类型</span></span><br><span class="line">    file: <span class="string">"dist/umd/vue.js"</span>,</span><br><span class="line">    name: <span class="string">"Vue"</span>, <span class="comment">// 打包后的全局变量的名字</span></span><br><span class="line">    sourcemap: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    babel(&#123;</span><br><span class="line">      exclude: <span class="string">"node_modules/**"</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    process.env.ENV === <span class="string">"development"</span></span><br><span class="line">      ? serve(&#123;</span><br><span class="line">          open: <span class="literal">true</span>,</span><br><span class="line">          openPage: <span class="string">"/public/index.html"</span>,</span><br><span class="line">          port: <span class="number">3000</span>,</span><br><span class="line">          contentBase: <span class="string">""</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">      : <span class="literal">null</span>,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>配置 <code>.babelrc</code> 文件用来处理babel。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"@babel/preset-env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>package.json</code> 中进行如下配置。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "build:dev": "rollup -c",</span><br><span class="line">  "serve": "cross-env ENV=development rollup -c -w"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终项目结构如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|-- vue-test</span><br><span class="line">    |-- .babelrc</span><br><span class="line">    |-- package-lock.json</span><br><span class="line">    |-- package.json</span><br><span class="line">    |-- rollup.congfig.js</span><br><span class="line">    |-- public</span><br><span class="line">    |   |-- index.html</span><br><span class="line">    |-- src</span><br><span class="line">        |-- index.js</span><br></pre></td></tr></table></figure><p>这样我们的配置文件就创建完毕了。</p><h2 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h2><p>使用过Vue后都知道，Vue在作为插件库使用的时候，都是以 <em>option Api</em> （<em>选项进行配置</em>）的形式进行创建的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            a: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所以我们第一步要实现的，就是将 <strong>Vue作为构造函数，并导出</strong>。</p><h3 id="导出构造函数"><a href="#导出构造函数" class="headerlink" title="导出构造函数"></a>导出构造函数</h3><p>先来看一下完整的导出代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;initMixin&#125; <span class="keyword">from</span> <span class="string">'./init'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._init(options);</span><br><span class="line">&#125;</span><br><span class="line">initMixin(Vue); <span class="comment">// 给原型上新增_init方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue;</span><br></pre></td></tr></table></figure><p><em>（注：这里我们不采用ES6类的写法，因为它会将类或函数作为一个整体进行编写。我们希望它可以分散到不同的文件中，所以采用ES5构造函数的方式进行定义，这样在结构上看起来会更清晰。）</em></p><ol><li><p>将创建的<strong>构造函数导出</strong>，他会接收一个<strong>参数options</strong>。</p><p><code>options</code> 其实就是我们传入的属性，包括 <code>el</code> 、 <code>data</code> 、<code>method</code> 等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(options); <span class="comment">// 实例化时传入的"属性"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue;</span><br></pre></td></tr></table></figure></li><li><p>新增 <strong>_init方法</strong>。</p><p><code>options</code> 接收到了，我们就需要通过传入的参数对 <em>Vue进行初始化</em>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._init(options);</span><br><span class="line">&#125;</span><br><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue;</span><br></pre></td></tr></table></figure><p>我们再对其进行 <em>解耦</em>，可以得到一个<strong>入口方法</strong>，可以使所有文件进行<strong>初始化操作</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;initMixin&#125; <span class="keyword">from</span> <span class="string">'./init'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._init(options);</span><br><span class="line">&#125;</span><br><span class="line">initMixin(Vue); <span class="comment">// 给原型上新增_init方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue;</span><br></pre></td></tr></table></figure></li></ol><p>这个文件的最终目的是向 <em>Vue原型上扩展方法</em>。</p><p>很明显，我们目前就需要对 <strong>Vue进行初始化</strong>。</p><h3 id="初始化Vue状态"><a href="#初始化Vue状态" class="headerlink" title="初始化Vue状态"></a>初始化Vue状态</h3><p>上一步中，我们创建了 <em>Vue类</em>，并传入了 <em>options参数</em>。</p><p>这一步我们就要将需要的内容封装成插件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;initState&#125; <span class="keyword">from</span> <span class="string">'./state'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span>(<span class="params">Vue</span>)</span>&#123;</span><br><span class="line">    Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> vm  = <span class="keyword">this</span>; <span class="comment">// 获取当前实例</span></span><br><span class="line">        vm.$options = options</span><br><span class="line">        <span class="comment">// 初始化状态</span></span><br><span class="line">        initState(vm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>options</code> 参数被传入了 <code>vm.$options</code> 中，这样我们就可以使用 <code>$options</code> 来进行配置。</p><p><code>initState</code> 就是对状态进行初始化，也就是对数据进行一个<strong>初始化的劫持</strong> （<em>当我改变数据时，视图也会更新</em>）。</p><h3 id="根据属性进行初始化操作"><a href="#根据属性进行初始化操作" class="headerlink" title="根据属性进行初始化操作"></a>根据属性进行初始化操作</h3><p><strong>Vue并不完全属于MVVM，它只是参考的MVVM。</strong>其包含的 <code>$ref</code> 就可以说明这个问题，它还是可以操作DOM的。</p><p>现在我们就需要对不同的属性进行不同的数据劫持。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span>(<span class="params">vm</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> opts = vm.$options;</span><br><span class="line">    <span class="keyword">if</span>(opts.props)&#123;</span><br><span class="line">        initProps(vm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opts.methods)&#123;</span><br><span class="line">        initMethod(vm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opts.data)&#123;</span><br><span class="line">        <span class="comment">// 初始化data</span></span><br><span class="line">        initData(vm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opts.computed)&#123;</span><br><span class="line">        initComputed(vm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opts.watch)&#123;</span><br><span class="line">        initWatch(vm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initMethod</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initWatch</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>根据不同的传入参数，来进行不同的处理。</p><p>下面我们就可以对拆分出来的不同属性，进行不同的初始化处理了。</p><h2 id="数据-data-初始化"><a href="#数据-data-初始化" class="headerlink" title="数据(data)初始化"></a>数据(data)初始化</h2><p>扩展 <code>initData</code> 方法之前，我们需要先知道一个概念。什么是<strong>数据劫持</strong>？</p><p><strong>数据劫持</strong> 就是通过 <code>Object.defineProperty</code> 来重写对象的 <code>getter</code> 和 <code>setter</code> 。数据更新时视图会发生改变，而视图改变时数据也会跟着更新，从而达到一个 视图和数据 互相影响的效果。</p><p>这种设计模式我们又称呼它为 <a href="https://mxshang.github.io/2021/07/12/Promise/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Promise%E4%B9%8B%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/">观察者模式</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;observe&#125; <span class="keyword">from</span> <span class="string">'./observer/index.js'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span>(<span class="params">vm</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> data = vm.$options.data;</span><br><span class="line">    data = vm._data = <span class="keyword">typeof</span> data === <span class="string">'function'</span> ? data.call(vm) : data; <span class="comment">// 如果data是函数，改变其this指向</span></span><br><span class="line">    observe(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>vm._data</code> 的作用其实就是为了让 <em>vm实例上可以获取到 data 的值</em>。</p><p>下面我们就来利用<strong>观察者模式</strong>，实现Vue中的<strong>数据劫持</strong>。</p><h3 id="对象属性劫持"><a href="#对象属性劫持" class="headerlink" title="对象属性劫持"></a>对象属性劫持</h3><p><strong>数据劫持</strong>主要包括 <em>对象劫持</em> 和 <em>数组劫持</em> 两个方面。</p><p>先来看一下<strong>对象属性劫持</strong>的完整代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 观测值</span></span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.walk(value);</span><br><span class="line">  &#125;</span><br><span class="line">  walk(data) &#123;</span><br><span class="line">    <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(data);</span><br><span class="line">    keys.forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">      defineReactive(data, key, data[key]);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, value</span>) </span>&#123;</span><br><span class="line">  observe(value);</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue == value) <span class="keyword">return</span>;</span><br><span class="line">      observe(newValue);</span><br><span class="line">      value = newValue;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> data !== <span class="string">"object"</span> || data == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observer(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>导出 <code>observe</code> 函数，进行类型判断。</p><p>当前文件，我们只处理 <code>Object</code> 类型的值。不是 <code>Object</code> 类型的值不做处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> data !== <span class="string">"object"</span> || data == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observer(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>完善 <code>Observer</code> 类，让对象上的所有属性依次进行观测。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 观测值</span></span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.walk(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 让对象上的所有属性依次进行观测</span></span><br><span class="line">  walk(data) &#123;</span><br><span class="line">    <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(data); <span class="comment">// 获取对象上的key值</span></span><br><span class="line">    keys.forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">      defineReactive(data, key, data[key]);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义 <code>defineReactive</code> 函数，用来对 <code>Object.defineProperty</code> 进行封装。</p><p>循环调用 <code>observe</code> 函数，保证当前对象内的所有属性都被监听到。</p><p>（<em>注：主要是为了处理 *</em>{a:{a:{a:1}}}** 这种情况。但这样处理，层级越深性能越差，所以在 Vue3 中将其替换成了 <code>proxy</code> 进行处理。*）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, value</span>) </span>&#123;</span><br><span class="line">  observe(value);</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue == value) <span class="keyword">return</span>;</span><br><span class="line">      observe(newValue);</span><br><span class="line">      value = newValue;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>setter</code> 方法中我们会注意到，我们又重新监听了一次 <code>newValue</code> 值的变化。这个是因为用户在赋值时，可能会传入一个<strong>新的 <code>Object</code> 类型的对象</strong>，所以我们需要对新传入的值，也进行一次监听。保证所有值的 <code>get</code> 和 <code>set</code> 都是被重写的。</p></li></ol><p>如果我们使用这种方法去处理数组，也是可以行得通的。但是<strong>只能通过索引去进行监听</strong>，我们在处理数组时一般会使用专门的方法去进行处理（<em>如 <code>push</code>、<code>shift</code>、<code>pop</code>等等</em>）。为了性能考虑，我们还需要单独对数组方法进行处理。</p><h3 id="数组方法劫持"><a href="#数组方法劫持" class="headerlink" title="数组方法劫持"></a>数组方法劫持</h3><p>其实数组的劫持，就是对<strong>原型上数组的方法进行重写</strong>。</p><p>首先，需要先判断当前传入的值是否是数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;arrayMethods&#125; <span class="keyword">from</span> <span class="string">'./array'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123; <span class="comment">// 观测值</span></span><br><span class="line"><span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      value.__proto__ = arrayMethods; <span class="comment">// 重写数组原型方法</span></span><br><span class="line">      <span class="keyword">this</span>.observeArray(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环并观测数组上的每一个值</span></span><br><span class="line">  observeArray(value) &#123;</span><br><span class="line">    value.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      observe(item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>observeArray</code> 可以保证数组上的每一个值都是被检测的，包括 <code>Object</code> 和 其他类型。</p><p><code>arrayMethods</code> 就是重写了当前数组原型上的方法。</p><h4 id="重写数组原型方法"><a href="#重写数组原型方法" class="headerlink" title="重写数组原型方法"></a>重写数组原型方法</h4><p>下面我们来看一下 <code>arrayMethods</code> 到底是什么。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldArrayProtoMethods = <span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> arrayMethods = <span class="built_in">Object</span>.create(oldArrayProtoMethods);</span><br><span class="line"><span class="keyword">let</span> methods = [<span class="string">"push"</span>, <span class="string">"pop"</span>, <span class="string">"shift"</span>, <span class="string">"unshift"</span>, <span class="string">"reverse"</span>, <span class="string">"sort"</span>, <span class="string">"splice"</span>]; <span class="comment">// 需要重写的方法</span></span><br><span class="line">methods.forEach(<span class="function">(<span class="params">method</span>) =&gt;</span> &#123;</span><br><span class="line">  arrayMethods[method] = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = oldArrayProtoMethods[method].apply(<span class="keyword">this</span>, args);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的意思是将 <em>原始数组原型上的方法继承一份，并导出。然后将我们需要重写的方法循环出来，依次进行处理</em>。</p><p>我们这里使用 <code>Object.create</code> 相当于 <code>arrayMethods.__proto__ = oldArrayProtoMethods</code>，这样会只处理重写后的方法，没重写的方法不会被处理。</p><p>现在，我们需要对一些特定的方法进行处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">methods.forEach(<span class="function">(<span class="params">method</span>) =&gt;</span> &#123;</span><br><span class="line">  arrayMethods[method] = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__;</span><br><span class="line">    <span class="keyword">let</span> inserted; <span class="comment">// 需要添加的项</span></span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"push"</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"unshift"</span>:</span><br><span class="line">        inserted = args;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"splice"</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>); <span class="comment">// 截取新添加的项</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted); <span class="comment">// 对新添加的每一项进行观测</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>push</code> 和 <code>unshift</code> 都是添加项的意思，一个是在头部添加，一个是在尾部添加。<code>splice</code> 从第三个参数开始，就是添加的项。</p><p>因为新添加的项可能也是 <code>Object</code> 类型，所以我们需要再次 <strong>对新添加的项进行劫持</strong>。</p><p>但是这里就出现了一个问题，我们并<em>没有办法使用劫持方法</em>。又已知<strong>当前方法中的this就是被调用数组的value</strong>（<em>上面的 <code>apply</code>改变了 <code>this</code>指向</em>）。所以我们就可以<strong>在value上增加一个属性<code>__ob__</code></strong>。</p><h4 id="增加-ob-属性"><a href="#增加-ob-属性" class="headerlink" title="增加 __ ob __ 属性"></a>增加 __ ob __ 属性</h4><p><code>__ob__</code> 属性的作用是给所有响应式数据<strong>增加标识</strong>，用来判断当前对象<strong>是否被劫持过</strong>。并且可以在响应式上<strong>获取<code>Observer</code>实例上的方法</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123; </span><br><span class="line">  <span class="keyword">constructor</span>(value)&#123;</span><br><span class="line"><span class="comment">// 添加 __ob__</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(value, <span class="string">"__ob__"</span>, &#123;</span><br><span class="line">      enumerable: <span class="literal">false</span>,   <span class="comment">// 不可枚举，也就是不能被循环出来</span></span><br><span class="line">      configurable: <span class="literal">false</span>, <span class="comment">// 不能删除</span></span><br><span class="line">      value: <span class="keyword">this</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就在每一项中都追加了一个 <code>__ob__</code> 属性，现在我们还需要进行一步处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> data !== <span class="string">"object"</span> || data == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (data.__ob__) &#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observer(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前项已经被添加了 <code>__ob__</code> 属性，则不进行处理。这样可以防止数据被重复劫持。</p><p>这样我们就完成了对数组的数据劫持。</p><p>（<em>注：在Vue中不能直接修改指定项，需要通过Array数组中的方法来进行修改。<code>Vue.$set</code> 可以修改特定值，后续我会详细介绍一下其使用和原理。</em>）</p><h2 id="属性代理"><a href="#属性代理" class="headerlink" title="属性代理"></a>属性代理</h2><p>我们已经对数据进行了相应的劫持，现在可以对 <code>data</code> 进行相应的操作了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line">vm._data.arr.push(&#123;</span><br><span class="line">   b: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line">vm._data.arr[<span class="number">1</span>].b = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p><code>set</code> 和 <code>get</code> 方法都可以被正常触发。</p><p>但是这种操作太麻烦了，所以我们现在需要对属性进行代理，让用户可以直接通过 <code>vm.arr</code> 这种方式直接修改值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span>(<span class="params">vm, source, key</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(vm, key, &#123;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> vm[source][key];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">      vm[source][key] = newValue;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span>(<span class="params">vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data;</span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">"function"</span> ? data.call(vm) : data;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">    <span class="comment">// 将_data上的属性全部代理给vm实例</span></span><br><span class="line">    proxy(vm, <span class="string">"_data"</span>, key);</span><br><span class="line">  &#125;</span><br><span class="line">  observe(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是使用 <code>Object.defineProperty</code> 对传入的属性进行劫持监听。</p><p>当用户到 <code>vm</code> 中获取属性时，属性的值被代理到 <code>vm._data</code> 上。</p><p>至此，我们的Vue2响应式原理就介绍完毕了。</p><hr><blockquote><p>本篇文章由 <strong>莫小尚</strong> 创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;Vue2.0全家桶的系统学习，其中包括&lt;strong&gt;Vue源码分析&lt;/strong&gt;、&lt;strong&gt;Vue-Router的使用和原理&lt;/strong&gt;、&lt;strong&gt;Vuex的用法和原理&lt;/strong&gt;、&lt;strong&gt;Vue-ssr&lt;/strong&gt;、如何进行&lt;strong&gt;单元测试&lt;/strong&gt; 和 一些常见的&lt;strong&gt;Vue面试题&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr&gt;&lt;blockquote&gt;&lt;p&gt;参考官网 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9jbi52dWVqcy5vcmcvaW5kZXguaHRtbA==&quot;&gt;vue.js官网&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Vue源码解析" scheme="https://mxshang.github.io/categories/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="知识点汇总" scheme="https://mxshang.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    
    <category term="Vue源码" scheme="https://mxshang.github.io/tags/Vue%E6%BA%90%E7%A0%81/"/>
    
    <category term="Vue基础" scheme="https://mxshang.github.io/tags/Vue%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记—Node之读取流的使用与实现</title>
    <link href="https://mxshang.github.io/2022/02/01/Stream/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B9%8B%E8%AF%BB%E5%8F%96%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://mxshang.github.io/2022/02/01/Stream/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B9%8B%E8%AF%BB%E5%8F%96%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-02-01T08:29:22.000Z</published>
    <updated>2022-03-03T07:31:09.634Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><p>在上一篇文章中，我们利用 <em>分片读写（发布订阅模式）</em> 的方式实现了 <em>文件拷贝</em> 的功能。</p><p>而 <em>Node</em> 中提供了几种原生解决方案，<span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvZnMuaHRtbCNmaWxlaGFuZGxlY3JlYXRlcmVhZHN0cmVhbW9wdGlvbnM=">fs.createReadStream<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvZnMuaHRtbCNmc2NyZWF0ZXdyaXRlc3RyZWFtcGF0aC1vcHRpb25z">fs.createWriteStream<i class="fa fa-external-link-alt"></i></span>。</p><p>顾名思义，这两种方案都是以创建 <em>流（<code>Stream</code>）</em> 的方式进行处理的。</p><p>这篇文章我们会着重说明一下 <em>可读流（<code>fs.createReadStream</code>）</em> 的基本使用与它的实现原理。</p><h2 id="可读流的使用"><a href="#可读流的使用" class="headerlink" title="可读流的使用"></a>可读流的使用</h2><blockquote><p><code>fs.createReadStream</code> 的具体说明，可以参考官网 <span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvZnMuaHRtbCNmaWxlaGFuZGxlY3JlYXRlcmVhZHN0cmVhbW9wdGlvbnM=">fs 文件系统 | Node.js API文档<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><code>fs.createReadStream</code> 会创建一个 <em>可读流</em> 用来对文件内容进行读取。方法会返回一个 <code>fs.ReadStream</code> 类的实例作为回调，其父类是 <span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvc3RyZWFtLmh0bWwjY2xhc3Mtc3RyZWFtcmVhZGFibGU=">stream.Readable<i class="fa fa-external-link-alt"></i></span> ，属于 <code>stream</code> 类上的一个类。</p><p>其中 第一个参数 <code>path</code> 传入需要进行读取的 <em>文件路径</em> 。</p><p>第二个参数 <code>option</code> 包括</p><ul><li><code>encoding</code>：编码格式，默认值为 <code>null</code>。</li><li><code>autoClose</code>：读取完毕后自动关闭，默认值为 <code>true</code>。</li><li><code>start</code> / <code>end</code>：从文件中读取一定范围的字节，而不是整个文件。</li><li><code>highWaterMark</code>：最高水位线，默认长度为 <code>64 * 1024</code> ，也就是 <code>64kb</code>。</li></ul><p>我们可以参考下面的例子，了解一下它的使用方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.txt</span></span><br><span class="line"><span class="number">123456789</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// createReadStream.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="comment">// 返回一个 Readable 类的实例</span></span><br><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(path.resolve(__dirname, <span class="string">"test.txt"</span>), &#123;</span><br><span class="line">  highWaterMark: <span class="number">3</span> <span class="comment">// 最高水位线为3，也就是每次读取 3kb</span></span><br><span class="line">&#125;);</span><br><span class="line">rs.on(<span class="string">"open"</span>, (fd) =&gt; &#123; <span class="comment">// 此方法是 fs 模块中自己实现的</span></span><br><span class="line">  <span class="built_in">console</span>.log(fd); <span class="comment">// 3 </span></span><br><span class="line">&#125;);</span><br><span class="line">rs.on(<span class="string">"data"</span>, (chunk) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chunk); <span class="comment">// 返回Buffer格式 &lt;Buffer 31 32 33&gt; &lt;Buffer 34 35 36&gt; &lt;Buffer 37 38 39&gt;</span></span><br><span class="line">&#125;);</span><br><span class="line">rs.on(<span class="string">"end"</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"end"</span>); <span class="comment">// 结束事件</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果我们的文件中包括中文，并把 <code>highWaterMark</code> 改成2，并使用变量进行拼接，就会出现乱码的情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.txt</span></span><br><span class="line">莫小尚<span class="number">1234567890</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// createReadStream.js</span></span><br><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(path.resolve(__dirname, <span class="string">"test.txt"</span>), &#123;</span><br><span class="line">  highWaterMark: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line">rs.on(<span class="string">"data"</span>, (chunk) =&gt; &#123;</span><br><span class="line">  result += chunk;</span><br><span class="line">&#125;);</span><br><span class="line">rs.on(<span class="string">"end"</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">// �������1234567890</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个原因就是因为 <code>Buffer</code> 在拼接的时候，需要使用其特定方法 <code>.concat</code> 进行拼接。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对代码进行修改</span></span><br><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line">rs.on(<span class="string">"data"</span>, (chunk) =&gt; &#123;</span><br><span class="line">  arr.push(chunk);</span><br><span class="line">&#125;);</span><br><span class="line">rs.on(<span class="string">"end"</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(Buffer.concat(arr).toString()); <span class="comment">// 莫小尚1234567890</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>搞清楚了 <code>ReadStream</code> 的使用，我们就可以尝试自己手写一套 <code>ReadStream</code> 类了。</p><h2 id="手写实现可读流"><a href="#手写实现可读流" class="headerlink" title="手写实现可读流"></a>手写实现可读流</h2><p>先来看一下完整的代码实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// readStream.js 手写方法</span></span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">"events"</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(path, options) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.path = path;</span><br><span class="line">    <span class="keyword">this</span>.flags = options.flags || <span class="string">"r"</span>;</span><br><span class="line">    <span class="keyword">this</span>.highWaterMark = options.highWaterMark || <span class="number">64</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">this</span>.start = options.start || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.end = options.end;</span><br><span class="line">    <span class="keyword">this</span>.emitClose = options.emitClose || <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.encoding = options.encoding;</span><br><span class="line">    <span class="keyword">this</span>.offset = <span class="keyword">this</span>.start; <span class="comment">// 偏移量</span></span><br><span class="line">    <span class="comment">// 是否需要触发data事件</span></span><br><span class="line">    <span class="keyword">this</span>.flowing = <span class="literal">false</span>; <span class="comment">// 当用户监听data事件后，此属性变成true</span></span><br><span class="line">    <span class="comment">// 即使只绑定了open事件，也可以进行触发(也就是只进行订阅)</span></span><br><span class="line">    <span class="keyword">this</span>.open();</span><br><span class="line">    <span class="comment">// 每次绑定事件，都会触发newListener的回调</span></span><br><span class="line">    <span class="keyword">this</span>.on(<span class="string">"newListener"</span>, (type) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (type === <span class="string">"data"</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.flowing = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.read();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 销毁方法</span></span><br><span class="line">  destory(err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">"error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fd) &#123;</span><br><span class="line">      fs.close(<span class="keyword">this</span>.fd, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">"close"</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  open() &#123;</span><br><span class="line">    fs.open(<span class="keyword">this</span>.path, <span class="keyword">this</span>.flags, (err, fd) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.destory(err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.fd = fd;</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">"open"</span>, fd); <span class="comment">// 触发open事件</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  read() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fd !== <span class="string">"number"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.once(<span class="string">"open"</span>, () =&gt; <span class="keyword">this</span>.read());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处直接读取 this.fd 是读取不到的，所以我们需要先进行判断</span></span><br><span class="line">    <span class="keyword">const</span> howManyToRead = <span class="keyword">this</span>.end</span><br><span class="line">      ? <span class="built_in">Math</span>.min(<span class="keyword">this</span>.highWaterMark, <span class="keyword">this</span>.end - <span class="keyword">this</span>.offset + <span class="number">1</span>)</span><br><span class="line">      : <span class="keyword">this</span>.highWaterMark;</span><br><span class="line">    <span class="keyword">const</span> buffer = Buffer.alloc(howManyToRead);</span><br><span class="line">    fs.read(<span class="keyword">this</span>.fd, buffer, <span class="number">0</span>, howManyToRead, <span class="keyword">this</span>.offset, (err,bytesRead) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="keyword">this</span>.destory(err);</span><br><span class="line">        <span class="keyword">if</span> (bytesRead == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.emit(<span class="string">"end"</span>); <span class="comment">// 触发end事件</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.destory(); <span class="comment">// 进行销毁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.offset += bytesRead;</span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">"data"</span>, buffer.slice(<span class="number">0</span>, bytesRead));</span><br><span class="line">        <span class="comment">// 进行递归，循环输出结果</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.flowing) &#123;</span><br><span class="line">          <span class="keyword">this</span>.read();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  pause() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.flowing) &#123;</span><br><span class="line">      <span class="keyword">this</span>.flowing = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  resume() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.flowing) &#123;</span><br><span class="line">      <span class="keyword">this</span>.flowing = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">this</span>.read();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = ReadStream;</span><br></pre></td></tr></table></figure><p>然后我们再对这个方法进行引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.txt</span></span><br><span class="line">莫小尚<span class="number">1234567890</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// createReadStream.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> ReadStream = <span class="built_in">require</span>(<span class="string">"./readStream"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rs = <span class="keyword">new</span> ReadStream(path.resolve(__dirname, <span class="string">"test.txt"</span>), &#123;</span><br><span class="line">  highWaterMark: <span class="number">2</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">"open"</span>, (fd) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(fd);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line">rs.on(<span class="string">"data"</span>, (chunk) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chunk);</span><br><span class="line">  arr.push(chunk);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">"end"</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(Buffer.concat(arr).toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后我们来进行依次解析，看一下 <code>fs.createReadStream</code> 的实现原理究竟是什么样的。</p><h3 id="实现方法解析"><a href="#实现方法解析" class="headerlink" title="实现方法解析"></a>实现方法解析</h3><p>根据官网，我们可以知道 <code>fs.createReadStream</code> 会接受两个参数，分别是 <code>path</code> 和 <code>option</code><em>（其中包括很多参数，具体可参考官网）</em>。</p><ol><li><p>创建一个类，并使它继承自 <code>EventEmitter</code>，这样会让他具备 <em>发布订阅模式</em> 的特性。其原本的继承链是 <code>class ReadStream extends Readable extends EventEmitter</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">"events"</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStream</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(path, options) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.path = path;</span><br><span class="line">    <span class="keyword">this</span>.flags = options.flags || <span class="string">"r"</span>;</span><br><span class="line">    <span class="keyword">this</span>.highWaterMark = options.highWaterMark || <span class="number">64</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">this</span>.start = options.start || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.end = options.end;</span><br><span class="line">    <span class="keyword">this</span>.emitClose = options.emitClose || <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.encoding = options.encoding;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = ReadStream;</span><br></pre></td></tr></table></figure></li><li><p>定义一个 <code>flowing</code> 属性，并使用 <code>.on(&#39;newListener&#39;)</code> 来监听 <em>data事件</em>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(path, options) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否需要触发data事件</span></span><br><span class="line">    <span class="keyword">this</span>.flowing = <span class="literal">false</span>; <span class="comment">// 当用户监听data事件后，此属性变成true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每次绑定事件，都会触发newListener的回调</span></span><br><span class="line">    <span class="keyword">this</span>.on(<span class="string">"newListener"</span>, (type) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (type === <span class="string">"data"</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.flowing = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.read();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  read() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"用户监听了data"</span>); <span class="comment">// 打印出此方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引入 <code>fs</code> 模块，并定义出一个 <code>.open()</code> 方法。其中包含一个 <code>destory</code> 方法，用来处理错误事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(path, options) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 即使只绑定了open事件，也可以进行触发(也就是只进行订阅)</span></span><br><span class="line">    <span class="keyword">this</span>.open();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 销毁方法</span></span><br><span class="line">  destory(err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">"error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fd) &#123;</span><br><span class="line">      fs.close(<span class="keyword">this</span>.fd, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">"close"</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  open() &#123;</span><br><span class="line">    fs.open(<span class="keyword">this</span>.path, <span class="keyword">this</span>.flags, (err, fd) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.destory(err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.fd = fd;</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">"open"</span>, fd); <span class="comment">// 触发open事件</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们只要在需要引入的文件中，定义一个监听的 <code>error</code> 事件就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createReadStream.js</span></span><br><span class="line">rs.on(<span class="string">"error"</span>, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>​ 当然，也可以不进行 error事件 绑定。</p><ol start="4"><li><p>在文件打开后，再进行内容读取。</p><p>我们都清楚， <code>fs.open</code> 是一个异步操作，所以可能会存在 <code>data</code> 事件触发时，文件还没有读取完的情况。</p><p>这时我们就需要进行一个 <strong>轮询处理</strong> ，等待 <code>this.emit(&#39;open&#39;)</code> 触发后，再进行 <code>read</code> 方法。</p><p>接下来，我们来对 <code>read</code> 方法进行改造。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(path, options) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  read() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fd !== <span class="string">"number"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.once(<span class="string">"open"</span>, () =&gt; <span class="keyword">this</span>.read());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处直接读取 this.fd 是读取不到的，所以我们需要先进行判断</span></span><br><span class="line">    fs.read(<span class="keyword">this</span>.fd);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以保证，<code>read</code> 事件是在文件打开后进行触发的。</p></li><li><p>现在来对 <code>fs.read</code> 的剩余参数进行处理。</p><p>创建一个 <code>Buffer</code> 来对内容进行存储，长度为 <code>highWaterMark</code> 字节。并且计算 <code>start</code> 和 <code>end</code></p><p>这里需要注意，我们在创建 <code>Buffer</code> 的时候，需要每次都声明一个新的内存空间来对内容进行存储。</p><p>不可以在属性中定义一个 <code>buffer</code> 属性，这样会导致每次指向的都是同一个内存空间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">read() &#123;</span><br><span class="line">  <span class="comment">// 每次都创建一个新的内存空间</span></span><br><span class="line">  <span class="keyword">const</span> buffer = Buffer.alloc(<span class="keyword">this</span>.highWaterMark);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们需要对 <code>start</code> 和 <code>end</code> 进行判断。</p><p>我们先定义一个 <code>offset</code> 属性，来记录上一轮计算的偏移量。</p><p>并且还需要判断，用户当前是否传入了 <code>start</code> 和 <code>end</code> 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(path, options) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.offset = <span class="keyword">this</span>.start; <span class="comment">// 偏移量</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  read() &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="keyword">const</span> howManyToRead = <span class="keyword">this</span>.end</span><br><span class="line">      ? <span class="built_in">Math</span>.min(<span class="keyword">this</span>.highWaterMark, <span class="keyword">this</span>.end - <span class="keyword">this</span>.offset + <span class="number">1</span>)</span><br><span class="line">      : <span class="keyword">this</span>.highWaterMark;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> buffer = Buffer.alloc(howManyToRead);</span><br><span class="line"></span><br><span class="line">    fs.read(<span class="keyword">this</span>.fd, buffer, <span class="number">0</span>, howManyToRead, <span class="keyword">this</span>.offset, (err,bytesRead) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="keyword">this</span>.destory(err);</span><br><span class="line">        <span class="keyword">this</span>.offset += bytesRead;</span><br><span class="line">      <span class="comment">// 可能存在最后一次的buffer大小 大于 实际数据大小的情况，所以使用slice来进行截取</span></span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">"data"</span>, buffer.slice(<span class="number">0</span>, bytesRead)); <span class="comment">// 将结果抛给data事件的回调</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们在前面的 data 事件中，就可以监听到读取的数据了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createReadStream.js</span></span><br><span class="line">rs.on(<span class="string">"data"</span>, (chunk) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chunk); <span class="comment">// &lt;Buffer e8 8e&gt;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>进行递归，循环输出结果</p><p>这里不用做过多的解释，通过上一步我们不难发现，每次都只输出了一次结果。</p><p>所以我们需要进行递归处理，将数据进行完全输出，并触发 <code>end</code> 事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(path, options) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  read() &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    fs.read(<span class="keyword">this</span>.fd, buffer, <span class="number">0</span>, howManyToRead, <span class="keyword">this</span>.offset, (err,bytesRead) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="keyword">this</span>.destory(err);</span><br><span class="line">      <span class="comment">// 如果读取不到数据了，就进行销毁</span></span><br><span class="line">      <span class="keyword">if</span> (bytesRead == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.emit(<span class="string">'end'</span>); <span class="comment">// 触发end事件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.destory(); <span class="comment">// 进行销毁</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.offset += bytesRead;</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">"data"</span>, buffer.slice(<span class="number">0</span>, bytesRead));</span><br><span class="line">      <span class="comment">// 进行递归，循环输出结果</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.flowing) &#123;</span><br><span class="line">            <span class="keyword">this</span>.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加一个 <code>pause</code> 和 <code>resume</code> 来进行流量控制。</p><p><code>pause</code> 和 <code>resume</code> 可以控制当前数据流的 <em>停止</em> 和 <em>继续</em>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(path, options) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  pause() &#123;</span><br><span class="line">    <span class="comment">// 判断当前是否读取完毕了</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.flowing) &#123;</span><br><span class="line">      <span class="keyword">this</span>.flowing = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  resume() &#123;</span><br><span class="line">    <span class="comment">// 判断当前是否读取完毕了</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.flowing) &#123;</span><br><span class="line">      <span class="keyword">this</span>.flowing = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">this</span>.read();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这样我们就手写实现了 <code>fs.createReadStream</code> 方法。</p><p><code>fs.createReadStream</code> 在工作中比较常见，可以用来进行大型文件的处理，所以学好用好此方法还是比较重要的。</p><blockquote><p>本篇文章由 <strong>莫小尚</strong> 创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr&gt;&lt;p&gt;在上一篇文章中，我们利用 &lt;em&gt;分片读写（发布订阅模式）&lt;/em&gt; 的方式实现了 &lt;em&gt;文件拷贝&lt;/em&gt; 的功能。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://mxshang.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="知识点汇总" scheme="https://mxshang.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    
    <category term="Node" scheme="https://mxshang.github.io/tags/Node/"/>
    
    <category term="JS进阶" scheme="https://mxshang.github.io/tags/JS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记—Node之文件拷贝与分片读写</title>
    <link href="https://mxshang.github.io/2021/12/29/Node%E7%B1%BB/Buffer/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B9%8B%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E4%B8%8E%E5%88%86%E7%89%87%E8%AF%BB%E5%86%99/"/>
    <id>https://mxshang.github.io/2021/12/29/Node%E7%B1%BB/Buffer/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B9%8B%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E4%B8%8E%E5%88%86%E7%89%87%E8%AF%BB%E5%86%99/</id>
    <published>2021-12-29T08:29:22.000Z</published>
    <updated>2022-01-11T19:54:17.552Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><p>在之前的文章中，我们曾讲过 <a href="https://mxshang.github.io/2021/11/16/Node-%E4%B8%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/">fs模块</a> ，其中包含 <code>readFile</code> 和 <code>writeFile</code> 两个方法。其中 <code>readFile</code> 是读取文件， <code>writeFile</code> 是写入文件。</p><p>下面我们来用这两个方法来实现一个简单的 <em>拷贝操作</em> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(path.resolve(__dirname, <span class="string">'./package.json'</span>), (err, data) =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'error'</span>, err);</span><br><span class="line">fs.writeFile(path.resolve(__dirname, <span class="string">'./test.json'</span>), data, () =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样我们的文件就被拷贝下来了，但是这种操作有一个问题。</p><p><code>readFile</code> 只适合操作小文件 <em>（如 JS、Css 和 json 文件等）*。但是对于一些大文件 *（如 音频、视频 等）</em> ，虽然也可以操作，但是可能会 <strong>淹没可用内存</strong>。 原因是因为 <code>readFile</code> 是将文件全部读取下来之后，再进行操作的。</p><p>这样我们就需要一种新的概念 <strong>分片读写</strong>，用来操作大型文件。 而<strong>分片读写</strong> 也就是后端领域中，经常提及的 <strong>数据流 (<code>Stream</code>)</strong> 操作。</p><h2 id="大文件的分片读写"><a href="#大文件的分片读写" class="headerlink" title="大文件的分片读写"></a>大文件的分片读写</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvZnMuaHRtbA==">fs 文件系统 | Node.js API文档<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>如果要使用 <em>node</em> 实现一套文件读写，我们需要用到 <span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvZnMuaHRtbCNmc3Byb21pc2Vzb3BlbnBhdGgtZmxhZ3MtbW9kZQ==">fs.open<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvZnMuaHRtbCNmc3JlYWRmZC1idWZmZXItb2Zmc2V0LWxlbmd0aC1wb3NpdGlvbi1jYWxsYmFjaw==">fs.read<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvZnMuaHRtbCNmc3dyaXRlZmQtYnVmZmVyLW9mZnNldC1sZW5ndGgtcG9zaXRpb24tY2FsbGJhY2s=">fs.write<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvZnMuaHRtbCNmaWxlaGFuZGxlY2xvc2U=">fs.close<i class="fa fa-external-link-alt"></i></span>。</p><p>其根本的实现思路就是，将需要进行读写的文件进行 <strong>边读边写</strong> 的操作，这样我们就可以控制读写的 <strong>速率</strong>。</p><p>现在我们先创建一个<em>目标文件 test.js（需要进行拷贝操作的文件）</em>，里面随便写一些内容，比如 <em>1234567890</em>。</p><p>现在我们就需要进行 <em>读一写一（读一个数字写一个数字）</em> 的操作，然后再产生一个名为 <em>newTest.js</em> 的文件。</p><p>我们先来实现一套 <em>单个文字</em> 的操作流程，来了解一下读写操作的原理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = Buffer.alloc(<span class="number">1</span>); <span class="comment">// 创建一个用来进行存储数据内存的 Buffer 类型</span></span><br><span class="line"><span class="comment">// 读取 源文件 中的数据</span></span><br><span class="line">fs.open(path.resolve(__dirname, <span class="string">"test.js"</span>), <span class="string">"r"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, rfd</span>) </span>&#123; <span class="comment">// fs 是 数字类型</span></span><br><span class="line">  <span class="comment">// 将读取到的数据写入到 buf 中。从第0个位置开始写入buf，写入长度为1个，然后从文件的第0个位置开始进行读取。</span></span><br><span class="line">  fs.read(rfd, buf, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, bytesRead</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(bytesRead); <span class="comment">// 读取到的字节长度</span></span><br><span class="line">    <span class="comment">// 读取到的第一文字以16进制的形式存入了 buf实例 中。</span></span><br><span class="line">    <span class="built_in">console</span>.log(buf); <span class="comment">// &lt;Buffer 31&gt;</span></span><br><span class="line">    <span class="comment">// 打开 目标文件。</span></span><br><span class="line">    fs.open(path.resolve(__dirname, <span class="string">"newTest.js"</span>), <span class="string">"w"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, wfd</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 数据已经被写入了</span></span><br><span class="line">      <span class="built_in">console</span>.log(rfd, wfd); <span class="comment">// 3 4</span></span><br><span class="line">      <span class="comment">// 向文件中写入buf中的数据。从第0个位置开始进行读取，读取长度为1个，然后再写入到文件中。</span></span><br><span class="line">      fs.write(wfd, buf, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, bytesWritten</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"success"</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>现在我们可以根据这种方式，然后使用 <a href="https://mxshang.github.io/2021/07/12/Promise/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Promise%E4%B9%8B%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/">发布订阅模式</a>，封装一套 分片读写操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>source 源文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>target 目标文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>cb 回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">source, target, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> BUFFER_SIZE = <span class="number">3</span>; <span class="comment">// buffer的固定长度</span></span><br><span class="line">  <span class="keyword">const</span> PATH_SOURCE = path.resolve(__dirname, source);</span><br><span class="line">  <span class="keyword">const</span> PATH_TARGET = path.resolve(__dirname, target);</span><br><span class="line">  <span class="keyword">let</span> buf = Buffer.alloc(BUFFER_SIZE); <span class="comment">// buffer实例</span></span><br><span class="line">  <span class="keyword">let</span> rOffset = <span class="number">0</span>; <span class="comment">// 读取偏移量</span></span><br><span class="line">  <span class="keyword">let</span> wOffset = <span class="number">0</span>; <span class="comment">// 写入偏移量</span></span><br><span class="line">  fs.open(PATH_SOURCE, <span class="string">"r"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, rfd</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> cb(err);</span><br><span class="line">    fs.open(PATH_TARGET, <span class="string">"w"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, wfd</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> cb(err);</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        fs.read(rfd, buf, <span class="number">0</span>, BUFFER_SIZE, rOffset, <span class="function"><span class="keyword">function</span> (<span class="params">err, bytesRead</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (err) <span class="keyword">return</span> cb(err);</span><br><span class="line">          <span class="comment">// 如果全部读取完毕，则关闭当前 读写操作</span></span><br><span class="line">          <span class="keyword">if</span> (bytesRead == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> done = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (++index == <span class="number">2</span>) &#123; cb(); &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            fs.close(wfd, done);</span><br><span class="line">            fs.close(rfd, done);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          fs.write(wfd, buf, <span class="number">0</span>, bytesRead, wOffset, <span class="function"><span class="keyword">function</span> (<span class="params">err, bytesWritten</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (err) <span class="keyword">return</span> cb(err);</span><br><span class="line">              <span class="comment">// 读取成功，并更新偏移量</span></span><br><span class="line">              rOffset += bytesRead;</span><br><span class="line">              wOffset += bytesWritten;</span><br><span class="line">              next();</span><br><span class="line">            &#125;</span><br><span class="line">          );</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      next();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 执行封装好的方法</span></span><br><span class="line">copy(<span class="string">"./test.js"</span>, <span class="string">"./newTest.js"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(err);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"copy success"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样我们就完成了一套 简单的 分片读写操作。</p><p>但是这种方式会出现 回调地狱 的问题，代码看起来非常难以阅读和维护。</p><p>这时我们就需要通过 <strong>数据流 (<code>Stream</code>)</strong> 来进行读写操作。</p><blockquote><p>本篇文章由 <strong>莫小尚</strong> 创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr&gt;&lt;p&gt;在之前的文章中，我们曾讲过 &lt;a href=&quot;https://mxshang.github.io/2021/11/16/Node-%E4%B8%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/&quot;&gt;fs模块&lt;/a&gt; ，其中包含 &lt;code&gt;readFile&lt;/code&gt; 和 &lt;code&gt;writeFile&lt;/code&gt; 两个方法。其中 &lt;code&gt;readFile&lt;/code&gt; 是读取文件， &lt;code&gt;writeFile&lt;/code&gt; 是写入文件。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://mxshang.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="知识点汇总" scheme="https://mxshang.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    
    <category term="Node" scheme="https://mxshang.github.io/tags/Node/"/>
    
    <category term="JS进阶" scheme="https://mxshang.github.io/tags/JS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记—Buffer的常用方法与实现</title>
    <link href="https://mxshang.github.io/2021/12/28/Node%E7%B1%BB/Buffer/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Buffer%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://mxshang.github.io/2021/12/28/Node%E7%B1%BB/Buffer/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Buffer%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-12-28T13:29:22.000Z</published>
    <updated>2021-12-28T16:11:48.124Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvYnVmZmVyLmh0bWw=">buffer 缓冲区<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><em>缓冲区 <code>Buffer</code></em> 是暂时存放输入输出数据的一段内存。<strong>JS没有二进制数据类型</strong>，而在处理TCP和文件流的时候，必须要处理二进制数据。所以 <code>Node</code> 提供了一个 <em><code>Buffer</code>对象</em> 来提供对二进制数据的操作。</p><p><code>Buffer</code> 表示固定内存分配的全局对象，也就是说要放到缓存区中的字节数需要提前确定。而 <code>Buffer</code> 好比由一个 <em>8位字节</em> 组成的数组，可以有效的在JavasScript中表示二进制数据。</p><p><code>Buffer</code> 简单来说就是 <code>node</code> 中的 <em>16进制</em> ，但 <code>Buffer</code> 在内存的标识也会全部使用 <em>2进制</em> 来进行表示。</p><p><em>（注：目前以无法使用 <code>new Buffer()</code> 创建 Buffer 实例，会存在安全性等问题。已被禁止使用。）</em></p><h3 id="Buffer-alloc"><a href="#Buffer-alloc" class="headerlink" title="Buffer.alloc"></a>Buffer.alloc</h3><p><code>Buffer</code> 代表的是内存，一旦声明好，就不能进行更改。</p><p>如果想要更改 <code>Buffer</code> 的大小，改小则对内存进行 <em>截取</em> 。 改大的话就需要创建一个更大的内存空间，将数据拷贝进行，也就是我们俗称的 <em>扩容</em> 。</p><p>这时候就可以用到 <code>Buffer</code> 类的内置方法， <code>Buffer.alloc()</code>。</p><p><code>Buffer.alloc(size[, fill[, encoding]])</code> ，表示分配 <code>size</code> 个字节的新 <code>Buffer</code>。 如果 <code>fill</code> 为 <code>undefined</code>，则 <code>Buffer</code> 将以零填充。</p><ul><li><strong>size</strong>：新的 <code>Buffer</code> 所需的长度。</li><li><strong>fill</strong>：用于预填充新 <code>Buffer</code> 的值，默认值为 <code>0</code>。</li><li><strong>encoding</strong>：如果 <code>fill</code> 是字符串，则这就是它的编码。默认值为 <code>utf8</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建了一个指定长度的buffer实例</span></span><br><span class="line"><span class="keyword">let</span> buf1 = Buffer.alloc(<span class="number">3</span>); <span class="comment">// 最小单位是 3字节</span></span><br><span class="line"><span class="built_in">console</span>.log(buf1); <span class="comment">// &lt;Buffer 00 00 00&gt;</span></span><br><span class="line"><span class="keyword">let</span> buf2 = Buffer.alloc(<span class="number">6</span>); <span class="comment">// 单位是 6</span></span><br><span class="line"><span class="built_in">console</span>.log(buf2); <span class="comment">// &lt;Buffer 00 00 00 00 00 00&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Buffer-from"><a href="#Buffer-from" class="headerlink" title="Buffer.from"></a>Buffer.from</h3><p>上一篇文章中，我们曾经使用 <code>Buffer.from</code> 来创建过 <a href="https://mxshang.github.io/2021/12/25/Buffer/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%BC%96%E7%A0%81%E7%9A%84%E5%8F%91%E5%B1%95/">base64</a> 。</p><p><code>Buffer.from</code> 方法用于创建包含指定 <em>字符串<em>，</em>数组</em> 或 <em>buffer</em> 的新 <code>Buffer</code> 实例。</p><p><code>Buffer.from</code> 可以传入的参数有很多，这里我们只扩展 <em>字符串</em> 和 <em>数组</em> 两种。</p><h4 id="Buffer-from-array"><a href="#Buffer-from-array" class="headerlink" title="Buffer.from(array)"></a>Buffer.from(array)</h4><p><code>Buffer.from(array)</code> 使用 <code>0</code> – <code>255</code> 范围内的字节 <code>array</code> 分配新的 <code>Buffer</code>。 该范围之外的数组条目将被截断以符合它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf1 = Buffer.from([<span class="number">0xe8</span>, <span class="number">0x8e</span>, <span class="number">0xab</span>])</span><br><span class="line"><span class="built_in">console</span>.log(buf1); <span class="comment">// &lt;Buffer e8 8e ab&gt;</span></span><br><span class="line"><span class="keyword">let</span> buf2 = Buffer.from([<span class="number">256</span>, <span class="number">0x8e</span>, <span class="number">0xab</span>]) <span class="comment">// 超过长度会自动取余</span></span><br><span class="line"><span class="built_in">console</span>.log(buf2); <span class="comment">// &lt;Buffer 00 8e ab&gt;</span></span><br><span class="line"><span class="keyword">let</span> buf2 = Buffer.from([<span class="string">'aaa'</span>, <span class="number">0x8e</span>, <span class="number">0xab</span>]) <span class="comment">// 不能在数组内存放其他数据类型</span></span><br><span class="line"><span class="built_in">console</span>.log(buf2); <span class="comment">// &lt;Buffer 00 8e ab&gt;</span></span><br></pre></td></tr></table></figure><p><em>（注：很少使用这种方法来定义 <code>buffer</code> ，因为需要指定存放的内容）</em></p><h4 id="Buffer-from-string"><a href="#Buffer-from-string" class="headerlink" title="Buffer.from(string)"></a>Buffer.from(string)</h4><p><code>Buffer.from(string[, encoding])</code> 创建包含 <code>string</code> 的新 <code>Buffer</code>。 <code>encoding</code> 参数标识将 <code>string</code> 转换为字节时要使用的字符编码。</p><ul><li><strong>string</strong>： 要编码的字符串。</li><li><strong>encoding</strong>： <code>string</code> 的编码，默认值为 <code>utf8</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = Buffer.from(<span class="string">'莫小尚'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf); <span class="comment">// &lt;Buffer e8 8e ab e5 b0 8f e5 b0 9a&gt;</span></span><br></pre></td></tr></table></figure><p><code>Buffer.from(string)</code> 是目前 <code>Buffer</code> 经常使用的方法。这个方法可以存储数据，存储的数据可以用 <code>Buffer</code> 进行表示。同时也可以和字符串之间进行相互转化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 .toString() 方法，将buffer转换成字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(buf.toString()); <span class="comment">// 莫小尚</span></span><br><span class="line"><span class="comment">// 可以转换成任意指定编码</span></span><br><span class="line"><span class="built_in">console</span>.log(buf.toString(<span class="string">'base64'</span>)); <span class="comment">// 6I6r5bCP5bCa</span></span><br></pre></td></tr></table></figure><p><code>buffer.toString()</code> 默认值为 <code>utf8</code> 。</p><p>我们在进行读写操作时，如果不指定编码，则所有读取的文件内容都是 <code>buffer</code> 类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.txt</span></span><br><span class="line"><span class="number">123456789</span></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> r = fs.readFileSync(<span class="string">'./test.txt'</span>); <span class="comment">// 不指定 utf-8 编码格式 </span></span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// &lt;Buffer 31 32 33 34 35 36 37 38 39&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Buffer的扩容"><a href="#Buffer的扩容" class="headerlink" title="Buffer的扩容"></a>Buffer的扩容</h3><p>我们在操作 <code>Buffer</code> 时，会遇到原本规定的内存大小不够的情况，这样我们就需要对 <code>Buffer</code> 进行扩容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf1 = Buffer.from(<span class="string">'莫'</span>)</span><br><span class="line"><span class="keyword">const</span> buf2 = Buffer.from(<span class="string">'小尚'</span>)</span><br><span class="line"><span class="keyword">const</span> bigBuf = Buffer.alloc(buf1.length + buf2.length);</span><br><span class="line"><span class="built_in">console</span>.log(bigBuf); <span class="comment">// &lt;Buffer 00 00 00 00 00 00 00 00 00&gt;</span></span><br></pre></td></tr></table></figure><p><code>buf.length</code> 返回 <code>buf</code> 中的字节数。</p><p>这样我们就创建了一个更大的 <code>Buffer</code> 对象，现在我们需要将内容拷贝到这个大 <em>buffer</em> 中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buf1.copy(bigBuf, <span class="number">0</span>, <span class="number">0</span>, buf1.length);</span><br><span class="line">buf2.copy(bigBuf, buf1.length, <span class="number">0</span>, buf2.length);</span><br><span class="line"><span class="built_in">console</span>.log(bigBuf.toString()); <span class="comment">// 莫小尚</span></span><br></pre></td></tr></table></figure><p>这里我们使用到了 <code>buf.copy()</code> 方法，稍后会进行讲解。</p><p>这样我们就完成了一个简单的扩容操作。 <em>（注：在实际工作中，此方法并不常用。我们一般会使用 <code>buf.concat</code> 来进行扩容操作。）</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf1 = Buffer.from(<span class="string">'莫'</span>);</span><br><span class="line"><span class="keyword">const</span> buf2 = Buffer.from(<span class="string">'小尚'</span>);</span><br><span class="line"><span class="keyword">const</span> bigBuf = Buffer.concat([buf1, buf2]);</span><br><span class="line"><span class="built_in">console</span>.log(bigBuf.toString()); <span class="comment">// 莫小尚</span></span><br></pre></td></tr></table></figure><p>关于 <code>buf.concat</code> 的使用，稍后也会进行详解。</p><h4 id="Buffer-copy"><a href="#Buffer-copy" class="headerlink" title="Buffer.copy"></a>Buffer.copy</h4><p><code>buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])</code> 将数据从 <code>buf</code> 的区域复制到 <code>target</code> 的区域，即使 <code>target</code> 内存区域与 <code>buf</code> 重叠。</p><ul><li><strong>target</strong>：被拷贝的 <code>Buffer</code> 或 <code>Uint8Array</code>，也就是我们的 大容量 <code>Buffer</code>。</li><li><strong>targetStart</strong>：<code>target</code> 内开始写入的偏移量，默认值为 <code>0</code>。</li><li><strong>sourceStart</strong>：<code>buf</code> 内开始复制的偏移量，默认值为 <code>0</code>。</li><li><strong>sourceEnd</strong>：<code>buf</code> 内停止复制的偏移量（不包括），默认值为 <code>buf.length</code>。</li><li><strong>[callBack]</strong>：复制的字节数。</li></ul><p>我们刚才使用了 <code>buf.copy</code> 进行了简单的扩容操作，那么 <code>buf.copy</code> 的实现原理是什么呢。</p><h5 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h5><p>首先我们清楚， <code>buf.copy</code> 中一共接受四个参数，分别是 <code>target</code> 、<code>targetStart</code> 、 <code>sourceStart</code> 、 <code>sourceEnd</code>。</p><p>现在我们来看一下完成后的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Buffer.prototype.copy = <span class="function"><span class="keyword">function</span> (<span class="params">target, targetStart, sourceStart = <span class="number">0</span>, sourceEnd = this.length</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = sourceStart; i &lt; sourceEnd; i++) &#123;</span><br><span class="line">target[targetStart++] = <span class="keyword">this</span>[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了 <code>buf.copy</code> ，我们就可以来看一下 <code>buf.concat</code> 方法了。</p><h4 id="Buffer-concat"><a href="#Buffer-concat" class="headerlink" title="Buffer.concat"></a>Buffer.concat</h4><p><code>Buffer.concat(list[, totalLength])</code> 会返回新的 <code>Buffer</code>，它是将 <code>list</code> 中的所有 <code>Buffer</code> 实例连接在一起的结果。</p><ul><li><strong>list</strong>：要拼接的 <code>Buffer</code> 或 <code>Uint8Array</code> 实例的数组列表。</li><li><strong>totalLength</strong>：连接时 <code>list</code> 中 <code>Buffer</code> 实例的总长度。</li><li><strong>callBack</strong>：返回一个新的 <code>Buffer</code>。</li></ul><p>在上面的例子中，我们使用 <code>buf.concat</code> 实现了一个 <code>Buffer</code> 扩容的例子。</p><p>下面我们就来详解一下它的方法实现。</p><h5 id="方法实现-1"><a href="#方法实现-1" class="headerlink" title="方法实现"></a>方法实现</h5><p>根据 <code>buf.concat</code> 的使用方式，我们可以大概了解到一个思路。 那就是将传入的 <code>Buffer</code> 实例通过 <em>拷贝</em> 的方式将其拼接成一个大的 <code>Buffer</code> 类。</p><p>这样我们就可以大概手写出其实现原理了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Buffer.concat = <span class="function"><span class="keyword">function</span> (<span class="params">bufferList, len = bufferList.reduce((a, b</span>) =&gt; <span class="title">a</span> + <span class="title">b</span>.<span class="title">length</span>, 0)) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> buffer = Buffer.alloc(len);</span><br><span class="line"><span class="comment">// 记录下一次 开始拼接的 位置</span></span><br><span class="line"><span class="keyword">let</span> offset = <span class="number">0</span>;</span><br><span class="line">bufferList.forEach(<span class="function"><span class="params">buf</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是不是 Buffer</span></span><br><span class="line">    <span class="keyword">if</span> (Buffer.isBuffer(buf)) &#123;</span><br><span class="line">buf.copy(buffer, offset);</span><br><span class="line">offset += buf.length;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就完成了 <code>buf.concat</code> 的实现。</p><blockquote><p>本篇文章由 <strong>莫小尚</strong> 创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr&gt;&lt;h2 id=&quot;Buffer&quot;&gt;&lt;a href=&quot;#Buffer&quot; class=&quot;headerlink&quot; title=&quot;Buffer&quot;&gt;&lt;/a&gt;Buffer&lt;/h2&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://mxshang.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="知识点汇总" scheme="https://mxshang.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    
    <category term="Node" scheme="https://mxshang.github.io/tags/Node/"/>
    
    <category term="JS进阶" scheme="https://mxshang.github.io/tags/JS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记—编码的发展</title>
    <link href="https://mxshang.github.io/2021/12/25/Node%E7%B1%BB/Buffer/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%BC%96%E7%A0%81%E7%9A%84%E5%8F%91%E5%B1%95/"/>
    <id>https://mxshang.github.io/2021/12/25/Node%E7%B1%BB/Buffer/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%BC%96%E7%A0%81%E7%9A%84%E5%8F%91%E5%B1%95/</id>
    <published>2021-12-25T06:01:22.000Z</published>
    <updated>2021-12-27T18:28:42.433Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="编码的发展"><a href="#编码的发展" class="headerlink" title="编码的发展"></a>编码的发展</h2><p>我们现在常用的编码是 <code>ASCII</code> 编码，汉字都是使用 <code>UTF-8</code> 格式。</p><p>编码一般分为以下几种</p><ul><li><strong>ASCII 码</strong></li><li><strong>GB2312</strong></li><li><strong>GBK</strong></li><li><strong>GB18030 (DBCS)</strong></li><li><strong>Unicode</strong></li><li><strong>UTF-8</strong> / <strong>UTF-16</strong></li><li>…</li></ul><h3 id="ASCII-码"><a href="#ASCII-码" class="headerlink" title="ASCII 码"></a>ASCII 码</h3><p><strong>ASCII码</strong> 的八位字节可以表现出 <em>256</em> 种不同的形态。</p><p>0-32 规定了特殊用途,一旦终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。<em>（如 遇上0×10, 终端就换行。遇上0×07, 终端就会发出嘟嘟嘟的声音 等。）</em></p><p>所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第 <em>127</em> 号。这样计算机就可以用不同字节来存储英语的文字了。</p><p><img data-src="pic2.png" alt="ASCII表"></p><p>因为计算机最早是在美国进行使用的，而他们也只使用了前 <em>127</em> 号。但是世界上存在那么多种语言，光是汉语就有好几万个汉字，这种编码格式显然是不太行的。</p><h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p>西欧一些国家用的不是英文，所以他们使用 <em>127</em> 号这后的空位来保存新的字母，一直编到了最后一位 <em>255<em>。</em>（不同国家表示的符号也是不同的，130 在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)）</em></p><p>而我们国家为了表示汉字，把 <em>127</em> 之后的符号取消了。</p><p>一个 <em>小于127</em> 的字符的意义与原来相同。但两个大于 127 的字符连在一起时，就表示一个汉字。前面的一个字节（<strong>高字节</strong>）从 <code>0xA1</code> 到 <code>0xF7</code>，后面一个字节（<strong>低字节</strong>）从 <code>0xA1</code> 到 <code>0xFE</code>。这种方式可以组合出大概 <code>(247-161)*(254-161) = 7998</code> 多个简体汉字。</p><p>而 <em>数学符号<em>、</em>日文假名</em> 和 ASCII里原来就有的 <em>数字<em>、</em>标点</em> 和 <em>字母</em> 都重新编成两个字长的编码。这就是 <strong>全角字符</strong>，<em>127</em> 以下那些就叫<strong>半角字符</strong>。</p><p>这种汉字方案叫做 <code>GB2312</code>。<code>GB2312</code> 是对 <code>ASCII</code> 的 <em>中文扩展</em> 。</p><h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h3><p>在使用过程中，发现 <code>GB2312</code> 还是不够用。于是便不再要求 <strong>低字节</strong> 一定是 <em>127</em> 之后的内码，只要第一个字节是大于 <em>127</em> ，就固定表示这是一个汉字的开始。</p><p>于是又增加了近 <em>20000</em> 个新的汉字（包括繁体字）和符号。</p><h3 id="GB18030-DBCS"><a href="#GB18030-DBCS" class="headerlink" title="GB18030 / DBCS"></a>GB18030 / DBCS</h3><p><code>GBK</code>扩成了<code>GB18030</code> 通称他们叫做 DBCS，增加了几千个新的少数民族的字。</p><p>在 DBCS 系列标准里，最大的特点是 <em>两字节长的汉字字符</em> 和 <em>一字节长的英文字符</em> 并存于同一套编码方案里。</p><p>就这样，各个国家都搞出了一套自己的编码标准。就导致会同时存在好多种不同的编码，互相之间不支持也不互通。</p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p><code>Unicode</code> 编码，开发人员应该并不陌生。</p><blockquote><p>ISO：International Organization for Standardization ，国际标准化组织</p><p>Unicode：Universal Multiple-Octet Coded Character Set ，简称 UCS，俗称 Unicode</p></blockquote><p><strong>ISO</strong> 的国际组织废了所有的地区性编码方案，重新搞一个包括了地球上 <em>所有文化<em>、</em>所有字母</em> 和 <em>文字</em> 的编码。</p><p><code>Unicode</code> 是一个很大的集合，现在的规模可以容纳 <em>100多万</em> 个符号。</p><p>ISO 组织直接规定必须用 <em>两个字节（16位）</em> 来表示所有的字符。<code>ASCII</code> 里的那些 <em>半角字符*，<code>Unicode</code> 保持其原编码不变，只是将其长度由原来的 *8</em> 位扩展为<em>16</em> 位，而其他文化和语言的字符则全部重新统一编码。</p><p>从 <code>Unicode</code> 开始，无论是半角的 <em>英文字母</em>，还是全角的 <em>汉字</em>，它们都是统一的一个字符。同时，也都是统一的 <em>两个字节</em>。</p><p><code>Unicode</code> 在很长一段时间内无法推广，直到互联网的出现。</p><h3 id="UTF"><a href="#UTF" class="headerlink" title="UTF"></a>UTF</h3><p>为解决 <code>Unicode</code> 如何在 <em>网络上传输</em> 的问题，面向传输的众多 <code>UTF</code> 标准出现了。</p><blockquote><p>UTF编码：Universal Character Set（UCS）Transfer Format</p></blockquote><p><code>UTF-8</code> 就是在互联网上使用最广的一种 <code>Unicode</code> 的实现方式。</p><p><code>UTF-8</code> 是每次以 <em>8位</em> 为单位进行数据传输，而 <code>UTF-16</code> 是每次以 <em>16位</em> 进行传输的。</p><p><code>UTF-8</code> 是一种变长的编码方式。<code>Unicode</code> 一个中文字符占 <em>2</em> 个字节，而 <code>UTF-8</code> 一个中文字符占 <em>3</em> 个字节。</p><p>换言之，<code>UTF</code> 就是 <code>Unicode</code> 的另一种实现方式。</p><h3 id="Base64-编码规范"><a href="#Base64-编码规范" class="headerlink" title="Base64 编码规范"></a>Base64 编码规范</h3><p><code>Base64</code> 是网络上最常见的用于传输 <em>8位</em> 字节码的编码方式之一。开发中可以替换掉路径，而且可以用于传输。</p><p><code>Base64</code> 编码是从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息。采用 <code>Base64</code> 编码具有不可读性，需要解码后才能阅读。</p><p><code>Base64</code> 要求把每 <em>三个8位</em> 的字节转换为 <em>四个6位</em> 的字节，然后把 <em>6位</em> 再添两位高位0，组成 <em>四个8位</em> 的字节。</p><p><img data-src="pic3.png" alt="base64对应表"></p><p>我们平时会使用 <code>encodeURIComponent()</code> 方法将文字转换成 <em>16进制</em>。</p><h4 id="转化思路"><a href="#转化思路" class="headerlink" title="转化思路"></a>转化思路</h4><p>我们都知道，<em>一个字 3字节，一个字节 8 位</em> 。而 <code>Base64</code> 其实就是将一个汉字转换为 <code>3 * 8 = 4 * 6</code> 的格式，也就是说现在一个汉字会有 <em>4个字节</em> 的长度，转换后的结果会比之前大 1/3。</p><p>我们先随便输出一个汉字，并将其转换成16进制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Buffer.from 可以将汉字转换成 16进制</span></span><br><span class="line"><span class="keyword">let</span> r = Buffer.from(<span class="string">'莫'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// &lt;Buffer e8 8e ab&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以发现，结果是 <em>3个字节</em> 长度的 16进制，挨个转换成 2进制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">0xe8</span>).toString(<span class="number">2</span>)); <span class="comment">// 11101000</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">0x8e</span>).toString(<span class="number">2</span>)); <span class="comment">// 10001110</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">0xab</span>).toString(<span class="number">2</span>)); <span class="comment">// 10101011</span></span><br></pre></td></tr></table></figure><p>再将得到的 2进制 进行拼接，并转换成 <em>4个字节*，并在前面补 0，将其变成 *8位</em> 二进制 。然后我们会得到下面的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 11101000 10001110 10101011</span></span><br><span class="line"><span class="comment">// 00111010 00001000 00111010 00101011</span></span><br></pre></td></tr></table></figure><p>这个结果最大是 <code>001111</code>，然后我们再将这个结果转换成 十进制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">'00111010'</span>,<span class="number">2</span>)); <span class="comment">// 58</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">'00001000'</span>,<span class="number">2</span>)); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">'00111010'</span>,<span class="number">2</span>)); <span class="comment">// 58</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">'00101011'</span>,<span class="number">2</span>)); <span class="comment">// 43</span></span><br></pre></td></tr></table></figure><p>这样我们就会得到一个每位都 <em>不大于64</em> 的结果。</p><p>根据上面写的对应表，我们就可以推算出这个文字对应的 <code>Base64</code> 编码为 <code>6I6r</code>，也就是我们上面写的 <strong>莫</strong> 字。</p><p>把这种思路整理一下，我们就可以得到下述代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CHARTS = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> buf = Buffer.from(str);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> b <span class="keyword">of</span> buf)&#123;</span><br><span class="line">      result += b.toString(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.match(<span class="regexp">/(\d&#123;6&#125;)/g</span>).map(<span class="function"><span class="params">v</span>=&gt;</span><span class="built_in">parseInt</span>(v,<span class="number">2</span>)).map(<span class="function"><span class="params">v</span>=&gt;</span>CHARTS[v]).join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> r = transfer(<span class="string">'莫'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// 6I6r</span></span><br></pre></td></tr></table></figure><p>这样就完成了我们的 <code>Base64</code> 的转换。</p><blockquote><p>本篇文章由 <strong>莫小尚</strong> 创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr&gt;&lt;h2 id=&quot;编码的发展&quot;&gt;&lt;a href=&quot;#编码的发展&quot; class=&quot;headerlink&quot; title=&quot;编码的发展&quot;&gt;&lt;/a&gt;编码的发展&lt;/h2&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://mxshang.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="知识点汇总" scheme="https://mxshang.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    
    <category term="Node" scheme="https://mxshang.github.io/tags/Node/"/>
    
    <category term="JS进阶" scheme="https://mxshang.github.io/tags/JS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记—二进制和精度问题</title>
    <link href="https://mxshang.github.io/2021/12/08/Node%E7%B1%BB/Buffer/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E8%BF%9B%E5%88%B6%E5%92%8C%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/"/>
    <id>https://mxshang.github.io/2021/12/08/Node%E7%B1%BB/Buffer/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E8%BF%9B%E5%88%B6%E5%92%8C%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/</id>
    <published>2021-12-08T06:01:22.000Z</published>
    <updated>2021-12-10T17:40:42.445Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>所谓 <strong>二进制</strong>，就是只用 <em>0</em> 与 <em>1</em> 两个数字，在计数与计算时必须是 <strong>逢2进1</strong> <em>（如十进制的 10 就是二进制的 1010）</em>。</p><p>计算机中所有的内容全都是以 <strong>二进制</strong> 的形式进行存储的，而数据也都是以 <strong>二进制</strong> 的形式来表现的。</p><h3 id="精度问题"><a href="#精度问题" class="headerlink" title="精度问题"></a>精度问题</h3><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly8wLjMwMDAwMDAwMDAwMDAwMDA0LmNvbS8=">Floating Point Math<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>我们首先来思考一个问题，<code>0.1 + 0.2 === 0.3</code> 的输出结果是什么？</p><p>来看一下这道最经典的面试题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>);</span><br></pre></td></tr></table></figure><p>这道题的结果是 <code>false</code> ，我们通过控制台打印可以发现， <em>0.1 + 0.2</em> 的结果并不是 <em>0.3</em>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span>); <span class="comment">// 0.30000000000000004</span></span><br></pre></td></tr></table></figure><p>导致这个问题的原因就和计算机的 <strong>二进制存储</strong> 有关。</p><p>首先我们要先明确计算机数据存储的两个概念。</p><ul><li>计算机将所有数据以 <strong>二进制</strong> 的形式存储。</li><li>计算机用 <strong>有限的大小</strong> 来存储数据。（因为现实生活中不存在无限大的内存或硬盘）</li></ul><p>计算机中的 <em>*最小单位是 *位（bit，比特）</em> **。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- 8 bit =&gt; 1 byte;</span><br><span class="line"></span><br><span class="line">- 1024 byte =&gt; 1 Kb;</span><br><span class="line"></span><br><span class="line">- 1024 Kb =&gt; 1 Mb;</span><br><span class="line"></span><br><span class="line">- 1024 Mb =&gt; 1 Gb;</span><br><span class="line"></span><br><span class="line">- 1024 Gb =&gt; 1 T;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们在进行数据存储时，一般以 <strong>字节</strong> 来进行存储。</p><p><strong>字节（byte）</strong> 的最大值和最小值是 <em>0~255</em> ，也就是说取值范围是 <em>255</em> 。</p><p>取值范围的 <em>255</em> 是因为计算机是通过 <strong>二进制来进行数据存储</strong> 。</p><h3 id="进制的转换"><a href="#进制的转换" class="headerlink" title="进制的转换"></a>进制的转换</h3><p>二进制顾名思义就是 <strong>逢2进1</strong>，十进制就是 <strong>逢10进1</strong>。</p><p>又因为 <code>8bit = 1byte</code>，所以他们之间相差 255。</p><p>二进制 转 十进制 其实就是 <em>当前位的值乘以进制（2），次幂是当前所在位</em>，也就是 <code>1*2^n</code>。</p><p>具体计算代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">Math</span>.pow(<span class="number">2</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 255</span></span><br></pre></td></tr></table></figure><p>计算公式如下。<br>$$<br>∵ 1<em>2^n 且 n&lt;8<br>∴ s = 1</em>2^0 + 1<em>2^2 + … + 1</em>2^7<br>$$</p><p>从 十进制 转 二进制，就是 <em>当前数除以进制（2），并取余。然后将余数倒退，就是最终的结果</em>。比如，<em>5 的二进制就是 101</em>。</p><p><img data-src="pic1.png" alt="5除以2取余数"></p><p>在代码中，我们一般使用 <strong><code>parseInt()</code> 把 任意进制 转成 十进制</strong>。使用 <strong><code>toString()</code> 把 十进制 转成 任意进制</strong>。</p><ul><li>使用 <code>0x</code> 前缀表示 <strong>十六进制</strong>，<code>0o</code> 前缀表示 <strong>八进制</strong>，<code>0b</code> 前缀表示 <strong>二进制</strong>。如 <code>0x64</code> 表示 <em>十进制的100</em>，<code>0o555</code> 表示 <em>十进制的365</em>，<code>0b1111</code> 表示 十进制的15。</li><li><code>toString()</code> 如果不填入参数，则默认转换成 十进制。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任意进制 转成 十进制</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">'20'</span>,<span class="number">10</span>)); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">'11'</span>,<span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">'20'</span>,<span class="number">16</span>)); <span class="comment">// 32</span></span><br><span class="line"><span class="comment">// 十进制 转成 任意进制</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">3</span>).toString(<span class="number">2</span>)); <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3.</span>.toString(<span class="number">2</span>)); <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">77</span>).toString(<span class="number">8</span>)); <span class="comment">// 115 </span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">77</span>).toString(<span class="number">16</span>)); <span class="comment">// 4d </span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">17</span>).toString(<span class="number">8</span>)); <span class="comment">// 21</span></span><br><span class="line"><span class="comment">// 十六进制 转成 任意进制</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">0x64</span>).toString(<span class="number">2</span>));  <span class="comment">// 1100100</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">0x32</span>).toString(<span class="number">8</span>)); <span class="comment">// 62</span></span><br></pre></td></tr></table></figure><h3 id="小数转换"><a href="#小数转换" class="headerlink" title="小数转换"></a>小数转换</h3><p>再回到我们最上面的题目。</p><p>我们现在需要算的是 <strong>小数（浮点数）</strong>，那么我们将小数转换成二进制进行存储，我们就需要用到 <strong>乘二取整法</strong>。</p><p>将 小数（浮点数）乘以2，若计算结果包含整数，则取出整数，记为1。反之则记为0。</p><p>如 <code>0.5 * 2 = 1 …… 0</code> ，则 <em>0.5</em> 的二进制为 <em>0.1</em>。</p><p>现在我们来看一下， <em>0.1</em> 的二进制是多少。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 乘二取整法</span></span><br><span class="line"><span class="comment">// 0.1 * 2 = 0.2 …… 0</span></span><br><span class="line"><span class="comment">// 0.2 * 2 = 0.4 …… 0</span></span><br><span class="line"><span class="comment">// 0.4 * 2 = 0.8 …… 0</span></span><br><span class="line"><span class="comment">// 0.8 * 2 = 1.6 …… 1</span></span><br><span class="line"><span class="comment">// 0.6 * 2 = 1.2 …… 1</span></span><br><span class="line"><span class="comment">// 0.2 * 2 = 0.4 …… 0</span></span><br><span class="line"><span class="comment">// ... 以此类推</span></span><br></pre></td></tr></table></figure><p>我们可以发现，结果是一个无限循环的二进制数 <code>0.0001100110011001100110011001100110011001100110011001101</code>。</p><p>同理我们也可以算出，<em>0.2</em> 的二进制是 <code>0.001100110011001100110011001100110011001100110011001101</code>。</p><p>我们可以发现，<em>0.1</em> 与 <em>0.2</em> 的二进制差了一位，无线数在计算机内部存储时会有长度限制，所以最终会存在错位的情况。</p><p>所以其十进制结果，最后会有几个 二进制单位的1 无法被计算。</p><p>这样才会导致 <code>0.1 + 0.2 === 0.30000000000000004</code>。</p><h3 id="精度问题的解决方案"><a href="#精度问题的解决方案" class="headerlink" title="精度问题的解决方案"></a>精度问题的解决方案</h3><p>推荐使用 <span class="exturl" data-url="aHR0cHM6Ly9tYXRoanMub3JnLw==">Math.js<i class="fa fa-external-link-alt"></i></span> 进行处理，他支持 <code>BigNumber</code> 的数据类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">'mathjs'</span>);</span><br><span class="line"><span class="keyword">let</span> big1 = math.bignumber(<span class="number">0.1</span>);</span><br><span class="line"><span class="keyword">let</span> big2 = math.bignumber(<span class="number">0.2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(math.add(big1, big2)); <span class="comment">// 0.3</span></span><br></pre></td></tr></table></figure><blockquote><p>本篇文章由 <strong>莫小尚</strong> 创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr&gt;&lt;h2 id=&quot;二进制&quot;&gt;&lt;a href=&quot;#二进制&quot; class=&quot;headerlink&quot; title=&quot;二进制&quot;&gt;&lt;/a&gt;二进制&lt;/h2&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://mxshang.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="知识点汇总" scheme="https://mxshang.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    
    <category term="Node" scheme="https://mxshang.github.io/tags/Node/"/>
    
    <category term="JS进阶" scheme="https://mxshang.github.io/tags/JS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记—Node中的Events模块</title>
    <link href="https://mxshang.github.io/2021/11/30/Node%E7%B1%BB/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E7%9A%84Events%E6%A8%A1%E5%9D%97/"/>
    <id>https://mxshang.github.io/2021/11/30/Node%E7%B1%BB/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E7%9A%84Events%E6%A8%A1%E5%9D%97/</id>
    <published>2021-11-30T11:42:22.000Z</published>
    <updated>2021-12-06T20:08:58.837Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="Events模块"><a href="#Events模块" class="headerlink" title="Events模块"></a>Events模块</h2><blockquote><p>参考官网 <span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvZXZlbnRzLmh0bWw=">events 事件触发器 | Node.js<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><code>Events</code> 模块是Node最重要的模块，它提供了一个属性 <code>EventEmitter</code>，<code>EventEmitter</code> 的核心是事件发射与事件监听器。</p><p>Node中大部分的模块，都继承自 <code>Events</code> 模块。</p><ul><li><code>Events</code> 模块是Node对 <strong>发布订阅模式</strong>（<code>publish/subscribe</code>）的实现。一个对象通过这个模块，向另一个对象传递消息。</li><li>该模块通过 <code>EventEmitter</code> 属性，提供了一个构造函数。该构造函数的实例具有 <code>on</code> 方法，可以用来监听指定事件，并触发回调函数。</li><li>任意对象都可以发布指定事件，被 <code>EventEmitter</code> 实例的on方法监听到。</li></ul><h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><blockquote><p>关于 <a href="https://mxshang.github.io/2021/07/12/Promise/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Promise%E4%B9%8B%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/">发布订阅模式</a> ，可以参考我之前的博客文章。</p></blockquote><p>关于 <code>Events</code> 中的发布订阅模式，我们要先清楚它的几个常用方法。</p><ul><li><strong>订阅方法</strong>：<code>on</code> 方法用来订阅事件，订阅是将方法对应成一种一对多的关系。</li><li><strong>发布方法</strong>：<code>emit</code> 用来执行订阅的事件。</li><li><strong>取消订阅</strong>：<code>off</code> 方法可以移除对应的事件监听。</li><li><strong>订阅一次</strong>：<code>once</code> 绑定事件当执行后自动删除订阅的事件。</li></ul><h4 id="on-和-emit"><a href="#on-和-emit" class="headerlink" title="on 和 emit"></a>on 和 emit</h4><p><code>on</code> 方法的第一个参数用来设定类名，第二个参数也是一个函数，里面可以接收发布时传入的参数。</p><p><code>emit</code> 方法第一个参数是类名，之后的参数都是传入 <code>on</code> 方法函数中的参数。</p><p><code>on</code> 和 <code>emit</code> 具体应用可以参考下面这个简单的Demo。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="comment">// 自定义一个 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 原型继承 需要通过实例来调用继承方法</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(Cat.prototype, EventEmitter.prototype);</span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, <span class="string">'睡'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> eat = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(b, <span class="string">'吃'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">cat.on(<span class="string">'猫咪'</span>, sleep)</span><br><span class="line">cat.on(<span class="string">'猫咪'</span>, eat)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 小胡子 吃</span></span><br><span class="line">  <span class="comment">// 小胖仙 睡</span></span><br><span class="line">    cat.emit(<span class="string">'猫咪'</span>, <span class="string">'小胖仙'</span>, <span class="string">'小胡子'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>现在我们可以实现一套 <code>on</code> 和 <code>emit</code> 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._event = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// on 方法</span></span><br><span class="line">EventEmitter.prototype.on = <span class="function"><span class="keyword">function</span> (<span class="params">eventName, callBack</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._event) &#123;</span><br><span class="line">        <span class="keyword">this</span>._event = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._event[eventName]) &#123;</span><br><span class="line">        <span class="keyword">this</span>._event[eventName].push(callBack) <span class="comment">// 相当于 &#123;eventName:[fn1,fn2]&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._event[eventName] = [callBack]; <span class="comment">// 相当于 &#123;eventName:[fn1]&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// emit 方法</span></span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span> (<span class="params">eventName, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._event[eventName].forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">        fn(...args)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="off"><a href="#off" class="headerlink" title="off"></a>off</h4><p><code>off</code> 方法的第一个参数用来设定类名，第二个参数传入需要被移除的函数回调。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 小胡子 吃</span></span><br><span class="line">  <span class="comment">// 小胖仙 睡</span></span><br><span class="line">    cat.emit(<span class="string">'猫咪'</span>, <span class="string">'小胖仙'</span>, <span class="string">'小胡子'</span>)</span><br><span class="line">  cat.off(<span class="string">'猫咪'</span>, sleep);</span><br><span class="line">  <span class="comment">// 小胡子 吃</span></span><br><span class="line">    cat.emit(<span class="string">'猫咪'</span>, <span class="string">'小胖仙'</span>, <span class="string">'小胡子'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>这样我们可以大概判断出来，移除掉和我们传入函数相同的函数，我们很快想到 <a href="https://mxshang.github.io/2021/06/18/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BES6%E7%9A%84%E6%95%B0%E7%BB%84/">filter</a> 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// off 方法</span></span><br><span class="line">EventEmitter.prototype.off = <span class="function"><span class="keyword">function</span> (<span class="params">eventName, callBack</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._event &amp;&amp; <span class="keyword">this</span>._event[eventName]) &#123;</span><br><span class="line">        <span class="keyword">this</span>._event[eventName] = <span class="keyword">this</span>._event[eventName].filter(</span><br><span class="line">          fn =&gt; fn !== callBack &amp;&amp; fn.c !== callBack <span class="comment">// fn.c参考下面的once方法实现</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="once"><a href="#once" class="headerlink" title="once"></a>once</h4><p><code>once</code> 方法的第一个参数用来设定类名，第二个参数传入只需要执行一次的函数回调。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> demolition =<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'拆家'</span>);</span><br><span class="line">&#125;</span><br><span class="line">cat.once(<span class="string">'猫咪'</span>, demolition)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...... 拆家</span></span><br><span class="line">    cat.emit(<span class="string">'猫咪'</span>, <span class="string">'小胖仙'</span>, <span class="string">'小胡子'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>这样我们可以根据之前实现的 <code>on</code> 和 <code>off</code> 来实现此方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// once 方法</span></span><br><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span> (<span class="params">eventName, callBack</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> one = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        callBack();</span><br><span class="line">        <span class="keyword">this</span>.off(eventName, one);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.on(eventName, one);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来这个方法好像没有什么问题，执行起来也全都是正确的。</p><p>但是在一种特殊情况下的时候，还是出现了错误。</p><p>那种情况就是如果我们在执行 <code>once</code> 方法之前，就已经通过 <code>off</code> 方法将其移除了。</p><p>我们实现的方法就不能实现这个需求了，所以我们还需要对 <code>once</code> 方法进行一些修改 <em>（ <code>off</code> 方法已经处理过了）</em>。</p><p>添加一个自定义属性，用来对函数进行 “缓存” 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span> (<span class="params">eventName, callBack</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> one = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    one.c = callBack; <span class="comment">// 自定义一个属性</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就实现了 <code>once</code> 方法。</p><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr&gt;&lt;h2 id=&quot;Events模块&quot;&gt;&lt;a href=&quot;#Events模块&quot; class=&quot;headerlink&quot; title=&quot;Events模块&quot;&gt;&lt;/a&gt;Events模块&lt;/h2&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://mxshang.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="知识点汇总" scheme="https://mxshang.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    
    <category term="Node" scheme="https://mxshang.github.io/tags/Node/"/>
    
    <category term="JS进阶" scheme="https://mxshang.github.io/tags/JS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记—EJS模板引擎的使用与原理</title>
    <link href="https://mxshang.github.io/2021/11/29/Node%E7%B1%BB/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94EJS%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
    <id>https://mxshang.github.io/2021/11/29/Node%E7%B1%BB/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94EJS%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/</id>
    <published>2021-11-29T11:42:22.000Z</published>
    <updated>2021-12-06T20:07:39.287Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>首先我们要先清楚，什么是 <strong>模板引擎</strong> ？</p><p>模板引擎的诞生是为了将显示与数据分离。</p><p>模板技术多种多样，但其本质是将模板文件和数据通过模板引擎生成最终的HTML代码。</p><p>这里我们以最常见的模板引擎 <em>EJS</em> 举例说明。</p><h3 id="EJS的使用"><a href="#EJS的使用" class="headerlink" title="EJS的使用"></a>EJS的使用</h3><p>本篇文章我们不讲使用，主要是为了手写实现 <code>EJS</code> 的原理。</p><blockquote><p>参考官网 <span class="exturl" data-url="aHR0cHM6Ly9lanMuYm9vdGNzcy5jb20v">EJS|嵌入式JavaScript模板引擎<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>首先我们先对EJS进行安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 利用NPM安装</span><br><span class="line">$ npm install ejs</span><br></pre></td></tr></table></figure><p>在目录中，我们可以创建一个 <code>template.html</code> 的html文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%=name%</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%=age%</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加两个标签用来做渲染。</p><p>再创建一个 <code>ejs.js</code> 的文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ejs = <span class="built_in">require</span>(<span class="string">'ejs'</span>); <span class="comment">// 导入ejs</span></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> r = <span class="keyword">await</span> ejs.renderFile(<span class="string">'./template.html'</span>,&#123;<span class="attr">name</span>:<span class="string">'momo'</span>,<span class="attr">age</span>:<span class="number">26</span>&#125;) <span class="comment">// 使用renderFile进行渲染</span></span><br><span class="line">    <span class="built_in">console</span>.log(r); <span class="comment">// 打印出结果</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>打印后发现，<em>name</em> 和 <em>age</em> 已经被渲染在了视图<em>（字符串）</em>上。</p><p><img data-src="pic18.png" alt="node控制台中打印结果"></p><p>通过上述的打印结果，我们便可以尝试手写实现 <code>ejs类</code>。</p><h3 id="EJS的实现原理"><a href="#EJS的实现原理" class="headerlink" title="EJS的实现原理"></a>EJS的实现原理</h3><p>首先，先根据需要的参数内容，实现一个类<em>（函数）</em>，里面包含一个 <code>readerFile</code> 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ejs = &#123;</span><br><span class="line">  readerFile(filename,options)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来实现一套简单的 <code>renderFile</code> 方法。</p><h4 id="简单情况"><a href="#简单情况" class="headerlink" title="简单情况"></a>简单情况</h4><p>先做一套最简单的实现，熟悉一下原理和逻辑。</p><p>来看一下完整代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">"util"</span>);</span><br><span class="line"><span class="keyword">const</span> read = util.promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ejs = &#123;</span><br><span class="line">  <span class="keyword">async</span> renderFile(filename, options) &#123;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="keyword">await</span> read(filename, <span class="string">"utf-8"</span>);</span><br><span class="line">    content = content.replace(<span class="regexp">/&lt;%=(.+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> options[<span class="built_in">arguments</span>[<span class="number">1</span>]];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为 <code>readerFile</code> 需要对文件进行读写，所以我们还需要封装一个可以进行读写的 <code>read</code> 方法。</p><p>根据我之前文章中的写法，我们可以利用 <a href="https://mxshang.github.io/2021/08/05/Promise/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Promise%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95/">promisify</a> 对读写方法进行封装。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> read = util.promisify(fs.readFile);</span><br></pre></td></tr></table></figure><p>这样我们就得到了一个可以进行异步读写的 <code>read</code> 函数。</p><p>随后我们将 <code>read</code> 函数放到我们上面的 <code>readerFile</code> 方法中，我们现在就得到了一个可以读取html模板的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ejs = &#123;</span><br><span class="line">  <span class="keyword">async</span> renderFile(filename, options) &#123;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="keyword">await</span> read(filename,<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(content); <span class="comment">// 可以直接打印出html文件模板</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>随后我们就可以对方法进行进一步处理了。</p><p>下一步我们就需要对 <code>&lt;%= ... %&gt;</code> 进行替换处理了。</p><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9yZWdleHAvcmVnZXhwLXN5bnRheC5odG1s">正则表达式 | 菜鸟教程<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>使用 <em>正则表达式</em> 对匹配的内容进行替换处理即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ejs = &#123;</span><br><span class="line">  <span class="keyword">async</span> renderFile(filename, options) &#123;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="keyword">await</span> read(filename,<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="comment">// 正则匹配内容，替换并输出结果</span></span><br><span class="line">    content = content.replace(<span class="regexp">/&lt;%=(.+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> options[<span class="built_in">arguments</span>[<span class="number">1</span>]]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样我们就实现了一套最简单的 <code>ejs.renderFile</code> 方法。</p><h4 id="复杂情况"><a href="#复杂情况" class="headerlink" title="复杂情况"></a>复杂情况</h4><p>实现了上面的简单情况，我们再来实现一种复杂情况。</p><p>还是上面那个例子，假设我们在 <code>html</code> 模板中去渲染 <em>数组</em>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%arr.forEach((item)=</span>&gt;</span>&#123;%&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">%=item%</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%&#125;)%</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>js</code> 中也许要进行对应的修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js</span></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> r = <span class="keyword">await</span> ejs.renderFile(<span class="string">"./template.html"</span>, &#123;</span><br><span class="line">    arr: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(r); <span class="comment">// 数组模板被渲染出来了</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>我们上面的简单情况的实现方式就无法满足这个需求，所以我们需要一套处理复杂情况的实现方式。</p><p>我们需要对上面的 <strong>简单情况</strong> 的实现方式代码进行一些 <strong>修改</strong> 。</p><p>先来看一下完整的实现代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">"util"</span>);</span><br><span class="line"><span class="keyword">const</span> read = util.promisify(fs.readFile);</span><br><span class="line"><span class="comment">// 复杂情况的实现</span></span><br><span class="line"><span class="keyword">let</span> ejs = &#123;</span><br><span class="line">  <span class="keyword">async</span> renderFile(filename, options) &#123;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="keyword">await</span> read(filename, <span class="string">"utf-8"</span>);</span><br><span class="line">    content = content.replace(<span class="regexp">/&lt;%=(.+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'$&#123;'</span> + <span class="built_in">arguments</span>[<span class="number">1</span>] + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> head = <span class="string">'let str = "";\nwith(obj)&#123;\nstr +=`'</span>;</span><br><span class="line">    <span class="keyword">let</span> body = content = content.replace(<span class="regexp">/&lt;%(.+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'`\n'</span> + <span class="built_in">arguments</span>[<span class="number">1</span>] + <span class="string">'\nstr+=`'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> foot = <span class="string">'`&#125; return str'</span></span><br><span class="line">    <span class="keyword">let</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'obj'</span>, head + body + foot)</span><br><span class="line">    <span class="keyword">return</span> fn(options);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> r = <span class="keyword">await</span> ejs.renderFile(<span class="string">"./template.html"</span>, &#123;</span><br><span class="line">    arr: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>在实现代码之前，我们需要先对其实现原理进行一些分析。</p><ol><li><p><strong>字符串拼接</strong></p><p><code>webpack.loader</code> 的底层实现其实就是 <em>字符串拼接</em> 。我们可以利用这种思路，来对我们需要重新拼接的模板进行拆分并拼接。</p><p>我们先来看一下完整的 <code>html</code> 文件是什么样的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%arr.forEach((item)=</span>&gt;</span>&#123;%&gt;</span><br><span class="line">    <span class="comment">&lt;!-- &lt;li&gt;&lt;%=item%&gt;&lt;/li&gt; --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 上面是原本需要输出的结果，这里先不考虑item --&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%&#125;)%</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在我们读取文件时，我们其实读取到的是一串 <em>字符串</em> 。</p><p>所以我们最终 <em>需要输出的模板</em> ，其实是下面这个样子的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">""</span>;</span><br><span class="line"><span class="comment">// 截取第一个&lt;% 之前的代码 </span></span><br><span class="line">str += <span class="string">`&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">&lt;html lang="en"&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">    &lt;meta charset="UTF-8"&gt;</span></span><br><span class="line"><span class="string">    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;</span></span><br><span class="line"><span class="string">    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;Document&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;`</span></span><br><span class="line"><span class="comment">// 拼接 forEach 的结果</span></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    str += <span class="string">`&lt;li&gt;1&lt;/li&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 拼接 末尾</span></span><br><span class="line">str += <span class="string">`</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;`</span></span><br></pre></td></tr></table></figure><p>要将代码拼接成上述效果， <em>实现原理的代码</em> 就变成了这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">let</span> ejs = &#123;</span><br><span class="line">  <span class="keyword">async</span> renderFile(filename, options) &#123;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="keyword">await</span> read(filename, <span class="string">"utf-8"</span>);</span><br><span class="line">    <span class="keyword">let</span> head = <span class="string">'let str = "";\nstr +=`'</span>;</span><br><span class="line">    <span class="keyword">let</span> body = content = content.replace(<span class="regexp">/&lt;%(.+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'`\n'</span> + <span class="built_in">arguments</span>[<span class="number">1</span>] + <span class="string">'\nstr+=`'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> foot = <span class="string">'`'</span></span><br><span class="line">    <span class="keyword">return</span> head + body + foot;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>with</code> 处理循环</strong></p><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvU3RhdGVtZW50cy93aXRo">with - JavaScript | MDN<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>为什么要用 <code>with</code> ？ 因为 <code>with</code> 可以使当前代码运行在指定的作用域内。</p><p>所以 <em>最终模板</em> 就会被渲染成这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">""</span>;</span><br><span class="line"><span class="comment">// obj就是传入的参数 options，也就是 &#123;arr:[1,2,3]&#125;</span></span><br><span class="line"><span class="keyword">with</span>(obj)&#123;</span><br><span class="line">str += <span class="string">`&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">&lt;html lang="en"&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">    &lt;meta charset="UTF-8"&gt;</span></span><br><span class="line"><span class="string">    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;</span></span><br><span class="line"><span class="string">    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;Document&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;`</span></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    str += <span class="string">`&lt;li&gt;1&lt;/li&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line">str += <span class="string">`</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么会有一个 <code>obj</code> ？ 下一步分析中会详细说明。</p><p>我们再对 <em>实现代码</em> 进行一些修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">let</span> head = <span class="string">'let str = "";\nwith(obj)&#123;\nstr +=`'</span>;</span><br><span class="line"><span class="keyword">let</span> body = content = content.replace(<span class="regexp">/&lt;%(.+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'`\n'</span> + <span class="built_in">arguments</span>[<span class="number">1</span>] + <span class="string">'\nstr+=`'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> foot = <span class="string">'`&#125;'</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>其实就是在需要拼接的代码里面，加上 <code>with</code> 就可以了。</p></li><li><p><strong><code>new Function</code> 创建函数模板</strong></p><p>在上一步中，我们出现了一个不知名参数 <code>obj</code>。</p><p>我在注释中解释为，<em>传入的参数</em> 。</p><p>通过一个函数，将参数传入 模板中，并执行最终的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">with</span> (obj) &#123;</span><br><span class="line">    str += <span class="string">`&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">&lt;html lang="en"&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">    &lt;meta charset="UTF-8"&gt;</span></span><br><span class="line"><span class="string">    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;</span></span><br><span class="line"><span class="string">    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;Document&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      str += <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;li&gt;1&lt;/li&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    str += <span class="string">`</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">fn(&#123; <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &#125;);</span><br></pre></td></tr></table></figure><p>其实就是在最外层套了一个 <code>function</code> 函数，里面有传入的参数 <em>{arr: [1, 2, 3]}</em>。</p><p>这样，我们在 <em>实现代码</em> 中，便可以使用 <a href="https://mxshang.github.io/2021/11/16/Node-%E4%B8%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/">new Function</a> 来实现此思路。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="keyword">let</span> foot = <span class="string">'`&#125; return str'</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'obj'</span>, head + body + foot)</span><br><span class="line"><span class="keyword">return</span> fn(options);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><code>obj</code> 作为参数，<em>拼接的字符串</em> 作为函数执行。</p><p>这时我们可以发现，结果变成了我们想要的样子。</p><p>现在我们来进行最后一步，处理循环的结果。</p></li><li><p><strong>处理循环结果</strong></p><p>我们先将 <code>html</code> 里面的注释去掉。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%arr.forEach((item)=</span>&gt;</span>&#123;%&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">%=item%</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;li&gt;1&lt;/li&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%&#125;)%</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过上面分析中的函数模板，要输出 <code>item</code> ，其实只要使用 <em>模板字符串 <code>${}</code></em> 即可。</p><p>所以我们可以对上面的模板添加一个替换条件即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">content = content.replace(<span class="regexp">/&lt;%=(.+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'$&#123;'</span> + <span class="built_in">arguments</span>[<span class="number">1</span>] + <span class="string">'&#125;'</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这样我们就实现了 <code>ejs.renderFile</code> 方法的 <strong>复杂情况</strong>。</p></li></ol><p>在实际工作和面试中，很少会手写这种形式的代码。</p><p>我们只需要了解其实现原理即可。</p><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr&gt;&lt;h2 id=&quot;模板引擎&quot;&gt;&lt;a href=&quot;#模板引擎&quot; class=&quot;headerlink&quot; title=&quot;模板引擎&quot;&gt;&lt;/a&gt;模板引擎&lt;/h2&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://mxshang.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="知识点汇总" scheme="https://mxshang.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    
    <category term="Node" scheme="https://mxshang.github.io/tags/Node/"/>
    
    <category term="JS进阶" scheme="https://mxshang.github.io/tags/JS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记—Node中第三方模块</title>
    <link href="https://mxshang.github.io/2021/11/23/Node%E7%B1%BB/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/"/>
    <id>https://mxshang.github.io/2021/11/23/Node%E7%B1%BB/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/</id>
    <published>2021-11-23T11:42:22.000Z</published>
    <updated>2021-11-24T00:29:00.527Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h2><p>第三方模块的引用也是 <em>没有绝对路径</em> 的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(r);</span><br></pre></td></tr></table></figure><p>第三方模块的 <strong>引用形式主要分为两种</strong>：</p><ul><li><p><strong>全局模块</strong>，直接<strong>安装到电脑的npm目录下</strong>。</p></li><li><p><strong>内置的第三方模块</strong>，默认会沿着 <strong>当前目录向上查找 <code>node_modules</code> 下的同名文件夹，先根据 <code>package.json</code> 中的 <code>main</code> 设定的文件查找。如不存在，再到 <code>index.js</code> 中查找</strong>。如果自己的目录下未找到 <code>node_modules</code>，则会向上查找。<em>（可以通过打印 <code>module.paths</code> 进行路径查找）</em></p><p>假设我们在当前目录下，新建一个 <code>node_modules</code> ，在里面自定义一个文件夹名为 <code>co</code>，文件夹内包含一个 <code>index.js</code> 文件。文件里面写上内容 <code>module.exports = &quot;hello&quot;</code>。</p><p>这时我们再重新打印，发现上面的结果变成了 <code>hello</code>。</p><p>原因就是因为 <strong>第三方模块的查找规则</strong>。</p></li></ul><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm5wbWpzLmNvbS8=">npm Docs<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tLw==">npm<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>作为前端工程师，应该对<code>npm</code>并不陌生。（ <em>现在不建议使用 <code>cnpm</code> ，无法锁定版本，可能会出现很多奇怪的问题。目前推荐使用 <code>nrm</code> 或 <code>yarn</code></em> ）</p><p>这里我们介绍一下 ” <em>3n模块</em> “</p><ul><li><code>npm</code> 全称 <code>node package manager</code> ，是nodejs的包管理器 ，用于node插件管理，包括安装、卸载、管理依赖等。</li><li><code>nrm</code> 全称 <code>node registry manager</code> ，是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在 npm 源间切换。<em>（例：<code>nrm use taobao</code> 、 <code>nrm use cnpm</code> 等…）</em></li><li><code>nvm</code> 全称 <code>node version manager</code> ，是一个nodejs的版本管理工具，通过它可以安装和切换不同版本的 node 和 npm。</li></ul><p>使用npm安装的模块就是 <strong>全局模块</strong>，这种模块无法被 <code>require</code> 引用，<strong>只能通过命令行使用</strong>。</p><p><img data-src="pic11.png" alt="npm root -g"></p><p>我们之所以可以在 <em>cmd控制台</em> 直接访问npm或node，是因为在环境变量的Path属性上进行了配置。</p><p>而我们通过 npm安装的 <strong>全局模块</strong> ，会 <em>在npm目录下生成一个快捷方式</em> ，所以我们可以通过命令行使用全局模块。</p><h3 id="配置命令行命令"><a href="#配置命令行命令" class="headerlink" title="配置命令行命令"></a>配置命令行命令</h3><p>假设我们现在有一个需要在命令行中输出的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; .&#x2F;bin&#x2F;www</span><br><span class="line">console.log(&#39;a&#39;)</span><br></pre></td></tr></table></figure><p>我们该如何进行配置呢？</p><p>首先通过命令行 <code>npm init -y</code> 生成默认的配置文件。</p><p><img data-src="pic12.png" alt="package.json"></p><p>在文件中添加属性 <code>bin</code> ，并在 <code>bin</code> 中添加相应的文件路径。<em>（我们也可以自定义一个命令，进行简便操作）</em></p><p><img data-src="pic13.png" alt="package.json"></p><p>我们将配置文件配置好后，需要放置到全局环境下。 这时有两种方式可以进行操作：</p><ul><li>发布到全局模块环境，并进行发布。</li><li>使用 <code>npm link</code> ，将我们当前文件link到 <em>node_module</em> 文件夹下。<em>（当前推荐使用这种，方便调试）</em></li></ul><p>这时我们可以看到，当前自定义命令 <code>&quot;gm&quot;</code> 已经映射到了我们当前的文件目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 控制台打印</span><br><span class="line">C:\Users\XXX\AppData\Roaming\npm\gm -&gt; C:\Users\XXX\AppData\Roaming\npm\node_modules\global-modules\bin\www</span><br><span class="line">C:\Users\XXX\AppData\Roaming\npm\node_modules\global-modules -&gt; D:\xxxx\xxxx\xxxx\xxx\xxx\global-modules</span><br></pre></td></tr></table></figure><p>但是我们现在还无法直接使用 <code>&quot;gm&quot;</code> 命令，我们还需要配置一个运行方式。</p><p>在我们之前创建好的文件最开头，输入 <code>#! /usr/bin/env node</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env node</span><br><span class="line">console.log(&#39;a&#39;)</span><br></pre></td></tr></table></figure><p>这行代码的意思就是告诉我们的命令行，当前文件是用当前环境变量里面node运行的。</p><p>修改了运行方式，我们需要重新运行 <code>npm link --force</code> 。<em>（<code>--force</code> 覆盖之前的配置文件）</em></p><p>这样我们就可以在命令行中输出我们配置文件中的内容了。</p><p><img data-src="pic14.png" alt="控制台输出"></p><p>我们可以通过这种方式，实现一些自定义的全局包，就可以采用这种方式进行配置。</p><p><strong>总结一下</strong>：</p><ol><li>先生成默认的配置文件。</li><li>配置 <code>bin</code> 命令。</li><li>在指定文件下添加执行方式 <code>#! /usr/bin/env node</code>。</li><li>将此包放到npm下，可以发布到全局环境，也可以使用 <code>npm link</code> 进行临时调试。</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr&gt;&lt;h2 id=&quot;第三方模块&quot;&gt;&lt;a href=&quot;#第三方模块&quot; class=&quot;headerlink&quot; title=&quot;第三方模块&quot;&gt;&lt;/a&gt;第三方模块&lt;/h2&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://mxshang.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="知识点汇总" scheme="https://mxshang.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    
    <category term="Node" scheme="https://mxshang.github.io/tags/Node/"/>
    
    <category term="JS进阶" scheme="https://mxshang.github.io/tags/JS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记—Node中模块查找规范</title>
    <link href="https://mxshang.github.io/2021/11/22/Node%E7%B1%BB/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E6%A8%A1%E5%9D%97%E6%9F%A5%E6%89%BE%E8%A7%84%E8%8C%83/"/>
    <id>https://mxshang.github.io/2021/11/22/Node%E7%B1%BB/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E6%A8%A1%E5%9D%97%E6%9F%A5%E6%89%BE%E8%A7%84%E8%8C%83/</id>
    <published>2021-11-22T11:42:22.000Z</published>
    <updated>2021-11-24T00:26:32.690Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><p>在学习其他模块之前，我们先要清楚 <em>文件模块中的查找规范</em> 。</p><h2 id="模块查找规范"><a href="#模块查找规范" class="headerlink" title="模块查找规范"></a>模块查找规范</h2><p>引用自定义模块时，会自动查找目标目录下的 <em>index.js文件</em> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /jQuery/index.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">"jquery"</span></span><br><span class="line"><span class="comment">// /main.js</span></span><br><span class="line"><span class="keyword">const</span> jQuery = <span class="built_in">require</span>(<span class="string">'./jQuery'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(jQuery); <span class="comment">// jquery</span></span><br></pre></td></tr></table></figure><p>但是如果我们不去定义 <em>index.js</em>，则会出现无法查找文件的问题，也就是报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /jQuery/a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">"jquery"</span></span><br><span class="line"><span class="comment">// /main.js</span></span><br><span class="line"><span class="keyword">const</span> jQuery = <span class="built_in">require</span>(<span class="string">'./jQuery'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(jQuery); <span class="comment">// Cannot find module './jQuery'</span></span><br></pre></td></tr></table></figure><p>这样我们就需要一个描述文件 <code>package.json</code> ，在文件中有一个 <code>main</code> 属性，可以定义文件入口。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /jQuery/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"main"</span>:<span class="string">"./jQuery/a.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们再重新打印，发现结果被成功打印了出来。</p><p>所以我们可以总结一下文件模块的 <strong>查找规范</strong>：</p><ul><li>在 <strong>最新的node版本</strong>中，默认 <em>先查找同名文件</em> 。如果没找到，则尝试添加查找 <em>.js和.json文件</em> 。如果还是没有，会查找 <em>同名文件夹（当成了一个包）</em>，找到后，会先找 <em>package.json</em>文件。如果没有，则会继续查找 <em>index.js文件</em>。如果依旧不存在，则会报错。</li><li>在 <strong>老版本的node中</strong>， 如果 <em>有package.json</em> 的情况下，会<em>先找同名包</em>。如果 <em>没有package.json</em>，会去 <em>查找同名文件</em>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 新版node查找流程</span><br><span class="line">│</span><br><span class="line">└───┤ 同名文件</span><br><span class="line"> │</span><br><span class="line"> │──┤ 同名.js &#x2F; 同名.json</span><br><span class="line"> │</span><br><span class="line"> │──┤ 同名文件夹</span><br><span class="line">    │</span><br><span class="line">    │───┤ pageage.json</span><br><span class="line">    │</span><br><span class="line">    └───┤ index.js</span><br><span class="line">   </span><br><span class="line"> 都没找到，则抛出一个错误。</span><br></pre></td></tr></table></figure><p>这就是node的自定义模块查找规范，我们在平时面试的时候可能会遇到这种问题。</p><p>比如介绍一下 <em>node的模块查找机制<em>，我们就可以用这种方式去介绍。</em>（目前一般很少有问老版本node的查找机制，一般都会问两种查找机制的区别，感兴趣的可以去查阅相关资料。）</em></p><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr&gt;&lt;p&gt;在学习其他模块之前，我们先要清楚 &lt;em&gt;文件模块中的查找规范&lt;/em&gt; 。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://mxshang.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="知识点汇总" scheme="https://mxshang.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    
    <category term="Node" scheme="https://mxshang.github.io/tags/Node/"/>
    
    <category term="JS进阶" scheme="https://mxshang.github.io/tags/JS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记—Npm的介绍与使用</title>
    <link href="https://mxshang.github.io/2021/11/22/Node%E7%B1%BB/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94npm%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://mxshang.github.io/2021/11/22/Node%E7%B1%BB/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94npm%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2021-11-22T11:42:22.000Z</published>
    <updated>2021-12-06T20:07:36.360Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="npm的介绍与使用"><a href="#npm的介绍与使用" class="headerlink" title="npm的介绍与使用"></a>npm的介绍与使用</h2><blockquote><p>官方网站 <span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tLw==">https://www.npmjs.com/<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><code>npm</code> 全称 <code>node package manager</code> ，是 nodejs 的包管理器 ，用于 node 插件管理，包括安装、卸载、管理依赖等。</p><h3 id="常用命令与配置"><a href="#常用命令与配置" class="headerlink" title="常用命令与配置"></a>常用命令与配置</h3><p>这里我们只总结一些平时工作中会经常用到的 <em>命令</em> 和 <em>配置</em>。</p><h4 id="npm-init"><a href="#npm-init" class="headerlink" title="npm init"></a>npm init</h4><p>默认安装一个 <code>package.json</code> 的文件，直接使用 <code>npm init -y</code> 进行安装。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"npm"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来介绍几个重要字段。</p><ul><li><strong>name</strong> ：当前包的 <strong>名字</strong> ，也就是最终发布到 <span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tLw==">npm官网<i class="fa fa-external-link-alt"></i></span> 上包的名字，不能和已有的包重名。</li><li><strong>version</strong>: 当前包的 <strong>版本号</strong> 。</li><li><strong>main</strong>：当前包的 <strong>入口文件</strong> ，也就是使用 <code>require</code> 默认引入的文件。</li><li><strong>scripts</strong>：可以配置一些 <strong>执行脚本</strong> ，如 <em>测试脚本</em> 等。</li><li><strong>license</strong>：<strong>协议许可</strong>。</li></ul><h4 id="npm-install"><a href="#npm-install" class="headerlink" title="npm install"></a>npm install</h4><p><code>npm install</code> 安装指定的包，简写为 <code>npm i</code>。 后面可以添加 <em>依赖关系</em>。</p><p>安装方式分为 <strong>全局安装</strong> 和 <strong>本地安装</strong>。</p><ul><li><p><strong>全局安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装一个全局 http 服务。</span></span><br><span class="line">npm install http-server -g</span><br></pre></td></tr></table></figure><p><strong>全局安装</strong> 的意思很简单，就是安装的模块会被安装到全局下。</p><p>可以在命令行中直接使用安装的包，其实只是在 <code>/user/local/bin</code> 目录下做了个 <em>链接</em> 连接到 <code>/usr/local/lib/node_modules/http-server/bin/http-server</code> 这个文件下。</p><p>当我们执行 <code>http-server</code> 这个命令时，会调用<em>链接</em> 到这个文件。<em>（mac因为有权限问题，这里我们可以加 <code>sudo</code> 来执行命令）</em></p><blockquote><p>关于此部分的使用，可以参考 我的博客 <a href="https://mxshang.github.io/2021/11/23/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/">node中第三方模块</a>。</p></blockquote><p>我们可以自己来尝试写一个包，创建bin目录，新增www文件。随便起一个名字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #! 表示采用node来执行此文件，同理 shell可以表示 sh</span></span><br><span class="line"><span class="meta">#! /usr/bin/env node</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'莫小尚'</span>);</span><br></pre></td></tr></table></figure><p>更新 <code>package.json</code> 文件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"bin": &#123;</span><br><span class="line">"my-pack":"./bin/www" // 这里要注意名字和你建立的文件夹相同</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>再用一个常用的命令实现链接的功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link</span><br></pre></td></tr></table></figure><p>这样我们在命令行中直接输入 <code>my-pack</code> 就可以 打印出结果。</p></li></ul><ul><li><p><strong>本地安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack --save-dev</span><br></pre></td></tr></table></figure><p><strong>本地安装</strong> 就是在项目中使用，而非在命令行中使用。</p><p>执行上述命令，可以生成一个 <code>package-lock.json</code> 文件。</p><p>安装后的模块被安装到了 <code>node_modules</code> 下，并且在 <code>package.json</code> 中也增加了一些内容。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"devDependencies": &#123;</span><br><span class="line">    "webpack": "^4.39.3"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过添加后缀，指定版本号来安装包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i jquery@2.2.0</span><br></pre></td></tr></table></figure><p><em>（默认执行 <code>npm i</code>会安装项目中所需要的依赖，如果只想安装生产环境依赖可以增加 <code>--production</code>参数）</em></p><p>下面我们来介绍一下 <code>package-lock</code> 文件。</p></li></ul><h5 id="package-lock-文件"><a href="#package-lock-文件" class="headerlink" title="package-lock 文件"></a>package-lock 文件</h5><p><code>package-lock.json</code> 的作用是 <em>锁定依赖安装结构</em> ，保证在任意机器上执行 <code>npm install</code> 都会得到完全相同的 <code>node_modules</code> ，因为<code>package-lock.json</code> 存储所有安装的信息。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"my-pack"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"lockfileVersion"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"requires"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">  <span class="attr">"@webassemblyjs/ast"</span>: &#123; </span><br><span class="line">      <span class="attr">"version"</span>: <span class="string">"1.8.5"</span>, <span class="comment">// 当前依赖的版本</span></span><br><span class="line">      <span class="attr">"resolved"</span>: <span class="string">"https://registry.npm.taobao.org/@webassemblyjs/ast/download/@webassemblyjs/ast-1.8.5.tgz"</span>, <span class="comment">// 从哪个渠道安装的</span></span><br><span class="line">      <span class="attr">"integrity"</span>: <span class="string">"sha1-UbHF/mV2o0lTv0slPfnw1JDZ41k="</span>, <span class="comment">// 内容hash</span></span><br><span class="line">      <span class="attr">"dev"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"requires"</span>: &#123;</span><br><span class="line">      <span class="attr">"@webassemblyjs/helper-module-context"</span>: <span class="string">"1.8.5"</span>,</span><br><span class="line">      <span class="attr">"@webassemblyjs/helper-wasm-bytecode"</span>: <span class="string">"1.8.5"</span>,</span><br><span class="line">      <span class="attr">"@webassemblyjs/wast-parser"</span>: <span class="string">"1.8.5"</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><em>（如果手动更新了 <code>package.json</code>文件，执行安装命令会下载对应的新版本，并且会自动更新 <code>package-lock</code> 文件）</em></p><h4 id="scripts配置"><a href="#scripts配置" class="headerlink" title="scripts配置"></a>scripts配置</h4><p>在 <code>package.json</code> 中可以定义自己的脚本通过 <code>npm run</code> 来执行。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">   "hello": "echo hello",</span><br><span class="line">   "build": "webpack"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用 <code>npm run hello</code> 执行自定义脚本，也可以使用 <code>npm run build</code> 执行<code>node_modules/.bin</code> 目录下的 <em>webpack文件</em>。</p><ul><li><p><code>npm run</code> 命令执行时，会把 <code>./node_modules/.bin/</code> 目录添加到执行环境的 <code>PATH</code> 变量中。因此如果某个 <strong>命令行包</strong> 未全局安装，而只安装在了当前项目的 <code>node_modules</code> 中，通过 <code>npm run</code> 一样可以执行该命令。</p></li><li><p>执行 <em>npm脚本</em> 时要传入参数，需要在命令后加 <code>--</code> 标明。如 <code>npm run hello -- --port 3000</code> 可以将 <code>--port</code> 参数传给<code>hello</code> 命令。</p></li><li><p>npm 提供了 <code>pre</code> 和 <code>post</code> 两种钩子机制。可以定义某个脚本前后的执行脚本，没有定义默认会忽略。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">   "prehello":"echo prehello",</span><br><span class="line">   "hello": "echo hello",</span><br><span class="line">   "posthello":"echo posthello"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><em>（通过打印 全局 env 和 在项目下执行 <code>npm run env</code>来对比<code>PATH</code>属性，不难发现在执行 <code>npm run</code> 的时候确实会将 <code>./node_modules/.bin/</code> 目录添加到<code>PATH</code> 中）</em></p><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>依赖关系分为以下几种：</p><ul><li><strong>开发依赖</strong> <code>devDependencies</code>，开发时使用的依赖，上线时就不需要了。如 <em>webpack</em> 、 <em>gulp</em> 等。</li><li><strong>生产依赖</strong> <code>dependencies</code>，开发时会用，上线的时候也需要。如 <em>vue</em> 等。</li><li><strong>同等依赖</strong> <code>peerDependencies</code>，安装某个库时，提示需要用到的其他依赖。如 <em>安装bootstrap</em> ，则需要用到依赖 <em>jQuery</em> 。</li><li><strong>可选依赖</strong> <code>optionalDependencies</code>，如果有一些依赖包即使安装失败，项目仍然能够运行或者希望npm继续运行。</li><li><strong>打包依赖 (捆绑依赖)</strong> <code>bundledDependencies</code>，将这个对象中的包打包到最终的发布包里，就是将节点内的包压缩到一个压缩包中。</li></ul><p>开发中用的最多的就是 <strong>开发依赖</strong> 、 <strong>生产依赖</strong> 和 <strong>同等依赖</strong>。</p><h4 id="开发依赖-和-生产依赖"><a href="#开发依赖-和-生产依赖" class="headerlink" title="开发依赖 和 生产依赖"></a>开发依赖 和 生产依赖</h4><p>开发依赖，<strong>开发环境所需要的依赖</strong>。同理，生产依赖，就是 <strong>生产环境所需要的依赖</strong>。</p><ul><li><strong>–save</strong>：将保存配置信息到 <em>package.json*，默认为 *dependencies</em> 节点中。</li><li><strong>–save-dev</strong>：默认为 <em>devDependencies</em> 节点中。</li></ul><p>在实际开发中，我们 <strong>不填写任何标识</strong>，则会默认安装到 <strong>生产环境</strong> 中。</p><p><img data-src="pic15.png" alt="devDependencies节点"></p><p>假设我们需要安装到 <strong>开发环境</strong> ，则填写标识 <code>--save-dev</code> 即可。</p><p><img data-src="pic16.png" alt="dependencies节点"></p><p>如果我们现在有一个 <em>github</em> 上克隆的开源项目，我们需要安装当前项目所需要的插件和各种依赖。</p><p>直接使用命令 <code>npm install</code> ，就会将上述两个节点下的依赖全部加载到 <code>node_modules</code> 下。</p><p>假设我们现在只需要 <em>生产依赖</em> ，则在后面加上节点 <em>production</em> 即可。 <code>npm install --production</code></p><h4 id="同等依赖"><a href="#同等依赖" class="headerlink" title="同等依赖"></a>同等依赖</h4><p>同等依赖，就是节点 <em>peerDependencies</em> 。</p><p>在安装时会提示我们需要用到的 <em>同等依赖包</em> 有哪些，起到一个提示的作用。</p><p><img data-src="pic17.png" alt="peerDependencies节点"></p><h3 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h3><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY24vbWlzYy9zZW12ZXIv">semver | npm中文文档<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>npm采用了 <strong><code>semver</code>规范</strong> 作为依赖版本管理方案，<code>semver</code> 约定一个包的版本号必须包含3个数字。</p><p><code>MAJOR.MINOR.PATCH</code> 意思是 <em>主版本号.小版本号.修订版本号</em> 。</p><ul><li><code>MAJOR</code> 对应大的版本号迭代，做了不兼容旧版的修改时要更新 <code>MAJOR</code> 版本号。</li><li><code>MINOR</code> 对应小版本迭代，发生兼容旧版API的修改或功能更新时，更新 <code>MINOR</code> 版本号。</li><li><code>PATCH</code> 对应修订版本号，一般针对修复 BUG 的版本号。</li></ul><p>当我们每次发布包的时候都需要升级版本号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm version major  <span class="comment"># 大版本号加 1，其余版本号归 0</span></span><br><span class="line">npm version minor  <span class="comment"># 小版本号加 1，修订号归 0</span></span><br><span class="line">npm version patch  <span class="comment"># 修订号加 1</span></span><br></pre></td></tr></table></figure><p>如果使用 <code>git</code> 管理项目会自动 <code>git tag</code> 标注版本号。</p><h4 id="标识含义"><a href="#标识含义" class="headerlink" title="标识含义"></a><strong>标识含义</strong></h4><table><thead><tr><th>range</th><th>含义</th><th align="left">例</th></tr></thead><tbody><tr><td><code>^2.2.1</code></td><td>指定的 MAJOR 版本号下, 所有更新的版本</td><td align="left">匹配 <code>2.2.3</code>, <code>2.3.0</code>; 不匹配 <code>1.0.3</code>, <code>3.0.1</code></td></tr><tr><td><code>~2.2.1</code></td><td>指定 MAJOR.MINOR 版本号下，所有更新的版本</td><td align="left">匹配 <code>2.2.3</code>, <code>2.2.9</code> ; 不匹配 <code>2.3.0</code>, <code>2.4.5</code></td></tr><tr><td><code>&gt;=2.1</code></td><td>版本号大于或等于 <code>2.1.0</code></td><td align="left">匹配 <code>2.1.2</code>, <code>3.1</code></td></tr><tr><td><code>&lt;=2.2</code></td><td>版本号小于或等于 <code>2.2</code></td><td align="left">匹配 <code>1.0.0</code>, <code>2.2.1</code>, <code>2.2.11</code></td></tr><tr><td><code>1.0.0 - 2.0.0</code></td><td>版本号从 1.0.0 (含) 到 2.0.0 (含)</td><td align="left">匹配 <code>1.0.0</code>, <code>1.3.4</code>, <code>2.0.0</code></td></tr></tbody></table><h4 id="预发版"><a href="#预发版" class="headerlink" title="预发版"></a><strong>预发版</strong></h4><ul><li><strong>alpha</strong> <em>(α)</em>：<strong>预览版</strong>，或者叫 <strong>内部测试版</strong>；一般不向外部发布，会有很多bug；一般只有测试人员使用。</li><li><strong>beta</strong> <em>(β)</em>：<strong>测试版</strong>，或者叫 <strong>公开测试版</strong>；这个阶段的版本会一直加入新的功能；在alpha版之后推出。</li><li><strong>rc</strong> <em>(release candidate)</em>：<strong>最终测试版</strong>；可能成为最终产品的候选版本，如果未出现问题则可发布成为正式版本。</li></ul><p><em>（<code>2.1.0-beta.1</code>这样声明的版本用户不会立马使用，可以用来做测试使用）</em></p><h2 id="npx的用法"><a href="#npx的用法" class="headerlink" title="npx的用法"></a>npx的用法</h2><blockquote><p>参考官网 <span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbnB4">npx - npm<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><code>npx</code> 命令是 <em>npm v5.2</em> 之后引入的新命令，<code>npx</code> 可以帮我们直接执行 <code>node_modules/.bin</code> 文件夹下的文件。</p><p><code>npx</code> 想要解决的主要问题，就是调用项目内部安装的模块。</p><h3 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>这样执行，会直接省略配置 <code>scripts</code> 脚本。</p><h3 id="避免安装全局模块"><a href="#避免安装全局模块" class="headerlink" title="避免安装全局模块"></a>避免安装全局模块</h3><p>全局安装的模块会带来很多问题，如 <em>多个用户全局安装的模块版本不同</em> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app react-project</span><br></pre></td></tr></table></figure><p>我们可以直接使用 <code>npx</code> 来执行模块。</p><p>它会先进行安装，安装后会将下载过的模块删除。这样可以保证项目是最新版本。</p><h2 id="npm包的发布"><a href="#npm包的发布" class="headerlink" title="npm包的发布"></a>npm包的发布</h2><p>首先我们需要先切换到官方源 <code>nrm</code>，这样更快。（关于 <a href="https://mxshang.github.io/2021/11/23/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/">nrm</a> 可以参考我之前的博客）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install nrm -g</span><br><span class="line">nrm use npm <span class="comment"># 切换到官方源</span></span><br></pre></td></tr></table></figure><p>之后将名字更新一下，这里也可以发布 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm5wbWpzLmNvbS9jcmVhdGluZy1hbmQtcHVibGlzaGluZy1zY29wZWQtcHVibGljLXBhY2thZ2Vz">作用域包<i class="fa fa-external-link-alt"></i></span> 选定版本。</p><p>忽略可以使用 <code>.npmignore</code>，然后可以直接进行发布了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure><p>这样我们自定义的包就被上传到 <span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tLw==">npm官网<i class="fa fa-external-link-alt"></i></span> 上啦。</p><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr&gt;&lt;h2 id=&quot;npm的介绍与使用&quot;&gt;&lt;a href=&quot;#npm的介绍与使用&quot; class=&quot;headerlink&quot; title=&quot;npm的介绍与使用&quot;&gt;&lt;/a&gt;npm的介绍与使用&lt;/h2&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://mxshang.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="知识点汇总" scheme="https://mxshang.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    
    <category term="Node" scheme="https://mxshang.github.io/tags/Node/"/>
    
    <category term="JS进阶" scheme="https://mxshang.github.io/tags/JS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记—Node中关于require的补充</title>
    <link href="https://mxshang.github.io/2021/11/21/Node%E7%B1%BB/Node-%E4%B8%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E5%85%B3%E4%BA%8Erequire%E7%9A%84%E8%A1%A5%E5%85%85/"/>
    <id>https://mxshang.github.io/2021/11/21/Node%E7%B1%BB/Node-%E4%B8%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E5%85%B3%E4%BA%8Erequire%E7%9A%84%E8%A1%A5%E5%85%85/</id>
    <published>2021-11-21T11:42:22.000Z</published>
    <updated>2021-11-21T15:55:35.285Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><p>看过上一篇文章，我们对 <code>require</code> 的基本使用和其实现原理已经了解的差不多了。</p><p>通过对源码的学习，我们也会产生以下几个问题。</p><h2 id="关于require的几个问题"><a href="#关于require的几个问题" class="headerlink" title="关于require的几个问题"></a>关于require的几个问题</h2><p>首先，我们还是定义两个文件，一个导出一个引入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 require 引入文件</span></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">"hello"</span>;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>在上一篇源码分析的文章中，我们提到过这么一个点。</p><p><code>this = module.exports = exports</code> <em>（具体可以参考我上一篇文章 <a href="https://mxshang.github.io/2021/11/20/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%ADrequire%E7%9A%84%E5%AE%9E%E7%8E%B0/">require的实现</a>）</em></p><p>那如果我们在这里输出 <code>module.exports === exports</code> ，结果又会如何呢？</p><h3 id="module-exports、exports和this的关系"><a href="#module-exports、exports和this的关系" class="headerlink" title="module.exports、exports和this的关系"></a>module.exports、exports和this的关系</h3><p>首先，我们先看一下上面那个问题的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.exports === exports); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.exports === <span class="keyword">this</span> , exports === <span class="keyword">this</span>); <span class="comment">// true true</span></span><br></pre></td></tr></table></figure><p>输出的结果是 <code>true</code>，我们还可以发现这三个值互换结果都是相等的。就是因为 <code>this = module.exports = exports</code> 。</p><p>既然他们三个是相等的，那么我是不是就可以直接 用 <code>exports = &quot;hello&quot;</code> 来输出结果了呢？</p><p>答案是<strong>不行</strong>。原因也很简单，因为我们在定义的时候是采用 <code>let exports = module.exports = {}</code> 的这种定义方式进行定义，文件在引用时，返回的是 <code>module.exports</code> 的值。 我们给 <code>exports</code> 赋值为 <em>hello</em> ，但 <code>module.exports</code> 依旧是空的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大概意思，具体实现可参考源码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> exports = <span class="built_in">module</span>.exports = &#123;&#125;;</span><br><span class="line">  exports = <span class="string">"hello"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们既然知道了这种赋值方式不行是因为<strong>值引用</strong>的问题，那么我们很快就可以想到。 是否可以利用堆栈内存的特性，给他们绑定一个属性呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line">exports.a = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">this</span>.a = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">module</span>.exports.a = <span class="string">"hello"</span>;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a.a); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>我们发现，这三种形式都可以进行值的传递和引用。其含义就是 <em>定义其堆内存中地址的值</em>， 且修改堆的值的指向。</p><p>假设我们同时定义 <code>module.exports</code> 和 属性，那么结果会获取 <code>module.exports</code> 的值，不会获取属性。</p><p><em>（注：不能直接修改 <code>this</code> 的值，可能会发生一些错误）</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports.a = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">"world"</span>;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// world</span></span><br></pre></td></tr></table></figure><p>因为 <code>module.exports</code> 的<strong>优先级是最高的</strong>，因为最终还是将 <code>module.exports</code>导出。<em>（所以 <code>require</code> 方法不支持多种写法同时导出）</em></p><h3 id="module-exports的简化"><a href="#module-exports的简化" class="headerlink" title="module.exports的简化"></a>module.exports的简化</h3><p>看过上面的定义，我们可以简单整理一下 <code>module.exports</code> 的简化写法。</p><h4 id="exports简化"><a href="#exports简化" class="headerlink" title="exports简化"></a>exports简化</h4><p>我们现在需要将模块内的多个值导出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports.a = <span class="string">"a"</span>;</span><br><span class="line"><span class="built_in">module</span>.exports.b = <span class="string">"b"</span>;</span><br><span class="line"><span class="built_in">module</span>.exports.c = <span class="string">"c"</span>;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(); <span class="comment">// &#123; a: 'a', b: 'b', c: 'c' &#125;</span></span><br></pre></td></tr></table></figure><p>这样写会很麻烦，所以我们可以使用 <code>exports</code> 来进行简化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line">exports.a = <span class="string">"a"</span>;</span><br><span class="line">exports.b = <span class="string">"b"</span>;</span><br><span class="line">exports.c = <span class="string">"c"</span>;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="comment">// ...  &#123; a: 'a', b: 'b', c: 'c' &#125;</span></span><br></pre></td></tr></table></figure><p>就是对代码进行简化。</p><h4 id="module-exports简化"><a href="#module-exports简化" class="headerlink" title="module.exports简化"></a>module.exports简化</h4><p>现在有多个方法需要导出，我们就可以用下面的方式简写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  fn1()&#123;&#125;,</span><br><span class="line">  fn2()&#123;&#125;,</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种就是 <code>module.exports</code> 结合 ES6 的一种简写方式。</p><p>至此，我们的 <em>Node的文件模块</em> 和 <em><a href="https://mxshang.github.io/2021/11/16/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/">Node的核心模块</a></em> 就总结完毕了。</p><p>下一篇文章我会总结一下 <em>Node中第三方模块</em>。</p><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr&gt;&lt;p&gt;看过上一篇文章，我们对 &lt;code&gt;require&lt;/code&gt; 的基本使用和其实现原理已经了解的差不多了。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://mxshang.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="知识点汇总" scheme="https://mxshang.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    
    <category term="Node" scheme="https://mxshang.github.io/tags/Node/"/>
    
    <category term="JS进阶" scheme="https://mxshang.github.io/tags/JS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记—Node中require的实现</title>
    <link href="https://mxshang.github.io/2021/11/20/Node%E7%B1%BB/Node-%E4%B8%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%ADrequire%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://mxshang.github.io/2021/11/20/Node%E7%B1%BB/Node-%E4%B8%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%ADrequire%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-11-20T10:42:22.000Z</published>
    <updated>2021-11-21T10:54:08.044Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="require"><a href="#require" class="headerlink" title="require"></a>require</h2><p>在上一篇文章中，我们了解到了如何去通过 <em>调试查看Node源码</em>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 require 引入文件</span></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = a;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure><p>通过调试查看 <code>require</code> 方法源码，其实现思路主要为以下几点。</p><ol><li><code>require</code> 方法的是 <code>Module</code> 模块的原型方法，也就是 <code>Module.prototype.require</code>。</li><li>通过 <code>Module._resolveFilename</code> 方法，将传入的路径转换为绝对路径。并添加文件的后缀名。<em>（.js、.json 等）</em></li><li><code>new Module</code> 拿到转换完毕的绝对路径，并创造一个模块并导出。（<em>其中包含一个属性id [ 当前文件路径 ]，还有一个 exports</em>）</li><li><code>Module.load</code> 对模块进行加载。</li><li>根据文件后缀 <code>Module._extensions[&#39;.js&#39;]</code> 去做策略加载。</li><li><code>fs.readFileSync</code> 同步读取文件。</li><li>增加了一个函数的外壳 <em>（ wrapper包装 ）</em> 让这个函数执行，并且让 <code>Module.exports</code> 作为当前上下文的 <code>this</code> 。</li><li>最终用户会拿到 <code>Module.exports</code> 的封装后的返回结果。</li></ol><p>所以，最终会返回一个 <code>Module.exports</code> 对象。通过以上思路，我们就可以实现一套 <code>require</code> 方法。</p><h3 id="实现require方法"><a href="#实现require方法" class="headerlink" title="实现require方法"></a>实现require方法</h3><p>根据上述规则，我们可以模拟实现一套 <code>require</code> 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> vm = <span class="built_in">require</span>(<span class="string">'vm'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.exports = &#123;&#125;; </span><br><span class="line">&#125;</span><br><span class="line">Module.wrapper = [</span><br><span class="line">    <span class="string">`(function(exports,require,module,__filename,__dirname)&#123;`</span>,</span><br><span class="line">    <span class="string">`&#125;)`</span></span><br><span class="line">];</span><br><span class="line">Module._extensions = &#123;</span><br><span class="line">    <span class="string">'.js'</span>(<span class="built_in">module</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> content = fs.readFileSync(<span class="built_in">module</span>.id, <span class="string">'utf8'</span>);</span><br><span class="line">        content = Module.wrapper[<span class="number">0</span>] + content + Module.wrapper[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">let</span> fn = vm.runInThisContext(content);</span><br><span class="line">        <span class="keyword">let</span> exports = <span class="built_in">module</span>.exports;</span><br><span class="line">        <span class="keyword">let</span> dirname = path.dirname(<span class="built_in">module</span>.id);</span><br><span class="line">        fn.call(exports, exports, _require, <span class="built_in">module</span>, <span class="built_in">module</span>.id, dirname);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'.json'</span>(<span class="built_in">module</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> content = fs.readFileSync(<span class="built_in">module</span>.id, <span class="string">'utf8'</span>);</span><br><span class="line">        <span class="built_in">module</span>.exports = <span class="built_in">JSON</span>.parse(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Module._resolveFilename = <span class="function"><span class="keyword">function</span> (<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> filePath = path.resolve(__dirname, filename);</span><br><span class="line">    <span class="keyword">let</span> isExists = fs.existsSync(filePath);</span><br><span class="line">    <span class="keyword">if</span> (isExists) &#123;</span><br><span class="line">        <span class="keyword">return</span> absPath;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(Module._extensions);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line"><span class="keyword">let</span> newPath = filePath + keys;</span><br><span class="line"><span class="keyword">if</span> (fs.existsSync(newPath)) <span class="keyword">return</span> newPath;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'module not exists'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Module.prototype.load = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> extName = path.extname(<span class="keyword">this</span>.id);</span><br><span class="line">    Module._extensions[extName](<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Module._cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_require</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    filename = Module._resolveFilename(filename);</span><br><span class="line">    <span class="keyword">let</span> cacheModule = Module._cache[filename];</span><br><span class="line">    <span class="keyword">if</span> (cacheModule) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheModule.exports; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(filename);</span><br><span class="line">    Module._cache[filename] = <span class="built_in">module</span></span><br><span class="line">    <span class="built_in">module</span>.load();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们来进行一步一步的解析。</p><ol><li><p>首先，我们需要先引入需要用到的内置模块（<code>fs</code>、<code>path</code> 和 <code>vm</code>）。</p><p>自定义一个 <em>函数方法 <code>_require</code></em> ，这就是我们最终需要实现的方法，第一个参数接受传入的路径。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> vm = <span class="built_in">require</span>(<span class="string">'vm'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_require</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>随后我们还需要一个 <code>Module._resolveFilename</code> 方法将传入的路径转换成绝对路径，并添加后缀。</p><p>因为使用 <code>Module</code> 方法，我们我们也需要声明一个名为 <code>Module</code> 的构造函数。</p><p>随后将路径传入 <code>Module._resolveFilename</code>方法中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Module._resolveFilename = <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> filePath = path.resolve(__dirname, id);</span><br><span class="line">    <span class="built_in">console</span>.log(filePath); <span class="comment">// d:\xxx\xxx\xxx\a</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_require</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    filename = Module._resolveFilename(filename); <span class="comment">// 绝对路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们发现目前打印的结果是没有后缀的<em>（不确定用户是否填写后缀）</em>，所以我们需要使用 <code>fs.existsSync</code> 判断当前路径是否存在。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Module._resolveFilename = <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">let</span> isExists = fs.existsSync(filePath);</span><br><span class="line">  <span class="keyword">if</span> (isExists) <span class="keyword">return</span> filePath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果存在，则直接返回结果。如果不存在，我们就需要给当前路径尝试添加后缀。</p></li><li><p>这里我们就需要添加后缀，我们需要先定义一个 <code>Module._extensions</code> 方法来对后缀进行分类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Module._extensions = &#123;</span><br><span class="line">    <span class="string">'.js'</span>() &#123;&#125;,</span><br><span class="line">    <span class="string">'.json'</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们将定义的后缀方法的 <code>keys</code> 添加到路径上，并再次进行路径判断。</p><p>路径存在则直接返回结果，如果路径不存在，这次就需要 <strong>返回一个错误</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Module._resolveFilename = <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(isExists)&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(Module._extensions);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line"><span class="keyword">let</span> newPath = filePath + keys;</span><br><span class="line"><span class="keyword">if</span> (fs.existsSync(newPath)) <span class="keyword">return</span> newPath;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'module not exists'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以保证我们 <em>传入的路径</em>，无论是加后缀或者不加后缀，都会返回一个 <em>当前路径的绝对路径</em>，且 <em>一定会找到当前文件</em>。</p></li><li><p>我们就已经创建好了一个 <strong>绝对引用路径</strong>，方便我们后续进行读取。</p><p>现在我们就需要根据这个路径，创建一个可以导出的模块。</p><p>这个模块就属于 <code>Module</code> 构造函数，根据我们一开始查看源码时总结的定义，我们知道 模块全部都是通过 <code>Module.exports</code> 方法进行导出的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id; <span class="comment">// 绝对路径</span></span><br><span class="line">    <span class="keyword">this</span>.exports = &#123;&#125;; <span class="comment">// 默认导出的是空对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_require</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    filename = Module._resolveFilename(filename); <span class="comment">// 绝对路径</span></span><br><span class="line">  <span class="keyword">let</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(filename);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们路径和导出的架子就有了，现在我们需要对中间部分进行处理。</p></li><li><p>其实所谓的 中间部分，也就是让用户对 <code>Module.exports</code> 赋值<em>（目前导出的是空对象）</em>。</p><p>根据源码的定义，我们需要定义一个 <code>module.load</code> 来对模块进行加载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Module.prototype.load = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> extName = path.extname(<span class="keyword">this</span>.id); <span class="comment">// 获取后缀名</span></span><br><span class="line">    Module._extensions[extName](<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_require</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">module</span>.load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种定义的好处就是，我们可以根据传入的后缀名，调用不同的处理策略。实现文件的 <strong>策略加载</strong>。</p><p>这样我们的 <code>module</code> 就会被传到上面的 <code>Module._extensions</code> 方法中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Module._extensions = &#123;</span><br><span class="line">    <span class="string">'.js'</span>(<span class="built_in">module</span>) &#123;&#125;,</span><br><span class="line">    <span class="string">'.json'</span>(<span class="built_in">module</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步我们就需要完善一下 <code>Module._extensions</code> 方法。</p></li><li><p>我们先来完善一下 <code>json</code> 方法，因为这个是最好实现的。</p><p>我们先随便定义一个 <code>.json</code> 文件来进行测试。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.json</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"name"</span> : <span class="string">"MXShang"</span>,</span><br><span class="line"><span class="attr">"age"</span> : <span class="number">26</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们来完善一下 <code>Module._extensions[json]</code> 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Module._extensions = &#123;</span><br><span class="line">    <span class="string">'.js'</span>() &#123;&#125;,</span><br><span class="line">    <span class="string">'.json'</span>(<span class="built_in">module</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> content = fs.readFileSync(<span class="built_in">module</span>.id, <span class="string">'utf8'</span>)</span><br><span class="line">        <span class="built_in">module</span>.exports = <span class="built_in">JSON</span>.parse(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取绝对路径，通过 <code>fs.readFileSync</code> 同步读取内容，并输出。</p><p>很好理解也很简单，接下来我们看一下 <code>Module._extensions[js]</code>。</p></li><li><p>在实现 <code>Module._extensions[js]</code> 方法前，我们先需要完成一个函数的外壳 <em>（ wrapper包装 ）</em> ，也就是我们之前文章中经常提到的，包含五个参数的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Module.wrapper = [</span><br><span class="line">    <span class="string">`(function(exports,require,module,__filename,__dirname)&#123;`</span>,</span><br><span class="line">    <span class="string">`&#125;)`</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>然后我们来实现 <code>Module._extensions[js]</code> 方法。</p><p>思路与实现 <code>.json</code> 相似，先将绝对路径的内容读出来，并将内容放到 <em>wrapper</em> 中。。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Module._extensions = &#123;</span><br><span class="line"><span class="string">'.js'</span>(<span class="built_in">module</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> content = fs.readFileSync(<span class="built_in">module</span>.id, <span class="string">'utf8'</span>);</span><br><span class="line">        content = Module.wrapper[<span class="number">0</span>] + content + Module.wrapper[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以得到一个 <em>被wrapper包裹的代码字符串</em>。</p></li><li><p>现在我们来将字符串变成可以执行的函数。使用 <code>vm.runInThisContext</code> 将字符串变成函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Module._extensions = &#123;</span><br><span class="line"><span class="string">'.js'</span>(<span class="built_in">module</span>) &#123;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">      <span class="keyword">let</span> fn = vm.runInThisContext(content); <span class="comment">// 获取最终执行的函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们需要明确一下 <code>fn</code> 的执行位置，也就是其 <em>this的指向</em>。</p><p>不用多说，this一定是指向 <code>module.exports</code> 的，所以我们需要通过 <code>fn.call</code> 方法来将函数的this指向当前构造函数。</p><p>然后我们再根据最终的函数，依次获取一下需要传递的五个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Module._extensions = &#123;</span><br><span class="line"><span class="string">'.js'</span>(<span class="built_in">module</span>) &#123;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">      <span class="keyword">let</span> exports = <span class="built_in">module</span>.exports; <span class="comment">// 当前this也就是exports参数。this = exports = module.exports</span></span><br><span class="line">        <span class="keyword">let</span> dirname = path.dirname(<span class="built_in">module</span>.id); <span class="comment">// 当前文件执行位置的绝对略经</span></span><br><span class="line">      fn.call(exports, exports, _require, <span class="built_in">module</span>, <span class="built_in">module</span>.id, dirname); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这一步我们就可以发现，<code>require</code> 方法实际上就是通过 <code>Module</code> 作为一个 <strong>中间层</strong> 来实现的。</p><p>至此，我们的 <code>require</code> 方法的整体思路就实现了。</p><p>但是我们还有一个小问题，就是如果我们多次引入文件，是没有缓存的。所以我们需要 <em>对结果进行缓存</em> 。</p></li><li><p>定义一个 <code>Module._cache</code> 来对结果进行缓存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个 Module._cache</span></span><br><span class="line">Module._cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在模块加载前，先将定义好的module模块结果进行缓存</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_require</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    Module._cache[filename] = <span class="built_in">module</span>; <span class="comment">// 根据文件名进行缓存</span></span><br><span class="line">    <span class="built_in">module</span>.load();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前模块已经被缓存过 <em>（加载过）</em> ，直接将缓存好的模块导出就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_require</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">let</span> cacheModule = Module._cache[filename];</span><br><span class="line">    <span class="keyword">if</span> (cacheModule) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheModule.exports; </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">let</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(filename);</span><br><span class="line">    Module._cache[filename] = <span class="built_in">module</span>; <span class="comment">// 根据文件名进行缓存</span></span><br><span class="line">    <span class="built_in">module</span>.load();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就实现了一套 <code>require</code> 方法。</p></li></ol><p>通过阅读源码，并通过源码手写方法，可以使我们更好的使用方法，也可以提升我们的技术。</p><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr&gt;&lt;h2 id=&quot;require&quot;&gt;&lt;a href=&quot;#require&quot; class=&quot;headerlink&quot; title=&quot;require&quot;&gt;&lt;/a&gt;require&lt;/h2&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://mxshang.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="知识点汇总" scheme="https://mxshang.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    
    <category term="Node" scheme="https://mxshang.github.io/tags/Node/"/>
    
    <category term="JS进阶" scheme="https://mxshang.github.io/tags/JS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记—Node中的模块调试</title>
    <link href="https://mxshang.github.io/2021/11/19/Node%E7%B1%BB/Node-%E4%B8%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E8%B0%83%E8%AF%95/"/>
    <id>https://mxshang.github.io/2021/11/19/Node%E7%B1%BB/Node-%E4%B8%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E8%B0%83%E8%AF%95/</id>
    <published>2021-11-19T10:56:22.000Z</published>
    <updated>2021-11-19T21:22:32.864Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL3poLWNuL2RvY3MvZ3VpZGVzL2RlYnVnZ2luZy1nZXR0aW5nLXN0YXJ0ZWQv">调试-入门指南 | Node.js 官网<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>当我们在写代码时（尤其是手写插件源码），总会出现一些不可预料的问题。所以我们这个时候就需要去对代码进行调试。</p><p>在上一篇文章中，我们希望去实现 <code>require</code>，这个时候我们就需要通过调试功能，去理解一下 <code>require</code> 内部的运行机制到底是什么样的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 require 引入文件</span></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = a;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure><p>下面我将会列举几种调试方式，并且使用其中一种来完成上一篇文章中遗留的问题。</p><h3 id="vscode调试"><a href="#vscode调试" class="headerlink" title="vscode调试"></a>vscode调试</h3><p>我们在使用 <em>Visual Studio Code</em> 编译器时，可以在右侧发现一个类似于瓢虫的标志。</p><p>点开后，我们可以创建一个 <code>launch.json</code> 的配置文件。</p><p><img data-src="pic5.png" alt="创建launch.json文件"></p><p>随后我们创建一个用来调试 <em>node.js</em> 的文件。</p><p>而我们就会得到下图中的配置文件，现在我们需要删除红框中的内容。</p><p><img data-src="pic6.png" alt="launch.json配置文件"></p><p>在文件 <em>b.js</em> 里面打一个断点，这样我们就可以进行调试了。</p><p><img data-src="pic7.png" alt="文件断点与调试"></p><p>点击 <em>单步调试</em> ，我们就可以看到源码了。</p><p><img data-src="pic8.png" alt="require源码"></p><p>这样我们就大概了解如何使用 <em>vscode</em> 进行代码调试了，后续我们可以通过这种方式加强我们对源码的学习。</p><h3 id="chrome调试"><a href="#chrome调试" class="headerlink" title="chrome调试"></a>chrome调试</h3><p>说起调试，我们就不得不说一下 浏览器调试。这里我们以 chrome谷歌浏览器为例。</p><p>首先，我们需要进行命令行配置。 输入 <code>node --inspect-brk</code>，在后面再加上我们需要调试的文件。</p><p>随后我们打开 chrome浏览器，输入链接 <code>chrome://inspect/#devices</code> ，这样就会进入浏览器的开发者工具界面。</p><p>我们就可以在页面中看到以下内容。<em>（此过程需要等待几秒到几分钟）</em></p><p><img data-src="pic9.png" alt="chrome开发者工具"></p><p>随后我们可以看见我们调试的文件。</p><p><img data-src="pic10.png" alt="调试工具"></p><p>操作使用上和vscode调试是相似的。</p><p>在下一篇文章中，我会使用这种调试方法去分析一下require的源码。</p><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr&gt;&lt;h2 id=&quot;调试&quot;&gt;&lt;a href=&quot;#调试&quot; class=&quot;headerlink&quot; title=&quot;调试&quot;&gt;&lt;/a&gt;调试&lt;/h2&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://mxshang.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="知识点汇总" scheme="https://mxshang.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    
    <category term="Node" scheme="https://mxshang.github.io/tags/Node/"/>
    
    <category term="JS进阶" scheme="https://mxshang.github.io/tags/JS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记—Node的VM模块详解</title>
    <link href="https://mxshang.github.io/2021/11/17/Node%E7%B1%BB/Node-%E4%B8%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%ADVM%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3/"/>
    <id>https://mxshang.github.io/2021/11/17/Node%E7%B1%BB/Node-%E4%B8%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%ADVM%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-11-17T03:56:22.000Z</published>
    <updated>2021-11-17T17:36:16.778Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvdm0uaHRtbA==">vm 虚拟机 | Node 官网<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>在上一篇文章中，我们提到了一个问题。</p><p><em>字符串如何能变成 JS 执行呢？</em></p><p>我们详细介绍了两种方法，分别是 <a href="https://mxshang.github.io/2021/11/16/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/">eval函数</a> 和 <a href="https://mxshang.github.io/2021/11/16/Node-%E4%B8%8B/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/">new Function</a> 。</p><p>在这里我们需要再强调一下， 由 <code>Function</code> 构造器创建的函数不会创建当前环境的闭包，它们总是被创建于全局环境，因此在运行时它们只能访问全局变量和自己的局部变量，不能访问它们被 <code>Function</code> 构造器创建时所在的作用域的变量。这一点与使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval" target="_blank" rel="noopener"><code>eval</code></a> 执行创建函数的代码不同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">global.a = <span class="number">100</span>; <span class="comment">// 挂在到全局对象global上</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">200</span>; <span class="comment">// this !== global</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"console.log(a)"</span>)() <span class="comment">// 100</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"console.log(b)"</span>)() <span class="comment">// b is not defined</span></span><br></pre></td></tr></table></figure><p><code>Function</code> 可以获取全局变量，所以他还是可能会有变量污染的情况出现。<code>Function</code> 是 <em>模块引擎的实现原理</em> ，后续我会出一篇文章进行单独讲解。</p><p>还有一种解决方案，我们在上一次文章中没有进行详细的展开，那就是 <strong><code>vm</code>模块</strong> 。</p><h2 id="vm模块"><a href="#vm模块" class="headerlink" title="vm模块"></a>vm模块</h2><p>在上述文字中，我一直在强调一个概念，那就是 <strong>变量的污染</strong>。</p><p>VM的特点就是不受环境的影响，也可以说他就是一个 <strong>沙箱环境</strong> <em>（沙箱模式给模块提供一个环境运行而不影响其它模块和它们私有的沙箱）</em>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="built_in">require</span>(<span class="string">'vm'</span>)</span><br><span class="line">global.a = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 运行在当前环境中[当前作用域]</span></span><br><span class="line">vm.runInThisContext(<span class="string">'console.log(a)'</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="comment">// 运行在新的环境中[其他作用域]</span></span><br><span class="line">vm.runInNewContext(<span class="string">'console.log(a)'</span>); <span class="comment">// a is not defined</span></span><br></pre></td></tr></table></figure><p>在这里我们要强调一下，因为 <strong>在Node中全局变量是在多个模块下共享的，所以尽量不要在global中定义属性。</strong> Demo中的定义是为了方便理解。</p><p>假设我们在同级目录下有一个文件 <em>1.js</em> ，里面定义了 <code>global.a = 100;</code>。 现在我们引入这个文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">requrie(./<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><p>我们可以发现，在当前文件中我们并没有定义变量a，仅仅只是把两个模块文件关联在了一起。这就是我上面提到的，<strong>Node中全局变量是在多个模块下共享的。</strong></p><p>他的原理是因为在 <em>Node</em> 的环境中，全局中有一个执行上下文。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟一下Node的全局环境</span></span><br><span class="line"><span class="comment">// vm.runInThisContext在当前全局环境执行，但不会产生新函数</span></span><br><span class="line">- <span class="function"><span class="keyword">function</span>(<span class="params">exports, module, require, __dirname, __filename</span>)</span>&#123; <span class="comment">// ... &#125;</span></span><br><span class="line">- vm.runInThisContext ...</span><br><span class="line"><span class="comment">// vm.runInNewContext在全局环境之外执行</span></span><br><span class="line">vm.runInNewContext ...</span><br></pre></td></tr></table></figure><p>所以，<code>vm.runInThisContext</code> 可以访问到 <code>global</code>上的全局变量，但是访问不到自定义的变量。而 <code>vm.runInNewContext</code> 访问不到 <code>global</code>，也访问不到自定义变量，他存在于一个全新的执行上下文。</p><p>而我们<code>require</code> 就是通过 <code>vm.runInThisContext</code> 实现的。</p><p>实现<code>require</code> 主要可以分为以下四步。</p><ol><li>读取需要引入的文件。</li><li>读取到文件后，将代码封装成一个函数。</li><li>通过 <code>vm.runInThisContext</code> 将他转变成 JS 语法。</li><li>代码调用。</li></ol><p>假设我们现在有以下两个文件。分别是 <em>a.js</em> 和 <em>b.js</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件a通过module.exports导出一个变量，在文件b中使用require进行接收。</span></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">"a"</span></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// a</span></span><br></pre></td></tr></table></figure><p>我们可以通过上面的四个步骤，分析一下导入导出的实现逻辑是什么样的。</p><ol><li><p><em>读取文件。</em></p><p>将需要引入的文件内容引入到需要接收的文件里，就会变成这个样子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">module</span>.exports = <span class="string">"a"</span>;</span><br></pre></td></tr></table></figure><p>但是这种形式，Node根本解析不了，所以我们就需要进行第二步。</p></li><li><p><em>将读取的文件封装成函数。</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = (<span class="function"><span class="keyword">function</span>(<span class="params">exports, module, require, __dirname, __filename</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="string">"a"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports</span><br><span class="line">&#125;)(...args) <span class="comment">// exports, module, require, __dirname, __filename 将五个参数传入</span></span><br></pre></td></tr></table></figure><p>封装成函数的原因，我们可以参考下面这个例子。</p><p>假设我们现在传入的不是字符串，而是一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这样我们在解析的时候，就会被解析成下面这种格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = (<span class="function"><span class="keyword">function</span>(<span class="params">exports, module, require, __dirname, __filename</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports</span><br><span class="line">&#125;)(...args) <span class="comment">// exports, module, require, __dirname, __filename 将五个参数传入</span></span><br></pre></td></tr></table></figure><p>我们导出的是 <code>module.exports</code>，所以在模块文件中定义的变量a，也只属于当前这个执行上下文。</p><p>在解析的时候，变量a 会被放到函数中。真正的实现了 <strong>作用域分离</strong>。</p></li><li><p><em><code>vm.runInThisContext</code> 解析成可执行的Js代码</em></p><p>我们处理过的代码会以字符串的形式存在，所以我们需要通过<code>vm.runInThisContext</code>将字符串进行解析。</p></li><li><p><em>进行代码调用</em></p><p>在此之前，我们其实还需要对代码进行调试。</p></li></ol><p>下一篇文章我会详细讲解一下 <strong>Node中的模块调试</strong>。</p><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr&gt;&lt;blockquote&gt;&lt;p&gt;参考文献 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL25vZGVqcy5jbi9hcGkvdm0uaHRtbA==&quot;&gt;vm 虚拟机 | Node 官网&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://mxshang.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="知识点汇总" scheme="https://mxshang.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    
    <category term="Node" scheme="https://mxshang.github.io/tags/Node/"/>
    
    <category term="JS进阶" scheme="https://mxshang.github.io/tags/JS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记—Node的核心模块</title>
    <link href="https://mxshang.github.io/2021/11/16/Node%E7%B1%BB/Node-%E4%B8%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/"/>
    <id>https://mxshang.github.io/2021/11/16/Node%E7%B1%BB/Node-%E4%B8%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/</id>
    <published>2021-11-16T02:56:22.000Z</published>
    <updated>2021-11-16T13:05:15.574Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="动态模块与静态模块"><a href="#动态模块与静态模块" class="headerlink" title="动态模块与静态模块"></a>动态模块与静态模块</h2><blockquote><p>关于之前文章中 <a href="https://mxshang.github.io/2021/11/15/Node/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/">动态静态</a> 的含义。</p></blockquote><p>首先，es6Module属于<em>“静态模块”</em>，commonjs属于<em>“动态模块”</em>。</p><p><em>静态模块</em> 是可以在编译的时候进行引入分析的，他可以进行 <em><code>tree-shaking</code>（webpack打包时自动去掉不用的代码）*。而 *动态模块</em> 是在代码执行的时候引入模块的，他不可以进行 <em><code>tree-shaking</code></em>。</p><blockquote><p>关于 <code>tree-shaking</code> ，可以参考 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9UcmVlX3NoYWtpbmc=">Tree Shaking | MDN<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>文件用webpack打包之后，文件就会从 <em>es6Module规范 转换成 commonjs规范</em>。</p><h2 id="模块的规范与分类"><a href="#模块的规范与分类" class="headerlink" title="模块的规范与分类"></a>模块的规范与分类</h2><p>首先，我们先回顾一下 <strong>commonjs模块规范</strong>：</p><ul><li>每个js <em>文件都是一个模块</em>。（每个模块外面都有一个函数）</li><li>模块的导出 <code>module.exports</code></li><li>模块的导入 <code>require</code></li></ul><p>而模块中也有自己的分类，下面我们介绍一下 <strong>模块分类</strong>：</p><ol><li><strong>核心模块</strong> 也叫内置模块，包括<code>fs</code>、<code>http</code>、<code>path</code>、<code>vm</code> 等等。在使用时 <em>不需要进行安装*，直接引入即可。引入的时候也 *不需要添加绝对路径或相对路径</em> 。</li><li><strong>第三方模块</strong> 也就是别人定义的模块，像 <code>co</code> 等等。此类模块在使用的时候 <em>需要进行安装</em>。</li><li><strong>自定义模块</strong> 是用户自己封装或定义的模块，在使用的时候需要 <em>通过绝对路径或者相对路径进行引入</em>。</li></ol><h2 id="常用的核心模块"><a href="#常用的核心模块" class="headerlink" title="常用的核心模块"></a>常用的核心模块</h2><h3 id="fs模块"><a href="#fs模块" class="headerlink" title="fs模块"></a>fs模块</h3><ol><li><p><strong>fs.readFileSync</strong></p><p>我们先举个 <strong>核心模块</strong> 的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="comment">// require内部使用的就是readFileSync来实现的</span></span><br><span class="line"><span class="keyword">let</span> r = fs.readFileSync(<span class="string">'./test.js'</span>,<span class="string">'utf8'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(r);</span><br></pre></td></tr></table></figure><p>首先，<code>require</code> 是<strong>同步方法</strong>。假设<code>require</code> 是异步的话，那么每引入一个模块，我们都需要在其成功的回调中写我们下一步需要执行的代码，这样就会造成代码的冗余和堆积。</p><p>所以 <code>require</code> 的内部就是使用 <em>readFileSync</em> 来实现的。</p></li><li><p><strong>fs.existsSync</strong></p><p>我们在读取文件时，如果读取的文件不存在，那么就会发生异常。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = fs.readFileSync(<span class="string">'./testxxx.js'</span>,<span class="string">'utf8'</span>); <span class="comment">// 假设此文件不存在</span></span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>这时我们可以使用 <code>existsSync</code> 来对文件进行判断。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = fs.existsSync(<span class="string">'./testxxx.txt'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(f); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>此方法目前只有 同步方法，<del>异步方法已经被废弃了</del>。</p></li></ol><h3 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a>path模块</h3><ol><li><p><strong>path.resolve</strong></p><p><code>path</code>模块是专门用来处理路径的。</p><p><code>path.resolve</code> 方法会把一个路径或路径片段的序列解析为一个绝对路径。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(path.resolve(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>));</span><br><span class="line"><span class="comment">// d:\xxx\xxx\xxx\a\b\c</span></span><br></pre></td></tr></table></figure><p>他会将当前绝对路径为前缀，将传入的参数以 <code>\</code> 分割，并解析成新的绝对路径。</p><p>但是这样会出现一个问题，假设我们现在切换一下执行目录，那么路径就会发生错误。原因是因为<code>path.resolve</code> 默认采用的解析方式是 <code>process.cwd()</code> 。</p><p>为了使路径正确，我们可以采用以下解决方案。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(path.resolve(__dirname ,<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'/'</span>)); <span class="comment">// 路径回到了根目录下</span></span><br></pre></td></tr></table></figure><p><em>（注：如果路径中存在 <code>/</code>，当前路径会回到跟目录下 ）</em></p></li><li><p><strong>path.join</strong></p><p><code>path.join</code> 是将传入的参数进行路径拼接，不会添加任何路径。</p><p>参数中如果存在 <code>/</code>，也会被拼接在一起。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(path.join(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'/'</span>));</span><br><span class="line"><span class="comment">// a\b\c\</span></span><br></pre></td></tr></table></figure><p>所以我们可以使用这种方法进行绝对路径的拼接。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(path.join(__dirname ,<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'/'</span>)); <span class="comment">// 路径被拼接在一起</span></span><br></pre></td></tr></table></figure><p>*<em>在某些情况下，<code>path.join</code>和 <code>path.resolve</code> 是可以互换使用的。但是在路径中出现 <code>/</code> 的情况下，还是使用 <code>path.join</code>更好。 *</em></p></li><li><p><strong>path.extname</strong></p><p><code>path.extname</code> 会获取文件扩展名，也可以说就是文件的类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(path.extname(<span class="string">'text.min.js'</span>)); <span class="comment">// .js</span></span><br></pre></td></tr></table></figure></li><li><p><strong>path.basename</strong></p><p><code>path.basename</code> 方法返回 <code>path</code> 的最后一部分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(path.basename(<span class="string">'d:/xxx/xxx/xxx/test.js'</span>,<span class="string">'.js'</span>));  <span class="comment">// test</span></span><br></pre></td></tr></table></figure><p>若不传最后一个参数，则会直接返回最后的文件名 <code>test.js</code></p></li><li><p><strong>path.relative</strong></p><p><code>path.basename</code> 方法会根据当前路径，<em>获取相对路径</em>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(path.basename(<span class="string">'a/b/c/test.js'</span>,<span class="string">'a'</span>));  <span class="comment">// ..\..\..</span></span><br></pre></td></tr></table></figure></li><li><p><strong>path.dirname</strong></p><p><code>path.dirname</code> 方法会获取当前文件的父路径。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(path.dirname(<span class="string">'a/b/c'</span>));  <span class="comment">// a/b</span></span><br></pre></td></tr></table></figure><p><em>__dirname的实现就是用的<code>path.dirname</code>。</em></p></li></ol><h3 id="vm模块"><a href="#vm模块" class="headerlink" title="vm模块"></a>vm模块</h3><p>在说这个模块之前，我们可以先思考一个问题。</p><p><em>字符串如何能变成JS执行呢？</em></p><ol><li><p><strong>eval函数</strong></p><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2wuY29tLmNuL2pzcmVmL2pzcmVmX2V2YWwuYXNw">eval()函数<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>我们第一个想到的就是 <code>eval()</code> 函数，他可以将传入的字符串或表达式转换成可以执行的JS代码，且 <code>eval()</code> 函数会受当前执行环境影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">'console.log(a)'</span>); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure></li><li><p><strong>new Function</strong></p><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24=">Function | MDN<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><code>new Function</code> 会将传入的字符串作为 <em>函数<em>，将传入的前几个参数作为 *函数的参数</em>。且 *在Node环境中</em> 他不会受外界的影响，因为 <code>new Function</code> 与 <em>最外级作用域是平级</em> 的，在浏览器中不受影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'b'</span>,<span class="string">'console.log(a)'</span>)(); <span class="comment">// a is not defined</span></span><br></pre></td></tr></table></figure></li><li><p><strong>vm模块</strong></p><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvdm0uaHRtbA==">vm 虚拟机 | Node官网<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><code>vm</code> 模块允许在 V8 虚拟机上下文中编译和运行代码。</p><p><em>（关于<code>vm</code>模块的使用和原理，我会在后续文章中详细讲解）</em></p></li></ol><hr><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr&gt;&lt;h2 id=&quot;动态模块与静态模块&quot;&gt;&lt;a href=&quot;#动态模块与静态模块&quot; class=&quot;headerlink&quot; title=&quot;动态模块与静态模块&quot;&gt;&lt;/a&gt;动态模块与静态模块&lt;/h2&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://mxshang.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="知识点汇总" scheme="https://mxshang.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    
    <category term="Node" scheme="https://mxshang.github.io/tags/Node/"/>
    
    <category term="JS进阶" scheme="https://mxshang.github.io/tags/JS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记—Node中模块化规范</title>
    <link href="https://mxshang.github.io/2021/11/15/Node%E7%B1%BB/Node-%E4%B8%8A/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/"/>
    <id>https://mxshang.github.io/2021/11/15/Node%E7%B1%BB/Node-%E4%B8%8A/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/</id>
    <published>2021-11-14T22:25:22.000Z</published>
    <updated>2021-11-14T23:20:29.330Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="模块化与全局对象"><a href="#模块化与全局对象" class="headerlink" title="模块化与全局对象"></a>模块化与全局对象</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0LXYxNi54L2RvY3MvYXBpL2dsb2JhbHMuaHRtbA==">Global objects|Node.js<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>首先，模块化包括 <em>require()</em> 、<em>exports</em> 和 <em>module</em> 等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(global.exports); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(global.module); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(global.require); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>但是当我们在控制台打印时，发现其结果都是 <em>undefined</em>。我们却可以直接对这些属性进行访问，比如<code>console.log(require)</code>。</p><p>这里需要注意，global上有的属性叫做<strong>全局属性</strong>，可以直接访问。但 <em>require()</em> 、<em>exports</em> 和 <em>module</em> 也可以直接访问，但是他们却不在global对象上。</p><p><em>每个文件都是一个模块，模块化的实现借助的是函数。</em></p><p>而这个函数里面有五个参数，分别是 <em>__dirname*、</em>__filename* 、<em>require()</em> 、<em>exports</em> 和 <em>module<em>。</em>（后续我会写一篇文章来实现模块化）</em></p><h2 id="模块化的规范"><a href="#模块化的规范" class="headerlink" title="模块化的规范"></a>模块化的规范</h2><p>模块化规范包括以下几种</p><ul><li>CommonJs规范</li><li>ESModule规范</li><li>AMD</li><li>CMD</li><li>UMD</li><li>SystemJs</li><li>…</li></ul><p><strong>为什么要有模块化规范？</strong></p><p>JS 诞生的时候，仅仅是为了实现网页表单的本地校验和简单的 dom 操作处理。所以并没有模块化的规范设计。</p><p>项目小的时候，我们可以通过命名空间、局部作用域、自执行函数等手段实现变量不冲突。但是到了大一点的项目，各种组件，各种第三方插件和各种 js 脚步融合的时候，就会发现这些技巧远远不够。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>最早的时候，一些项目组会采用 <strong>单例设计模式</strong> 来解决这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员a</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  aa()&#123; </span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 成员b</span></span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">  bb()&#123;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种解决方式就会出现 <em>命名过长，难以调用</em> 等问题。所以他 <em>解决了，但没有完全解决</em>。</p><h3 id="AMD、CMD"><a href="#AMD、CMD" class="headerlink" title="AMD、CMD"></a>AMD、CMD</h3><p>为了解决模块化的问题，人们用 <strong>文件拆分</strong> 的方式，配合 iife *<em>自执行函数 *</em>来解决。也就是 <em>AMD、CMD</em>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xx = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>这种方式在前端中需要请求顺序，也就出现了依赖问题。比如我们现在有一个文件a，他需要依赖文件b和文件c，但是c文件又需要依赖文件d。这时候就出现了文件之间的依赖问题，我们并不知道每个文件需要依赖的文件都有谁。</p><p>这就是以前出现的依赖前置 <code>define([&#39;jquery&#39;,&#39;xxx&#39;],function(){ // ... })</code></p><h3 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h3><p>它可以通过运行时或者编译时让同一个代码模块在使用 CommonJs、CMD 甚至是 AMD 的项目中运行。未来同一个 JavaScript 包运行在浏览器端、服务区端甚至是 APP 端都只需要遵守同一个写法就行了。</p><p>简单来说，他的出现就是为了兼容CommonJs、CMD和AMD，但是他并<em>不兼容ESModule<em>。</em>（所以我们在平时发布组件库时，就会将代码打包成 UMD 和 ESModule 两种）</em></p><h3 id="CommonJs和ESModule的区别"><a href="#CommonJs和ESModule的区别" class="headerlink" title="CommonJs和ESModule的区别"></a>CommonJs和ESModule的区别</h3><p><em>CommonJs</em> 和 <em>ESModule</em> 的定义都是一样的，<strong>一个文件就是一个模块</strong>。</p><ul><li><p><strong>CommonJs的用法</strong>： <em>require()</em> 是使用其他模块，<em>module.exports</em> 是导出模块。</p></li><li><p><strong>ESModule的用法</strong>：<em>import</em> 是使用其他模块，<em>export</em> 是导出模块。</p><p><em>CommonJs</em> 是<strong>基于Node的I/O操作</strong>，如果我想进行模块的引入和导出，我就需要使用Node来进行操作。</p></li></ul><p>而 <em>ESModule</em> 是<strong>基于浏览器的请求</strong>，如果我想进行引入导出的操作，我就需要使用浏览器。</p><p>我们也可以理解为，<strong><em>ESModule</em> 是静态的</strong>，而 <strong><em>CommonJs</em>是动态的</strong>。所以我们平时才会使用 <em>require()</em> 来对资源进行动态引入。 <em>（注：目前ES7中支持 import(‘./xxx’)来对资源进行动态引入）</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ESModule不可以动态引入资源</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="comment">// 这种写法不成立</span></span><br><span class="line">  <span class="keyword">import</span> xxx <span class="keyword">from</span> <span class="string">'./xxx'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CommonJs可以动态引入资源</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./xxx'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>(在现在的实际项目中，我们一般会使用webpack来对文件进行自动编译。)</em></p><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr&gt;&lt;h2 id=&quot;模块化与全局对象&quot;&gt;&lt;a href=&quot;#模块化与全局对象&quot; class=&quot;headerlink&quot; title=&quot;模块化与全局对象&quot;&gt;&lt;/a&gt;模块化与全局对象&lt;/h2&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://mxshang.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="知识点汇总" scheme="https://mxshang.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    
    <category term="Node" scheme="https://mxshang.github.io/tags/Node/"/>
    
    <category term="JS进阶" scheme="https://mxshang.github.io/tags/JS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记—Node中的EventLoop</title>
    <link href="https://mxshang.github.io/2021/11/14/Node%E7%B1%BB/Node-%E4%B8%8A/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E7%9A%84EventLoop/"/>
    <id>https://mxshang.github.io/2021/11/14/Node%E7%B1%BB/Node-%E4%B8%8A/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E4%B8%AD%E7%9A%84EventLoop/</id>
    <published>2021-11-14T04:25:22.000Z</published>
    <updated>2021-11-14T21:05:49.747Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTQvMTAvZXZlbnQtbG9vcC5odG1s">JavaScript运行机制详解<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>首先，<code>process.nextTick</code>是node自己实现的方法，并<strong>不属于node中的EventLoop</strong>，他的<strong>优先级也比promise更高</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// nextTick</span></span><br><span class="line"><span class="comment">// promise</span></span><br></pre></td></tr></table></figure><p>我们可以看到，上述执行队列中，会<em>先输出nextTick，再输出promise</em>。</p><p>原因就是因为nextTick的执行位置，他会<strong>在执行上下文栈执行完毕后，立即执行nextTick</strong>。</p><p><img data-src="pic4.png" alt="node中的nextTick"></p><h2 id="Node中的EventLoop"><a href="#Node中的EventLoop" class="headerlink" title="Node中的EventLoop"></a>Node中的EventLoop</h2><blockquote><p>参考文献 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL3poLWNuL2RvY3MvZ3VpZGVzL2V2ZW50LWxvb3AtdGltZXJzLWFuZC1uZXh0dGljay8=">Node.js事件循环、定时器和process.nextTick()<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>为了更好的学习和理解EventLoop与nextTick的关系，我们也可以参考下图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数。</span><br><span class="line">   ┌───────────────────────────┐</span><br><span class="line">┌─&gt;│           timers          │ </span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">|   执行延迟到下一个循环迭代的 I&#x2F;O 回调。</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │     pending callbacks     │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">|   仅系统内部使用。</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │       idle, prepare       │</span><br><span class="line">│  └─────────────┬─────────────┘      </span><br><span class="line">|   检索新的I&#x2F;O事件;执行与 I&#x2F;O 相关的回调  ┌───────────────┐</span><br><span class="line">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class="line">│  │           poll            │&lt;─────┤  connections, │</span><br><span class="line">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class="line">│   setImmediate() 回调函数在这里执行。  └───────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐      </span><br><span class="line">│  │           check           │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">|  一些关闭的回调函数</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">└──┤      close callbacks      │  </span><br><span class="line">   └───────────────────────────┘</span><br></pre></td></tr></table></figure><p>这里每一个阶段都对应一个事件队列，当 event loop 执行到某个阶段时会将当前阶段对应的队列依次执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段。</p><p>我们可以通过以下代码来感受一下上述概念。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// timeout</span></span><br><span class="line"><span class="comment">// setImmediate</span></span><br></pre></td></tr></table></figure><p>这里我们可以发现，<em>timeout</em> 会在 <em>setImmediate</em> 之前输出。</p><p>但是这里会有一个问题，多次执行之后我们会发现，<em>timeout</em> 也会在 <em>setImmediate</em> 之后输出。</p><p>原因是因为当前默认<strong>执行主栈代码</strong>，主栈代码执行完毕后，<strong>再去执行宏任务队列</strong>。但是因为我们的<strong>定时器设定</strong>的时间是0，可能会<strong>有几毫秒的延迟</strong>，所以当主栈代码执行完毕后，定时器并<strong>没有到达指定的执行时间</strong>，所以会存在两个结果输出情况不一致的情况。</p><p>我们可以称他为 <strong><em>准备阶段时间</em></strong>。</p><p>假设我们目前存在这样一段代码，从I/O事件中执行<em>setImmediate</em> 与 <em>setTimeout</em>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'./test.txt'</span>, <span class="string">'utf-8'</span>, () =&gt; &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//setImmediate</span></span><br><span class="line"><span class="comment">//timeout</span></span><br></pre></td></tr></table></figure><p>我们的代码在执行时，会先检测是否存在 <strong><em>timer</em>阶段</strong>，也就是定时器。没有的话，会去检测 <strong><em>poll</em>队列</strong>（I/O事件）是否为空。检测完毕后，再去检测是否存在 setImmediate，也就是 <strong><em>check</em>阶段</strong> 。检测完毕后，会进行轮询，也就是下一轮检测。</p><p>这样我们可以<strong>总结一下</strong>：</p><ol><li>检测Poll队列中是否为空，如果不为空则执行队列中的任务，直到超时或者全部执行完毕。</li><li>执行完毕后检测setImmediate队列是否为空，如果不为空则执行check阶段，如果为空则等待时间到达。时间到达后回到timer阶段。</li><li>等待时间到达是可能会出现新的callback，此时也在当前阶段被清空。</li></ol><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>搞清楚了Node中的EventLoop，那么EventLoop和微任务的关系又是什么样的呢？</p><p>我们可以看一道曾经腾讯的面试题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'c'</span>);</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'d'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'e'</span>);</span><br><span class="line"><span class="comment">// c e d a b</span></span><br></pre></td></tr></table></figure><p>根据我们之前学过的知识我们可以推导出这道题的结果。</p><p>Node在执行时，会先将主执行栈代码执行完毕，这时<em>输出结果 c 、e<em>，将</em>promise.then()放入微任务队列<em>。然后会拿出一个宏任务并执行，先清空微任务队列，这时 *输出结果 d</em>。随后再执行定时器回调，*输出结果 a</em> 。然后根据Node中EventLoop的执行顺序，timer清空完毕后进入poll阶段，检查是否存在I/O事件。随后检测setImmediate队列，并将 <em>输出结果 b</em>。</p><hr><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr&gt;&lt;h2 id=&quot;nextTick&quot;&gt;&lt;a href=&quot;#nextTick&quot; class=&quot;headerlink&quot; title=&quot;nextTick&quot;&gt;&lt;/a&gt;nextTick&lt;/h2&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://mxshang.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="知识点汇总" scheme="https://mxshang.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    
    <category term="Node" scheme="https://mxshang.github.io/tags/Node/"/>
    
    <category term="JS进阶" scheme="https://mxshang.github.io/tags/JS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记—Node的全局对象</title>
    <link href="https://mxshang.github.io/2021/11/05/Node%E7%B1%BB/Node-%E4%B8%8A/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E7%9A%84%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1/"/>
    <id>https://mxshang.github.io/2021/11/05/Node%E7%B1%BB/Node-%E4%B8%8A/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E7%9A%84%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-11-05T11:25:22.000Z</published>
    <updated>2021-11-05T16:38:31.830Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="Node中的全局对象"><a href="#Node中的全局对象" class="headerlink" title="Node中的全局对象"></a>Node中的全局对象</h2><blockquote><p>参考官网 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL3poLWNuL2RvY3Mv">Node.js官网<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>首先我们先要清楚一个概念。一个默认执行的js文件，使用node来执行他会把这个文件当成一个模块来执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>this是一个空对象，模块会默认将this给进行修改。</p><p>在前端（html）中，访问变量是通过<strong>window</strong>属性。而在后端（node）中，访问变量是通过<strong>global</strong>属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在node环境下运行</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="keyword">this</span>); <span class="comment">// global</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>我们可以在控制台中，查看打印出来的结果。</p><p><img data-src="pic3.png" alt="global"></p><p>其中有很多我们经常用到的方法，例如<em>setTimeout</em>、<em>clearTimeout</em>、<em>setInterval</em>、<em>clearInterval</em>、setImmediate、<em>clearImmediate</em>等等。</p><p><em>（我们可以使用 <code>console.dir(this, {showHidden: true})</code> 查看隐藏属性，更全面的观察global。）</em></p><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。</p><p>但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个<strong>专门存放二进制数据的缓存区</strong>。</p><p><em>（后期会有博客对此进行详细说明）</em></p><h3 id="dirname-filename"><a href="#dirname-filename" class="headerlink" title="__dirname / __filename"></a><strong>__dirname</strong> / <strong>__filename</strong></h3><ul><li><strong>__dirname</strong> ：表示当前文件执行时的 <em>固定目录</em> ，也就是目录的绝对路径。</li><li><strong>__filename</strong> ：表示当前文件自己执行位置的 绝对路径。</li></ul><p>使用 <strong>__dirname</strong> 和 <strong>__filename</strong> 的路径，是准确的绝对路径。</p><h3 id="process"><a href="#process" class="headerlink" title="process"></a>process</h3><blockquote><p>参考官网 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wcm9jZXNzLmh0bWw=">process<i class="fa fa-external-link-alt"></i></span></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process);</span><br></pre></td></tr></table></figure><h4 id="platform"><a href="#platform" class="headerlink" title="platform"></a>platform</h4><p>表示<strong>当前运行的平台</strong>（win、mac 等等）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.platform); <span class="comment">// win32</span></span><br></pre></td></tr></table></figure><p><em>win32表示我当前运行的平台是 windows，而 mac的输出结果是 darwin。</em></p><p>我们可以根据其输出结果的不同，做不同的命令配置。</p><h4 id="chdir"><a href="#chdir" class="headerlink" title="chdir"></a>chdir</h4><p><code>change directory</code>，<strong>修改当前文件运行目录</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改前文件位置 d:\****\****\test\demo</span></span><br><span class="line">process.chdir(<span class="string">'../'</span>)</span><br><span class="line"><span class="comment">// 修改后文件位置 d:\****\****\test</span></span><br></pre></td></tr></table></figure><p><em>此方法我们很少会应用到。</em></p><h4 id="cwd"><a href="#cwd" class="headerlink" title="cwd"></a>cwd</h4><p><code>current working directory</code>的缩写，表示<strong>当前工作目录</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.cwd()); <span class="comment">// d:\****\****\test\demo</span></span><br></pre></td></tr></table></figure><p>当前文件运行在哪个目录中，他就会显示哪个目录。</p><p>假设我们换一下运行此文件的目录（如在上级目录运行此文件），那结果就会显示运行文件的位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.cwd()); <span class="comment">// d:\****\****\test</span></span><br></pre></td></tr></table></figure><p>在webpack中，<em>webpack会使用此方法自动查找并运行目录下的webpack.config.js文件</em>。</p><h4 id="env"><a href="#env" class="headerlink" title="env"></a>env</h4><p>表示当前的<strong>环境变量</strong>，而环境变量分为 <em>用户变量</em> 和 <em>系统变量</em> 。</p><p>在实际场景中，我们可以通过此变量来判断当前的运行环境（<em>生产环境、开发环境 和 测试环境 等等</em>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">"dev"</span>) &#123;</span><br><span class="line">    <span class="comment">// 开发环境</span></span><br><span class="line">    <span class="comment">// do something ... </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 生产环境</span></span><br><span class="line">    <span class="comment">// do something ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（<em>因目前Node各版本设置process.env的差异，在此不做配置环境变量的演示了，配置方法以 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2RvY3MvbGF0ZXN0LXYxNC54L2FwaS9wcm9jZXNzLmh0bWwjcHJvY2Vzc19wcm9jZXNzX2Vudg==">process.env官网<i class="fa fa-external-link-alt"></i></span> 为准</em>）</p><h4 id="argv"><a href="#argv" class="headerlink" title="argv"></a>argv</h4><p>表示启动时<strong>传入的命令行参数</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.argv); </span><br><span class="line"><span class="comment">// ['C:\\Program Files\\nodejs\\node.exe', 'd:\\****\\****\\test\\demo\\index.js']</span></span><br></pre></td></tr></table></figure><p>其中返回了一个数组，第一个属性表示 <em>执行node所在的.exe文件</em> ，第二个属性表示 <em>当前执行的文件</em> 。</p><p>在实际场景中，我们可能会在命令行中输入其他需要传入的指令。</p><p>比如要启动一个server程序，我们就需要拟定一个端口号<code>--port 3000</code>。我们再使用上面的变量，输出的结果就会多出来 <code>--port</code> 和 <code>3000</code>。这样我们就可以对用户传递的参数进行解析，从而生成对应的功能。</p><p>（<em>我们也可以使用 *</em><span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY29tbWFuZGVy">commander<i class="fa fa-external-link-alt"></i></span>** 来解析我们想要的参数。后续文章中，我们也会使用此插件，开发一套cli脚手架。*）</p><h4 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h4><p>表示<strong>延迟加载</strong>，他和<code>setImmediate()</code>都属于延迟加载。但是setImmediate是<strong>将任务放到队列前面</strong>，而nextTick是<strong>将任务放到队列末尾</strong>。</p><p><em>下一篇文章我会细讲一下nextTick。</em></p><hr><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr&gt;&lt;h2 id=&quot;Node中的全局对象&quot;&gt;&lt;a href=&quot;#Node中的全局对象&quot; class=&quot;headerlink&quot; title=&quot;Node中的全局对象&quot;&gt;&lt;/a&gt;Node中的全局对象&lt;/h2&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://mxshang.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="知识点汇总" scheme="https://mxshang.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    
    <category term="Node" scheme="https://mxshang.github.io/tags/Node/"/>
    
    <category term="JS进阶" scheme="https://mxshang.github.io/tags/JS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记—Node的基本概念</title>
    <link href="https://mxshang.github.io/2021/11/02/Node%E7%B1%BB/Node-%E4%B8%8A/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://mxshang.github.io/2021/11/02/Node%E7%B1%BB/Node-%E4%B8%8A/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Node%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2021-11-02T11:25:22.000Z</published>
    <updated>2021-11-04T10:50:15.024Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。</p></blockquote><hr><h2 id="Node的基本概念"><a href="#Node的基本概念" class="headerlink" title="Node的基本概念"></a>Node的基本概念</h2><h3 id="什么是Node？"><a href="#什么是Node？" class="headerlink" title="什么是Node？"></a>什么是Node？</h3><p>Node.js是一个基于 Chrome V8 引擎的JavaScript运行环境(runtime)，Node不是一门语言是让js运行在后端的运行时，并且不包括javascript全集，因为在服务端中不包含DOM和BOM，Node也提供了一些新的模块例如http、fs模块等。Node.js 使用了事件驱动、非阻塞式 I/O 的模型，使其轻量又高效并且Node.js 的包管理器 npm，是全球最大的开源库生态系统。到此我们已经对node有了简单的概念。</p><h3 id="Node的高并发"><a href="#Node的高并发" class="headerlink" title="Node的高并发"></a>Node的高并发</h3><p>Node在处理高并发，I/O密集场景有明显的性能优势。</p><ul><li>高并发，是指在同一时间并发访问服务器。</li><li>I/O密集指的是文件操作、网络操作、数据库,相对的有CPU密集，CPU密集指的是逻辑处理运算、压缩、解压、加密、解密。</li></ul><p>Web主要场景就是接收客户端的请求读取静态资源和渲染界面，所以Node非常适合Web应用的开发。</p><p>说到高并发，肯定就会想起多线程。那么多线程和高并发之间的关系和区别又是什么呢？</p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>首先我们先来了解一下什么是<strong>多线程</strong></p><p><img data-src="pic1.png" alt="多线程示意图"></p><p>后端语言（包括Java、C++等）存在一个<strong>线程池</strong>，每发送一次请求，线程池都会分配一个线程给服务器，用来处理请求，以此类推。因为多线程语言的特点是<strong>同步请求</strong>，所以在多线程发送请求时，可能会存在单个线程阻塞的情况，需要等待当前这个线程的任务处理完毕后，才会释放线程并放回到线程池，方便下一批任务的使用。当前线程数超过线程池最大可分配数量时，可能就会出现等待的情况。</p><ul><li><p><strong>多线程优点</strong>：可以<em>高效高速的处理多个api请求</em>（<em>图片压缩、大量计算 等…</em>），属于<strong>cpu密集型</strong>。</p></li><li><p><strong>多线程缺点</strong>：<em>不安全性</em>，假设我们有多个线程需要对数据库同一个资源进行操作（例如对同一个数据进行修改），就会出现数据安全性的问题 [<em>需要对资源进行加锁操作</em>]。</p></li></ul><p>多线程并非一起做某一件事，靠的是切换上下文（分时），所以<strong>多线程会浪费一些资源</strong>。</p><blockquote><p>关于多线程的具体概念，可以去查阅相关的资料。</p></blockquote><h4 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h4><p><strong>高并发</strong>是单线程的一个概念。</p><ul><li><strong>高并发优点</strong>：不需要开启多个线程，<strong>节省资源</strong>。</li><li><strong>高并发缺点</strong>：<strong>不适合做复杂操作</strong>，如果需要做复杂操作，可以开启子进程。</li></ul><p><em>Node是多线程的，但是其主线程是单线程。所以我们一直都说，Node其实是单线程语言。</em></p><h3 id="同步异步和阻塞非阻塞"><a href="#同步异步和阻塞非阻塞" class="headerlink" title="同步异步和阻塞非阻塞"></a>同步异步和阻塞非阻塞</h3><ul><li><strong>同步</strong>就是在执行某段代码时，代码没有得到返回之前，其他代码无法执行，当得到了返回值后可以继续执行其他代码。</li><li><strong>异步</strong>就是在执行某段代码时，代码不会立即得到返回结果，可以继续执行其他代码，返回值通过回调来获取。</li></ul><blockquote><p>关于<a href="https://mxshang.github.io/2021/10/26/Promise/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Generator%E5%92%8Casync-await/">同步阻塞与异步非阻塞</a>，可以参考我之前的文章。</p></blockquote><h3 id="Node中的EventLoop"><a href="#Node中的EventLoop" class="headerlink" title="Node中的EventLoop"></a>Node中的EventLoop</h3><p><img data-src="pic2.png" alt="Node中EventLoop原理"></p><ul><li>1.我们写的js代码会交给v8引擎进行处理。</li><li>2.代码中可能会调用nodeApi，node会交给libuv库处理</li><li>3.libuv通过阻塞i/o和多线程实现了异步io。</li><li>4.通过事件驱动的方式，将结果放到事件队列中，最终交给我们的应用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数。</span><br><span class="line">   ┌───────────────────────────┐</span><br><span class="line">┌─&gt;│           timers          │ </span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">|   执行延迟到下一个循环迭代的 I&#x2F;O 回调。</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │     pending callbacks     │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">|   仅系统内部使用。</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │       idle, prepare       │</span><br><span class="line">│  └─────────────┬─────────────┘      </span><br><span class="line">|  检索新的I&#x2F;O事件;执行与 I&#x2F;O相关的回调  ┌───────────────┐</span><br><span class="line">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class="line">│  │           poll            │&lt;─────┤  connections, │</span><br><span class="line">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class="line">│  setImmediate() 回调函数在这里执行。  └───────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐      </span><br><span class="line">│  │           check           │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">|  一些关闭的回调函数</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">└──┤      close callbacks      │  </span><br><span class="line">   └───────────────────────────┘</span><br></pre></td></tr></table></figure><p>这里每一个阶段都对应一个事件队列,当event loop执行到某个阶段时会将当前阶段对应的队列依次执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段。</p><p><em><code>process.nextTick()</code> 从技术上讲不是事件循环的一部分。优先级高于微任务</em></p><p><strong>poll阶段:</strong></p><ol><li><p>检测Poll队列中是否为空，如果不为空则执行队列中的任务，直到超时或者全部执行完毕。</p></li><li><p>执行完毕后检测setImmediate队列是否为空，如果不为空则执行check阶段，如果为空则等待时间到达。时间到达后回到timer阶段</p></li><li><p>等待时间到达是可能会出现新的callback，此时也在当前阶段被清空</p></li></ol><hr><blockquote><p>本篇文章由<strong>莫小尚</strong>创作，文章中如有任何问题和纰漏，欢迎您的指正与交流。<br>您也可以关注我的 <a href="https://mxshang.github.io">个人站点</a>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW94aWFvc2hhbmcv">博客园<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8xNTkxNzQ4NTY3NzYyNzc2">掘金<i class="fa fa-external-link-alt"></i></span>，我会在文章产出后同步上传到这些平台上。<br>最后感谢您的支持！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;日常的学习笔记，包括 ES6、Promise、Node.js、Webpack、http 原理、Vue全家桶，后续可能还会继续更新 Typescript、Vue3 和 常见的面试题 等等。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr&gt;&lt;h2 id=&quot;Node的基本概念&quot;&gt;&lt;a href=&quot;#Node的基本概念&quot; class=&quot;headerlink&quot; title=&quot;Node的基本概念&quot;&gt;&lt;/a&gt;Node的基本概念&lt;/h2&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://mxshang.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="知识点汇总" scheme="https://mxshang.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    
    <category term="Node" scheme="https://mxshang.github.io/tags/Node/"/>
    
    <category term="JS进阶" scheme="https://mxshang.github.io/tags/JS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
</feed>
